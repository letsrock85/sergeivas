"use strict";
var jsxRuntime = require("react/jsx-runtime"), ui = require("@sanity/ui"), React = require("react"), icons = require("@sanity/icons"), sanity = require("sanity"), uuid = require("@sanity/uuid"), framerMotion = require("framer-motion"), styled = require("styled-components"), getJsonStream = require("./getJsonStream.js"), router$1 = require("sanity/router"), orderBy = require("lodash/orderBy.js"), isEqual = require("lodash/isEqual.js"), react$1 = require("@sanity/telemetry/react"), template = require("lodash/template.js"), react = require("@portabletext/react"), color = require("@sanity/color"), types = require("@sanity/types"), reactI18next = require("react-i18next"), portableTextEditor = require("@sanity/portable-text-editor"), schema$1 = require("@sanity/schema"), theme = require("@sanity/ui/theme"), deburr = require("lodash/deburr.js"), reactRx = require("react-rx"), rxjs = require("rxjs"), CopyToClipboard = require("react-copy-to-clipboard"), isNumber = require("lodash/isNumber.js"), isString = require("lodash/isString.js"), PathUtils = require("@sanity/util/paths"), omit = require("lodash/omit.js"), operators = require("rxjs/operators"), uniqBy = require("lodash/uniqBy.js"), negate = require("lodash/negate.js"), throttle = require("lodash/throttle.js"), scrollIntoView = require("scroll-into-view-if-needed"), findIndex = require("lodash/findIndex.js"), diffMatchPatch = require("@sanity/diff-match-patch"), isHotkey = require("is-hotkey"), JSONInspector = require("@rexxars/react-json-inspector"), HLRU = require("hashlru"), telemetry = require("@sanity/telemetry"), _internal = require("@sanity/schema/_internal"), deepEquals = require("react-fast-compare"), shallowEquals = require("shallow-equals"), _internalBrowser = require("sanity/_internalBrowser"), rxjsExhaustmapWithTrailing = require("rxjs-exhaustmap-with-trailing"), camelCase = require("lodash/camelCase.js"), speakingurl = require("speakingurl"), uniqueId = require("lodash/uniqueId.js"), reactIs = require("react-is"), uniq = require("lodash/uniq.js"), kebabCase = require("lodash/kebabCase.js"), generateHelpUrl = require("@sanity/generate-help-url"), find = require("lodash/find.js"), startCase = require("lodash/startCase.js"), legacyDateFormat = require("@sanity/util/legacyDateFormat"), FocusLock = require("react-focus-lock"), mendoza = require("mendoza"), assetUtils = require("@sanity/asset-utils"), imageUrlBuilder = require("@sanity/image-url"), dateFns = require("date-fns"), debounce = require("lodash/debounce.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e)
    return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
var React__namespace = /* @__PURE__ */ _interopNamespaceCompat(React), styled__default = /* @__PURE__ */ _interopDefaultCompat(styled), orderBy__default = /* @__PURE__ */ _interopDefaultCompat(orderBy), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual), template__default = /* @__PURE__ */ _interopDefaultCompat(template), deburr__default = /* @__PURE__ */ _interopDefaultCompat(deburr), CopyToClipboard__default = /* @__PURE__ */ _interopDefaultCompat(CopyToClipboard), isNumber__default = /* @__PURE__ */ _interopDefaultCompat(isNumber), isString__default = /* @__PURE__ */ _interopDefaultCompat(isString), PathUtils__namespace = /* @__PURE__ */ _interopNamespaceCompat(PathUtils), omit__default = /* @__PURE__ */ _interopDefaultCompat(omit), uniqBy__default = /* @__PURE__ */ _interopDefaultCompat(uniqBy), negate__default = /* @__PURE__ */ _interopDefaultCompat(negate), throttle__default = /* @__PURE__ */ _interopDefaultCompat(throttle), scrollIntoView__default = /* @__PURE__ */ _interopDefaultCompat(scrollIntoView), findIndex__default = /* @__PURE__ */ _interopDefaultCompat(findIndex), isHotkey__default = /* @__PURE__ */ _interopDefaultCompat(isHotkey), JSONInspector__default = /* @__PURE__ */ _interopDefaultCompat(JSONInspector), HLRU__default = /* @__PURE__ */ _interopDefaultCompat(HLRU), deepEquals__default = /* @__PURE__ */ _interopDefaultCompat(deepEquals), shallowEquals__default = /* @__PURE__ */ _interopDefaultCompat(shallowEquals), camelCase__default = /* @__PURE__ */ _interopDefaultCompat(camelCase), speakingurl__default = /* @__PURE__ */ _interopDefaultCompat(speakingurl), uniqueId__default = /* @__PURE__ */ _interopDefaultCompat(uniqueId), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq), kebabCase__default = /* @__PURE__ */ _interopDefaultCompat(kebabCase), find__default = /* @__PURE__ */ _interopDefaultCompat(find), startCase__default = /* @__PURE__ */ _interopDefaultCompat(startCase), FocusLock__default = /* @__PURE__ */ _interopDefaultCompat(FocusLock), imageUrlBuilder__default = /* @__PURE__ */ _interopDefaultCompat(imageUrlBuilder), debounce__default = /* @__PURE__ */ _interopDefaultCompat(debounce);
const commentsLocaleNamespace = "comments", commentsUsEnglishLocaleBundle = sanity.defineLocaleResourceBundle({
  locale: "en-US",
  namespace: commentsLocaleNamespace,
  resources: () => Promise.resolve().then(function() {
    return require("./resources.js");
  })
}), DOCUMENT_PANEL_MIN_WIDTH = 320, DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600, DOCUMENT_INSPECTOR_MIN_WIDTH = 320, DOCUMENT_INSPECTOR_MAX_WIDTH = 540, EMPTY_PARAMS$2 = {}, INSPECT_ACTION_PREFIX = "inspect:", DEFAULT_MENU_ITEM_GROUPS = [{ id: "inspectors" }, { id: "links" }], HISTORY_INSPECTOR_NAME = "sanity/structure/history", VALIDATION_INSPECTOR_NAME = "sanity/structure/validation", COMMENTS_INSPECTOR_NAME = "sanity/structure/comments", separator = /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) }), renderItem = (item, index) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "li", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", size: 1, weight: "medium", children: item }) }, `${item}-${index}`);
function CommentBreadcrumbs(props) {
  const { titlePath, maxLength } = props, items = React.useMemo(() => {
    const len = titlePath.length, beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
    return maxLength && len > maxLength ? [
      ...titlePath.slice(0, beforeLength - 1),
      titlePath.slice(beforeLength - 1, len - afterLength),
      ...titlePath.slice(len - afterLength)
    ] : titlePath;
  }, [maxLength, titlePath]), nodes = React.useMemo(() => items.map((item, index) => {
    const key = `${item}-${index}`, showSeparator = index < items.length - 1;
    return Array.isArray(item) ? /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Tooltip,
        {
          content: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, padding: 2, children: item.map(renderItem) }),
          children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: renderItem("...", index) })
        }
      ),
      showSeparator && separator
    ] }, key) : /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
      renderItem(item, index),
      showSeparator && separator
    ] }, key);
  }), [items]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", as: "ol", gap: 2, children: nodes });
}
function getDialogCopy(t) {
  return {
    thread: {
      title: t("delete-thread.title"),
      body: t("delete-thread.body"),
      confirmButtonText: t("delete-thread.confirm")
    },
    comment: {
      title: t("delete-comment.title"),
      body: t("delete-comment.body"),
      confirmButtonText: t("delete-comment.confirm")
    }
  };
}
function CommentDeleteDialog(props) {
  const { isParent, onClose, commentId, onConfirm, loading, error } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), dialogCopy = getDialogCopy(t), { title, body, confirmButtonText } = dialogCopy[isParent ? "thread" : "comment"], handleDelete = React.useCallback(() => {
    onConfirm(commentId);
  }, [commentId, onConfirm]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      footer: {
        cancelButton: {
          onClick: onClose
        },
        confirmButton: {
          loading,
          onClick: handleDelete,
          text: confirmButtonText,
          tone: "critical"
        }
      },
      header: title,
      id: "delete-comment-dialog",
      onClose,
      width: 0,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: body }),
        error && /* @__PURE__ */ jsxRuntime.jsx(sanity.TextWithTone, { tone: "critical", children: t("delete-dialog.error") })
      ] })
    }
  );
}
const CommentDisabledIcon = React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      "data-sanity-icon": "comment-disabled",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M5.92627 14.5381H7.92627V18.5381L11.9263 14.5381H15.9263C17.0308 14.5381 17.9263 13.6427 17.9263 12.5381V6.53809C17.9263 5.43352 17.0308 4.53809 15.9263 4.53809H5.92627C4.8217 4.53809 3.92627 5.43352 3.92627 6.53809V12.5381C3.92627 13.6427 4.8217 14.5381 5.92627 14.5381Z",
            stroke: "currentColor",
            strokeWidth: "1.2",
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M2.77256 2.66835C2.54413 2.51319 2.23317 2.57259 2.07802 2.80103L1.40378 3.7937C1.32927 3.9034 1.30139 4.0382 1.32627 4.16845C1.35115 4.29871 1.42676 4.41374 1.53646 4.48825L19.5861 16.7479C19.8146 16.903 20.1255 16.8436 20.2807 16.6152L20.9549 15.6225C21.0294 15.5128 21.0573 15.378 21.0324 15.2478C21.0076 15.1175 20.9319 15.0025 20.8222 14.928L2.77256 2.66835Z",
            fill: "currentColor",
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
}), CommentIcon = React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    "svg",
    {
      "data-sanity-icon": "comment",
      width: "1em",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          d: "M7.5 15.5H9.5V19.5L13.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V7.5C19.5 6.39543 18.6046 5.5 17.5 5.5H7.5C6.39543 5.5 5.5 6.39543 5.5 7.5V13.5C5.5 14.6046 6.39543 15.5 7.5 15.5Z",
          stroke: "currentColor",
          strokeLinejoin: "round",
          strokeWidth: "1.2"
        }
      )
    }
  );
}), MentionIcon = React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      "data-sanity-icon": "mention",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M16.6633 18.9383C15.539 19.6562 14.2034 20.0723 12.7705 20.0723C8.77022 20.0723 5.52734 16.8294 5.52734 12.8291C5.52734 8.82881 8.77022 5.58594 12.7705 5.58594C16.7708 5.58594 20.0137 8.82881 20.0137 12.8291C20.0137 13.6623 19.8249 14.7093 19.6141 15.2077C19.5578 15.3408 19.479 15.4845 19.3936 15.6238C19.0955 16.1106 18.5507 16.3721 17.9807 16.4018V16.4018C16.8271 16.462 15.8588 15.5428 15.8588 14.3877V9.27302",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: "12.5732", cy: "12.8291", r: "3.08691", stroke: "currentColor", strokeWidth: 1.2 })
      ]
    }
  );
}), ReactionIcon = React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxRuntime.jsxs(
    "svg",
    {
      "data-sanity-icon": "add-reaction",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M10.1044 10.4011L10.1044 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M14.2393 10.4011L14.2393 10.9972",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M7.12128 14.1151C7.70803 15.0226 9.66113 16.8377 11.7735 16.8377C13.8859 16.8377 15.6713 15.0226 16.4257 14.1151",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square"
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            d: "M16.703 6.43905C15.3486 5.36511 13.6357 4.72374 11.773 4.72374C7.38731 4.72374 3.83203 8.27902 3.83203 12.6647C3.83203 17.0503 7.38731 20.6056 11.773 20.6056C16.0995 20.6056 19.618 17.1455 19.712 12.8415",
            stroke: "currentColor",
            strokeWidth: 1.2
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M19.1135 9.03425L19.1135 11.4903L20.3135 11.4903L20.3135 9.03425L22.7693 9.03425L22.7693 7.83425L20.3135 7.83425L20.3135 5.37941L19.1135 5.37941L19.1135 7.83425L16.6584 7.83425L16.6584 9.03425L19.1135 9.03425Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
}), SendIcon = React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    "svg",
    {
      "data-sanity-icon": "send",
      fill: "none",
      height: "1em",
      ref,
      viewBox: "0 0 25 25",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg",
      ...props,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        "path",
        {
          clipRule: "evenodd",
          d: "M21.1602 12.5L7.16016 19.5V14.8765L13.6656 12.4989L7.16016 9.97149L7.16016 5.5L21.1602 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
}), CommentsAuthoringPathContext = React.createContext(
  null
);
function CommentsAuthoringPathProvider(props) {
  const { children } = props, [authoringPath, setAuthoringPath] = React.useState(null), handleSetAuthoringPath = React.useCallback((nextAuthoringPath) => {
    setAuthoringPath(nextAuthoringPath);
  }, []), value = React.useMemo(
    () => ({
      authoringPath,
      setAuthoringPath: handleSetAuthoringPath
    }),
    [authoringPath, handleSetAuthoringPath]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsAuthoringPathContext.Provider, { value, children });
}
const CommentsContext = React.createContext(null);
function getSchemaField(schemaType, fieldPath) {
  var _a;
  const paths = PathUtils__namespace.fromString(fieldPath), firstPath = paths[0];
  if (firstPath && types.isObjectSchemaType(schemaType)) {
    const field = (_a = schemaType == null ? void 0 : schemaType.fields) == null ? void 0 : _a.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = PathUtils__namespace.toString(paths.slice(1));
      return nextPath ? getSchemaField(field.type, nextPath) : field;
    }
  }
}
function findArrayItemIndex(array, pathSegment) {
  if (typeof pathSegment == "number")
    return pathSegment;
  const index = findIndex__default.default(array, pathSegment);
  return index === -1 ? !1 : index;
}
function buildCommentBreadcrumbs(props) {
  const { currentUser, schemaType, fieldPath, documentValue } = props, paths = PathUtils__namespace.fromString(fieldPath), fieldPaths = [];
  let currentSchemaType = null;
  return paths.forEach((seg, index) => {
    var _a, _b, _c, _d, _e;
    const currentPath = paths.slice(0, index + 1), previousPath = paths.slice(0, index), field = getSchemaField(schemaType, PathUtils__namespace.toString(currentPath)), isKeySegment = seg.hasOwnProperty("_key"), parentValue = sanity.getValueAtPath(documentValue, previousPath), currentValue = sanity.getValueAtPath(documentValue, currentPath), conditionalContext = {
      document: documentValue,
      currentUser,
      parent: parentValue,
      value: currentValue
    };
    if (isKeySegment && Array.isArray(parentValue)) {
      const arrayItemIndex = findArrayItemIndex(parentValue, seg), isNumber2 = typeof arrayItemIndex == "number";
      fieldPaths.push({
        invalid: arrayItemIndex === !1,
        isArrayItem: !0,
        title: isNumber2 ? `#${Number(arrayItemIndex) + 1}` : "Unknown array item"
      });
      return;
    }
    if (field != null && field.type) {
      const hidden = sanity.resolveConditionalProperty(field.type.hidden, conditionalContext);
      fieldPaths.push({
        invalid: hidden,
        isArrayItem: !1,
        title: sanity.getSchemaTypeTitle(field.type)
      }), currentSchemaType = field.type;
      return;
    }
    if (types.isArraySchemaType(currentSchemaType)) {
      const arrayValue = sanity.getValueAtPath(documentValue, previousPath), objectType = arrayValue == null ? void 0 : arrayValue._type, objectField = (_a = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _a.find(
        (type) => type.name === objectType
      ), currentField = (_b = objectField == null ? void 0 : objectField.fields) == null ? void 0 : _b.find(
        (f) => f.name === seg
      );
      if (!objectType && currentValue) {
        const allCurrentFields = (_c = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _c.map((o) => o == null ? void 0 : o.fields).filter(Boolean).flat(), anonymousField = allCurrentFields == null ? void 0 : allCurrentFields.find((f) => (f == null ? void 0 : f.name) === seg), hidden = sanity.resolveConditionalProperty((_d = anonymousField == null ? void 0 : anonymousField.type) == null ? void 0 : _d.hidden, conditionalContext);
        anonymousField && (fieldPaths.push({
          invalid: hidden,
          isArrayItem: !1,
          title: sanity.getSchemaTypeTitle(anonymousField == null ? void 0 : anonymousField.type)
        }), currentSchemaType = anonymousField == null ? void 0 : anonymousField.type);
        return;
      }
      if (!currentField) {
        fieldPaths.push({
          invalid: !0,
          isArrayItem: !1,
          title: "Unknown field"
        });
        return;
      }
      const currentTitle = sanity.getSchemaTypeTitle(currentField == null ? void 0 : currentField.type), objectFieldHidden = sanity.resolveConditionalProperty(
        (_e = objectField == null ? void 0 : objectField.type) == null ? void 0 : _e.hidden,
        conditionalContext
      ), currentFieldHidden = sanity.resolveConditionalProperty(
        currentField == null ? void 0 : currentField.type.hidden,
        conditionalContext
      ), isHidden = objectFieldHidden || currentFieldHidden;
      fieldPaths.push({
        invalid: isHidden,
        isArrayItem: !1,
        title: currentTitle
      }), currentSchemaType = currentField == null ? void 0 : currentField.type;
      return;
    }
    fieldPaths.push({
      invalid: !0,
      isArrayItem: !1,
      title: "Unknown field"
    });
  }), fieldPaths;
}
function useCommentHasChanged(message) {
  const prevMessage = React.useRef(message);
  return React.useMemo(() => !isEqual__default.default(prevMessage.current, message), [message]);
}
function hasCommentMessageValue(value) {
  return value ? value == null ? void 0 : value.some(
    (block) => {
      var _a;
      return sanity.isPortableTextTextBlock(block) && ((_a = (block == null ? void 0 : block.children) || []) == null ? void 0 : _a.some((c) => sanity.isPortableTextSpan(c) ? c.text : c.userId));
    }
  ) : !1;
}
function commentIntentIfDiffers(parent, comment) {
  var _a, _b;
  const parentIntent = (_a = parent == null ? void 0 : parent.context) == null ? void 0 : _a.intent, intent = (_b = comment == null ? void 0 : comment.context) == null ? void 0 : _b.intent;
  if (intent && (!parentIntent || "preview" in intent.params && "preview" in parentIntent.params && intent.params.preview !== parentIntent.params.preview))
    return intent;
}
function isTextSelectionComment(comment) {
  var _a, _b, _c, _d, _e, _f;
  return comment ? !!(((_c = (_b = (_a = comment == null ? void 0 : comment.target) == null ? void 0 : _a.path) == null ? void 0 : _b.selection) == null ? void 0 : _c.type) === "text" && (_f = (_e = (_d = comment == null ? void 0 : comment.target) == null ? void 0 : _d.path) == null ? void 0 : _e.selection) != null && _f.value) : !1;
}
const EMPTY_ARRAY$j = [];
function buildCommentThreadItems(props) {
  const { comments: comments2, currentUser, documentValue, schemaType, type } = props, parentComments = comments2 == null ? void 0 : comments2.filter((c) => !c.parentCommentId);
  return type === "task" ? parentComments.map((parentComment) => {
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
    return {
      commentsCount: [parentComment, ...replies].length,
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue: !1,
      breadcrumbs: EMPTY_ARRAY$j,
      fieldPath: ""
    };
  }) : type === "field" ? parentComments.map((parentComment) => {
    var _a, _b, _c;
    const crumbs = buildCommentBreadcrumbs({
      currentUser,
      documentValue,
      fieldPath: ((_a = parentComment.target.path) == null ? void 0 : _a.field) || "",
      schemaType
    });
    let hasTextSelection = !1;
    if (isTextSelectionComment(parentComment) && (hasTextSelection = !!((_b = parentComment.target.path) != null && _b.selection && parentComment.target.path.selection.value.some((v) => v.text))), crumbs.some((bc) => bc.invalid))
      return;
    const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id), commentsCount = [parentComment, ...replies].length, hasReferencedValue = hasTextSelection;
    return {
      breadcrumbs: crumbs,
      commentsCount,
      fieldPath: ((_c = parentComment.target.path) == null ? void 0 : _c.field) || "",
      parentComment,
      replies,
      threadId: parentComment.threadId,
      hasReferencedValue
    };
  }).filter(Boolean) : EMPTY_ARRAY$j;
}
const DMP_MARGIN = 15;
function diffText(current, next) {
  const diff = diffMatchPatch.makeDiff(current, next), diffs = diffMatchPatch.cleanupEfficiency(diff), levenshtein = diffsLevenshtein(diffs);
  return { patches: diffMatchPatch.makePatches(current, diffs, { margin: DMP_MARGIN }), levenshtein };
}
function diffApply(current, patches) {
  return diffMatchPatch.applyPatches(patches, current, {
    allowExceedingIndices: !0,
    margin: DMP_MARGIN
  })[0];
}
const CHILD_SYMBOL = "\uF0D0";
function toPlainTextWithChildSeparators(inputBlock) {
  return inputBlock.children.map((child) => types.isPortableTextSpan(child) ? child.text.replaceAll(CHILD_SYMBOL, " ") : "").join(CHILD_SYMBOL);
}
const COMMENT_INDICATORS = ["\uF000", "\uF001"], COMMENT_INDICATORS_REGEX = new RegExp(`[${COMMENT_INDICATORS.join("")}]`, "g"), EMPTY_ARRAY$i = [];
function buildRangeDecorationSelectionsFromComments(props) {
  const { value, comments: comments2 } = props;
  if (!value || value.length === 0)
    return EMPTY_ARRAY$i;
  const textSelections = comments2.filter(isTextSelectionComment), decorators = [];
  return textSelections.forEach((comment) => {
    var _a, _b;
    (_b = (_a = comment.target.path) == null ? void 0 : _a.selection) == null || _b.value.forEach((selectionMember) => {
      const matchedBlock = value.find((block) => block._key === selectionMember._key);
      if (!matchedBlock || !types.isPortableTextTextBlock(matchedBlock))
        return;
      const selectionText = selectionMember.text.replaceAll(COMMENT_INDICATORS_REGEX, ""), textWithChildSeparators = toPlainTextWithChildSeparators(matchedBlock), { patches } = diffText(selectionText, selectionMember.text), diffedText = diffApply(textWithChildSeparators, patches), startIndex = diffedText.indexOf(COMMENT_INDICATORS[0]), endIndex = diffedText.replaceAll(COMMENT_INDICATORS[0], "").indexOf(COMMENT_INDICATORS[1]), textWithoutCommentTags = diffedText.replaceAll(COMMENT_INDICATORS_REGEX, ""), oldCommentedText = selectionMember.text.substring(
        selectionMember.text.indexOf(COMMENT_INDICATORS[0]) + 1,
        selectionMember.text.indexOf(COMMENT_INDICATORS[1])
      ), newCommentedText = textWithoutCommentTags.substring(startIndex, endIndex), { levenshtein } = diffText(newCommentedText, oldCommentedText), threshold = Math.round(newCommentedText.length + oldCommentedText.length / 2);
      let nullSelection = !1;
      if (newCommentedText.length === 0 && (nullSelection = !0), levenshtein > threshold && (nullSelection = !0), startIndex + 1 === endIndex && (nullSelection = !0), startIndex !== -1 && endIndex !== -1) {
        let childIndexAnchor = 0, anchorOffset = 0, childIndexFocus = 0, focusOffset = 0;
        for (let i = 0; i < textWithoutCommentTags.length && (textWithoutCommentTags[i] === CHILD_SYMBOL && (i <= startIndex && (anchorOffset = -1, childIndexAnchor++), focusOffset = -1, childIndexFocus++), i < startIndex && anchorOffset++, i < startIndex + newCommentedText.length && focusOffset++, i !== startIndex + newCommentedText.length); i++)
          ;
        decorators.push({
          selection: {
            anchor: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexAnchor]._key }
              ],
              offset: anchorOffset
            },
            focus: {
              path: [
                { _key: matchedBlock._key },
                "children",
                { _key: matchedBlock.children[childIndexFocus]._key }
              ],
              offset: focusOffset
            }
          },
          comment,
          range: { _key: matchedBlock._key, text: nullSelection ? "" : diffedText }
        });
      }
    });
  }), decorators.length === 0 ? EMPTY_ARRAY$i : decorators;
}
function diffsLevenshtein(diffs) {
  let levenshtein = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case diffMatchPatch.DIFF_INSERT:
        insertions += data.length;
        break;
      case diffMatchPatch.DIFF_DELETE:
        deletions += data.length;
        break;
      case diffMatchPatch.DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
    }
  }
  return levenshtein += Math.max(insertions, deletions), levenshtein;
}
const CommentRangeDecoration = React.memo(function(props) {
  const {
    children,
    commentId,
    currentHoveredCommentId,
    onClick,
    onHoverEnd,
    onHoverStart,
    selectedThreadId,
    threadId
  } = props, decoratorRef = React.useRef(null), isNestedRef = React.useRef(!1), parentCommentId = React.useRef(null);
  React.useEffect(() => {
    var _a, _b;
    const prevEl = (_a = decoratorRef.current) == null ? void 0 : _a.previousSibling, nextEl = (_b = decoratorRef.current) == null ? void 0 : _b.nextSibling;
    if (!prevEl || !nextEl) {
      isNestedRef.current = !1;
      return;
    }
    const [key] = Object.keys(applyInlineCommentIdAttr("")), prevId = prevEl.getAttribute(key), nextId = nextEl.getAttribute(key), isNestedDecorator = !!(prevId && nextId && prevId === nextId);
    parentCommentId.current = isNestedDecorator ? prevId : null, isNestedRef.current = isNestedDecorator;
  }, []);
  const handleMouseEnter = React.useCallback(() => onHoverStart(commentId), [commentId, onHoverStart]), handleMouseLeave = React.useCallback(() => onHoverEnd(null), [onHoverEnd]), handleClick = React.useCallback(() => onClick(commentId), [commentId, onClick]), hovered = currentHoveredCommentId === commentId || currentHoveredCommentId === parentCommentId.current && isNestedRef.current;
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommentInlineHighlightSpan,
    {
      isAdded: !0,
      isHovered: hovered || selectedThreadId === threadId,
      isNested: isNestedRef.current,
      onClick: handleClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ref: decoratorRef,
      ...applyInlineCommentIdAttr(threadId),
      children
    }
  );
});
function buildRangeDecorations(props) {
  const {
    comments: comments2,
    currentHoveredCommentId,
    onDecorationClick,
    onDecorationHoverEnd,
    onDecorationHoverStart,
    onDecorationMoved,
    selectedThreadId,
    value
  } = props;
  return buildRangeDecorationSelectionsFromComments({ comments: comments2, value }).map(({ selection, comment, range }) => ({
    component: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(
      CommentRangeDecoration,
      {
        commentId: comment._id,
        currentHoveredCommentId,
        onClick: onDecorationClick,
        onHoverEnd: onDecorationHoverEnd,
        onHoverStart: onDecorationHoverStart,
        selectedThreadId,
        threadId: comment.threadId,
        children
      }
    ),
    onMoved: onDecorationMoved,
    selection,
    payload: {
      commentId: comment._id,
      range
    }
  }));
}
function buildTextSelectionFromFragment(props) {
  const { fragment, value, selection } = props;
  if (!selection)
    throw new Error("Selection is required");
  const normalizedSelection = selection.backward ? { backward: !1, anchor: selection.focus, focus: selection.anchor } : selection;
  return {
    type: "text",
    value: fragment.map((fragmentBlock) => {
      const originalBlock = value.find((b) => b._key === fragmentBlock._key);
      if (!types.isPortableTextTextBlock(originalBlock))
        return {
          _key: fragmentBlock._key,
          text: ""
        };
      const anchorBlockKey = types.isKeySegment(normalizedSelection.anchor.path[0]) && normalizedSelection.anchor.path[0]._key, focusBlockKey = types.isKeySegment(normalizedSelection.focus.path[0]) && normalizedSelection.focus.path[0]._key, fragmentBlockText = react.toPlainText([fragmentBlock]), fragmentStartSpan = types.isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[0] : void 0, fragmentEndSpan = types.isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[fragmentBlock.children.length - 1] : void 0;
      let originalTextBeforeSelection = "", startChildIndex = -1;
      if (anchorBlockKey === originalBlock._key)
        for (const child of originalBlock.children) {
          if (startChildIndex++, child._key === (fragmentStartSpan == null ? void 0 : fragmentStartSpan._key)) {
            originalTextBeforeSelection += types.isPortableTextSpan(child) && child.text.substring(0, normalizedSelection.anchor.offset) || "";
            break;
          }
          originalTextBeforeSelection += child.text;
        }
      let originalTextAfterSelection = "";
      if (focusBlockKey === originalBlock._key)
        for (const child of originalBlock.children.slice(startChildIndex).reverse()) {
          if (child._key === (fragmentEndSpan == null ? void 0 : fragmentEndSpan._key)) {
            originalTextAfterSelection = (types.isPortableTextSpan(child) && child.text.substring(normalizedSelection.focus.offset, child.text.length) || "") + originalTextAfterSelection;
            break;
          }
          originalTextAfterSelection = child.text + originalTextAfterSelection;
        }
      return {
        _key: originalBlock._key,
        text: `${originalTextBeforeSelection}${COMMENT_INDICATORS[0]}${fragmentBlockText}${COMMENT_INDICATORS[1]}${originalTextAfterSelection}`
      };
    })
  };
}
function mergeCommentReactions(reactionsA, reactionsB) {
  const mergedReactions = {};
  for (const reaction of reactionsA)
    mergedReactions[reaction._key] = { ...reaction };
  for (const reaction of reactionsB)
    mergedReactions[reaction._key] = { ...mergedReactions[reaction._key], ...reaction };
  return Object.values(mergedReactions);
}
function createCommentsSet(comments2) {
  return comments2.reduce((acc, comment) => ({ ...acc, [comment._id]: comment }), {});
}
function commentsReducer(state2, action) {
  var _a;
  switch (action.type) {
    case "COMMENTS_SET": {
      const commentsById = createCommentsSet(action.comments);
      return {
        ...state2,
        comments: commentsById
      };
    }
    case "COMMENT_ADDED": {
      const nextCommentResult = action.payload, nextCommentValue = nextCommentResult, nextComment = {
        [nextCommentResult._id]: {
          ...state2.comments[nextCommentResult._id],
          ...nextCommentValue,
          _state: nextCommentResult._state || void 0,
          // If the comment is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the comments correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the comment.
          // Once the comment is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextCommentResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state2,
        comments: {
          ...state2.comments,
          ...nextComment
        }
      };
    }
    case "COMMENT_RECEIVED": {
      const nextCommentResult = action.payload;
      return {
        ...state2,
        comments: {
          ...state2.comments,
          [nextCommentResult._id]: nextCommentResult
        }
      };
    }
    case "COMMENT_DELETED": {
      const { [action.id]: _, ...restComments } = state2.comments;
      return Object.keys(restComments).forEach((commentId) => {
        restComments[commentId].parentCommentId === action.id && delete restComments[commentId];
      }), {
        ...state2,
        comments: restComments
      };
    }
    case "COMMENT_UPDATED": {
      const updatedComment = action.payload, id = updatedComment._id, comment = state2.comments[id], optimisticReactions = ((_a = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a.filter((v) => v == null ? void 0 : v._optimisticState)) || [], incomingReactions = updatedComment.reactions || [], nextReactions = mergeCommentReactions(optimisticReactions, incomingReactions), nextComment = {
        // Add existing comment data
        ...comment,
        // Add incoming comment data
        ...updatedComment,
        // Add reactions merged with optimistic reactions
        reactions: nextReactions
      };
      return {
        ...state2,
        comments: {
          ...state2.comments,
          [id]: nextComment
        }
      };
    }
    default:
      return state2;
  }
}
const INITIAL_STATE$2 = {
  comments: {}
}, LISTEN_OPTIONS$1 = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
}, SORT_FIELD$1 = "_createdAt", SORT_ORDER$1 = "desc", QUERY_FILTERS$1 = ['_type == "comment"', "target.document._ref == $documentId"], QUERY_PROJECTION$1 = `{
  _createdAt,
  _id,
  authorId,
  contentSnapshot,
  context,
  lastEditedAt,
  message,
  parentCommentId,
  reactions,
  status,
  target,
  threadId
}`, QUERY_SORT_ORDER$1 = `order(${SORT_FIELD$1} ${SORT_ORDER$1})`, QUERY$1 = `*[${QUERY_FILTERS$1.join(" && ")}] ${QUERY_PROJECTION$1} | ${QUERY_SORT_ORDER$1}`;
function useCommentsStore(opts) {
  const { client, documentId, onLatestTransactionIdReceived, transactionsIdMap } = opts, [state2, dispatch] = React.useReducer(commentsReducer, INITIAL_STATE$2), [loading, setLoading] = React.useState(client !== null), [error, setError] = React.useState(null), didInitialFetch = React.useRef(!1), params = React.useMemo(() => ({ documentId: sanity.getPublishedId(documentId) }), [documentId]), initialFetch = React.useCallback(async () => {
    if (!client) {
      setLoading(!1);
      return;
    }
    try {
      const res = await client.fetch(QUERY$1, params);
      dispatch({ type: "COMMENTS_SET", comments: res }), setLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client, params]), handleListenerEvent = React.useCallback(
    async (event) => {
      var _a;
      if (event.type === "welcome" && !didInitialFetch.current && (setLoading(!0), await initialFetch(), setLoading(!1), didInitialFetch.current = !0), event.type === "reconnect" && (setLoading(!0), didInitialFetch.current = !1), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextComment = event.result;
          nextComment && dispatch({
            type: "COMMENT_RECEIVED",
            payload: nextComment
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "COMMENT_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedComment = event.result, id = ((_a = event.result) == null ? void 0 : _a._id) || "", transactionId = event.transactionId, latestTransactionId = transactionsIdMap.get(id), isLatestTransaction = transactionId === latestTransactionId;
          if (!isLatestTransaction && latestTransactionId)
            return;
          updatedComment && (dispatch({
            type: "COMMENT_UPDATED",
            payload: updatedComment
          }), isLatestTransaction && onLatestTransactionIdReceived(id));
        }
      }
    },
    [initialFetch, onLatestTransactionIdReceived, transactionsIdMap]
  ), listener$ = React.useMemo(() => client ? client.observable.listen(QUERY$1, params, LISTEN_OPTIONS$1).pipe(
    rxjs.catchError((err) => (setError(err), rxjs.of(err)))
  ) : rxjs.of(), [client, params]);
  return React.useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: React.useMemo(() => Object.values(state2.comments), [state2.comments]),
    dispatch,
    error,
    loading
  };
}
const EMPTY_ARRAY$h = [], EMPTY_COMMENTS_DATA = {
  open: EMPTY_ARRAY$h,
  resolved: EMPTY_ARRAY$h
}, CommentsProvider = React.memo(function(props) {
  const { children, documentId, documentType, isCommentsOpen, onCommentsOpen, sortOrder, type } = props, commentsEnabled = useCommentsEnabled(), [status, setStatus] = React.useState("open"), { client, createAddonDataset, isCreatingDataset } = sanity.useAddonDataset(), publishedId = sanity.getPublishedId(documentId), editState = sanity.useEditState(publishedId, documentType, "low"), schemaType = sanity.useSchema().get(documentType), currentUser = sanity.useCurrentUser(), { name: workspaceName, dataset, projectId } = sanity.useWorkspace(), documentValue = React.useMemo(() => editState.draft || editState.published, [editState.draft, editState.published]), documentRevisionId = React.useMemo(() => documentValue == null ? void 0 : documentValue._rev, [documentValue]), transactionsIdMap = React.useMemo(() => /* @__PURE__ */ new Map(), []), handleOnLatestTransactionIdReceived = React.useCallback(
    (commentDocumentId) => {
      transactionsIdMap.delete(commentDocumentId);
    },
    [transactionsIdMap]
  ), {
    dispatch,
    data = EMPTY_ARRAY$h,
    error,
    loading
  } = useCommentsStore({
    documentId: publishedId,
    client,
    transactionsIdMap,
    onLatestTransactionIdReceived: handleOnLatestTransactionIdReceived
  }), handleOnTransactionStart = React.useCallback(
    (commentDocumentId, transactionId) => {
      transactionsIdMap.set(commentDocumentId, transactionId);
    },
    [transactionsIdMap]
  ), handleSetStatus = React.useCallback(
    (newStatus) => commentsEnabled.mode === "upsell" && newStatus === "resolved" ? null : setStatus(newStatus),
    [setStatus, commentsEnabled]
  ), mentionOptions = sanity.useUserListWithPermissions(
    React.useMemo(() => ({ documentValue, permission: "read" }), [documentValue])
  ), threadItemsByStatus = React.useMemo(() => {
    if (!schemaType || !currentUser)
      return EMPTY_COMMENTS_DATA;
    const sorted = orderBy__default.default(data, ["_createdAt"], [sortOrder]), items = buildCommentThreadItems({
      comments: sorted,
      currentUser,
      documentValue,
      schemaType,
      type
    });
    return {
      open: items.filter((item) => item.parentComment.status === "open"),
      resolved: items.filter((item) => item.parentComment.status === "resolved")
    };
  }, [currentUser, data, documentValue, schemaType, sortOrder, type]), getThreadLength = React.useCallback(
    (threadId) => threadItemsByStatus.open.filter((item) => item.threadId === threadId).length,
    [threadItemsByStatus.open]
  ), getComment = React.useCallback((id) => data == null ? void 0 : data.find((c) => c._id === id), [data]), handleOnCreate = React.useCallback(
    (payload) => {
      var _a, _b;
      const hasError = ((_b = (_a = data == null ? void 0 : data.find((c) => c._id === payload._id)) == null ? void 0 : _a._state) == null ? void 0 : _b.type) === "createError";
      dispatch({
        type: "COMMENT_ADDED",
        payload: {
          ...payload,
          _state: hasError ? { type: "createRetrying" } : void 0
        }
      });
    },
    [data, dispatch]
  ), handleOnUpdate = React.useCallback(
    (id, payload) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id,
          ...payload
        }
      });
    },
    [dispatch]
  ), handleOnCreateError = React.useCallback(
    (id, err) => {
      dispatch({
        type: "COMMENT_UPDATED",
        payload: {
          _id: id,
          _state: {
            error: err,
            type: "createError"
          }
        }
      });
    },
    [dispatch]
  ), { operation } = useCommentOperations(
    React.useMemo(
      () => ({
        client,
        currentUser,
        dataset,
        documentId: publishedId,
        documentRevisionId,
        documentType,
        getComment,
        getThreadLength,
        projectId,
        schemaType,
        workspace: workspaceName,
        // This function runs when the first comment creation is executed.
        // It is used to create the addon dataset and configure a client for
        // the addon dataset.
        createAddonDataset,
        // The following callbacks runs when the comment operation are executed.
        // They are used to update the local state of the comments immediately after
        // a comment operation has been executed. This is done to avoid waiting for
        // the real time listener to update the comments and make the UI feel more
        // responsive. The comment will be updated again when we receive an mutation
        // event from the real time listener.
        onCreate: handleOnCreate,
        onCreateError: handleOnCreateError,
        onUpdate: handleOnUpdate,
        onTransactionStart: handleOnTransactionStart
      }),
      [
        client,
        currentUser,
        dataset,
        documentRevisionId,
        documentType,
        getComment,
        createAddonDataset,
        getThreadLength,
        handleOnCreate,
        handleOnCreateError,
        handleOnTransactionStart,
        handleOnUpdate,
        projectId,
        publishedId,
        schemaType,
        workspaceName
      ]
    )
  ), ctxValue = React.useMemo(
    () => ({
      isCreatingDataset,
      status,
      setStatus: handleSetStatus,
      getComment,
      isCommentsOpen,
      onCommentsOpen,
      comments: {
        data: threadItemsByStatus,
        error,
        loading: loading || isCreatingDataset
      },
      operation: {
        create: operation.create,
        react: operation.react,
        remove: operation.remove,
        update: operation.update
      },
      mentionOptions
    }),
    [
      isCreatingDataset,
      status,
      handleSetStatus,
      getComment,
      isCommentsOpen,
      onCommentsOpen,
      threadItemsByStatus,
      error,
      loading,
      operation.create,
      operation.react,
      operation.remove,
      operation.update,
      mentionOptions
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsContext.Provider, { value: ctxValue, children });
}), CommentsEnabledContext = React.createContext(null), CommentsEnabledProvider = React__namespace.memo(function(props) {
  const { children, documentId, documentType } = props, value = useResolveCommentsEnabled(documentId, documentType);
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsEnabledContext.Provider, { value, children });
}), CommentsIntentContext = React.createContext(
  void 0
), CommentsIntentProvider = React.memo(function(props) {
  const { children, getIntent: getIntent2 } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsIntentContext.Provider, { value: getIntent2, children });
}), CommentsOnboardingContext = React.createContext(null), VERSION = 1, LOCAL_STORAGE_KEY = `sanityStudio:comments:inspector:onboarding:dismissed:v${VERSION}`, setLocalStorage = (value) => {
  try {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(value));
  } catch {
  }
}, getLocalStorage = () => {
  try {
    const value = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    return value ? JSON.parse(value) : !1;
  } catch {
    return !1;
  }
};
function CommentsOnboardingProvider(props) {
  const { children } = props, [dismissed, setDismissed] = React.useState(getLocalStorage()), handleDismiss = React.useCallback(() => {
    setDismissed(!0), setLocalStorage(!0);
  }, [setDismissed]), ctxValue = React.useMemo(
    () => ({
      setDismissed: handleDismiss,
      isDismissed: dismissed
    }),
    [handleDismiss, dismissed]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsOnboardingContext.Provider, { value: ctxValue, children });
}
const CommentsSelectedPathContext = React.createContext(
  null
), CommentsSelectedPathProvider = React__namespace.default.memo(function(props) {
  const { children } = props, [selectedPath, setSelectedPath] = React.useState(null), handleSelectPath = React.useCallback(
    (nextPath) => {
      isEqual__default.default(selectedPath, nextPath) || setSelectedPath(nextPath);
    },
    [selectedPath]
  ), ctxValue = React.useMemo(
    () => ({
      selectedPath,
      setSelectedPath: handleSelectPath
    }),
    [selectedPath, handleSelectPath]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsSelectedPathContext.Provider, { value: ctxValue, children });
}), CommentsUpsellContext = React.createContext(null), UPSELL_CLIENT_OPTIONS = {
  apiVersion: "2023-12-11",
  useProjectHostname: !1,
  withCredentials: !1,
  useCdn: !0
}, FEATURE = "comments", TEMPLATE_OPTIONS = { interpolate: /{{([\s\S]+?)}}/g }, BASE_URL = "www.sanity.io";
function CommentsUpsellProvider(props) {
  const [upsellDialogOpen, setUpsellDialogOpen] = React.useState(!1), [upsellData, setUpsellData] = React.useState(null), projectId = sanity.useProjectId(), telemetry2 = react$1.useTelemetry(), client = sanity.useClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS), telemetryLogs = React.useMemo(
    () => ({
      dialogSecondaryClicked: () => telemetry2.log(sanity.UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      dialogPrimaryClicked: () => telemetry2.log(sanity.UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "modal"
      }),
      panelViewed: (source) => telemetry2.log(sanity.UpsellDialogViewed, {
        feature: FEATURE,
        type: "inspector",
        source
      }),
      panelDismissed: () => telemetry2.log(sanity.UpsellDialogDismissed, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelPrimaryClicked: () => telemetry2.log(sanity.UpsellDialogUpgradeCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      }),
      panelSecondaryClicked: () => telemetry2.log(sanity.UpsellDialogLearnMoreCtaClicked, {
        feature: FEATURE,
        type: "inspector"
      })
    }),
    [telemetry2]
  ), handlePrimaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]), handleSecondaryButtonClick = React.useCallback(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]), handleClose = React.useCallback(() => {
    setUpsellDialogOpen(!1), telemetry2.log(sanity.UpsellDialogDismissed, {
      feature: FEATURE,
      type: "modal"
    });
  }, [telemetry2]);
  React.useEffect(() => {
    const sub = client.withConfig(UPSELL_CLIENT_OPTIONS).observable.request({
      uri: "/journey/comments"
    }).subscribe({
      next: (data) => {
        if (data)
          try {
            const ctaUrl = template__default.default(data.ctaButton.url, TEMPLATE_OPTIONS);
            data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL, projectId });
            const secondaryUrl = template__default.default(data.secondaryButton.url, TEMPLATE_OPTIONS);
            data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL, projectId }), setUpsellData(data);
          } catch {
          }
      },
      error: () => {
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, [client, projectId]);
  const handleOpenDialog = React.useCallback(
    (source) => {
      setUpsellDialogOpen(!0), telemetry2.log(sanity.UpsellDialogViewed, {
        feature: FEATURE,
        type: "modal",
        source
      });
    },
    [telemetry2]
  ), ctxValue = React.useMemo(
    () => ({
      upsellDialogOpen,
      handleOpenDialog,
      upsellData,
      telemetryLogs
    }),
    [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(CommentsUpsellContext.Provider, { value: ctxValue, children: [
    props.children,
    upsellData && upsellDialogOpen && /* @__PURE__ */ jsxRuntime.jsx(
      CommentsUpsellDialog,
      {
        data: upsellData,
        onClose: handleClose,
        onPrimaryClick: handlePrimaryButtonClick,
        onSecondaryClick: handleSecondaryButtonClick
      }
    )
  ] });
}
function useCommentsIntent() {
  return React.useContext(CommentsIntentContext);
}
const structureLocaleNamespace = "structure", structureUsEnglishLocaleBundle = sanity.defineLocaleResourceBundle({
  locale: "en-US",
  namespace: structureLocaleNamespace,
  resources: () => Promise.resolve().then(function() {
    return require("./resources2.js");
  })
});
function DocTitle(props) {
  const { document: documentValue } = props, schemaType = sanity.useSchema().get(documentValue._type), { t } = sanity.useTranslation(structureLocaleNamespace), { error, value } = sanity.unstable_useValuePreview({
    schemaType,
    value: documentValue
  });
  return schemaType ? error ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t("doc-title.error.text", { errorMessage: error.message }) }) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: (value == null ? void 0 : value.title) || /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("doc-title.fallback.text") }) }) : /* @__PURE__ */ jsxRuntime.jsx("code", { children: t("doc-title.unknown-schema-type.text", { schemaType: documentValue._type }) });
}
const ChevronWrapper = styled__default.default(ui.Box)`
  margin-left: auto;
`, CrossDatasetReferencesDetails = styled__default.default.details`
  flex: none;

  &[open] ${ChevronWrapper} {
    transform: rotate(180deg);
  }
`, CrossDatasetReferencesSummary = styled__default.default.summary`
  list-style: none;

  &::-webkit-details-marker {
    display: none;
  }
`, Table = styled__default.default.table`
  width: 100%;
  text-align: left;
  padding: 0 ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[2])};
  border-collapse: collapse;

  th {
    padding: ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
  }

  td {
    padding: 0 ${({ theme: theme2 }) => ui.rem(theme2.sanity.space[1])};
  }

  tr > *:last-child {
    text-align: right;
  }
`, DocumentIdFlex = styled__default.default(ui.Flex)`
  min-height: 33px;
`, OtherReferenceCount = (props) => {
  const { t } = sanity.useTranslation(structureLocaleNamespace), difference = props.totalCount - props.references.length;
  return difference ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Inline, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t("confirm-delete-dialog.other-reference-count.title", { count: difference }) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Tooltip,
      {
        portal: !0,
        placement: "top",
        content: t("confirm-delete-dialog.other-reference-count.tooltip"),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {}) })
      }
    )
  ] }) }) : null;
};
function PaneItemPreview(props) {
  const { icon, layout, presence, schemaType, value } = props, title = sanity.isRecord(value.title) && React.isValidElement(value.title) || isString__default.default(value.title) || isNumber__default.default(value.title) ? value.title : null, { draft, published, isLoading } = reactRx.useMemoObservable(
    () => sanity.getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title),
    [props.documentPreviewStore, schemaType, value._id, title]
  ), status = isLoading ? null : /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(sanity.DocumentPreviewPresence, { presence }),
    /* @__PURE__ */ jsxRuntime.jsx(sanity.DocumentStatusIndicator, { draft, published })
  ] }) }), tooltip = /* @__PURE__ */ jsxRuntime.jsx(sanity.DocumentStatus, { draft, published });
  return /* @__PURE__ */ jsxRuntime.jsx(
    sanity.SanityDefaultPreview,
    {
      ...sanity.getPreviewValueWithFallback({ value, draft, published }),
      isPlaceholder: isLoading,
      icon,
      layout,
      status,
      tooltip
    }
  );
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
const PaneRouterContext = React.createContext({
  index: 0,
  groupIndex: 0,
  siblingIndex: 0,
  payload: void 0,
  params: {},
  hasGroupSiblings: !1,
  groupLength: 0,
  routerPanesState: [],
  BackLink: () => missingContext(),
  ChildLink: () => missingContext(),
  ReferenceChildLink: () => missingContext(),
  handleEditReference: () => missingContext(),
  ParameterizedLink: () => missingContext(),
  replaceCurrent: () => missingContext(),
  closeCurrentAndAfter: () => missingContext(),
  closeCurrent: () => missingContext(),
  duplicateCurrent: () => missingContext(),
  setView: () => missingContext(),
  setParams: () => missingContext(),
  setPayload: () => missingContext(),
  navigateIntent: () => missingContext(),
  createPathWithParams: () => missingContext()
}), BackLink = React.forwardRef(function(props, ref) {
  const { routerPanesState, groupIndex } = React.useContext(PaneRouterContext), panes = React.useMemo(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]), state2 = React.useMemo(() => ({ panes }), [panes]);
  return /* @__PURE__ */ jsxRuntime.jsx(router$1.StateLink, { ...props, ref, state: state2 });
}), PaneLayoutContext = React.createContext(null);
function usePaneLayout() {
  const pane = React.useContext(PaneLayoutContext);
  if (!pane)
    throw new Error("PaneLayout: missing context value");
  return pane;
}
const ChildLink = React.forwardRef(function(props, ref) {
  const { childId, childPayload, childParameters, ...rest } = props, { routerPanesState, groupIndex } = React.useContext(PaneRouterContext);
  return /* @__PURE__ */ jsxRuntime.jsx(
    router$1.StateLink,
    {
      ...rest,
      ref,
      state: {
        panes: [
          ...routerPanesState.slice(0, groupIndex + 1),
          [{ id: childId, params: childParameters, payload: childPayload }]
        ]
      }
    }
  );
}), ParameterizedLink = React.forwardRef(function(props, ref) {
  const { routerPanesState: currentPanes, groupIndex, siblingIndex } = React.useContext(PaneRouterContext), { params, payload, ...rest } = props, nextParams = sanity.useUnique(params), nextPayload = sanity.useUnique(payload), nextState = React.useMemo(() => {
    const currentGroup = currentPanes[groupIndex], currentSibling = currentGroup[siblingIndex], nextSibling = {
      ...currentSibling,
      params: nextParams != null ? nextParams : currentSibling.params,
      payload: nextPayload != null ? nextPayload : currentSibling.payload
    }, nextGroup = [
      ...currentGroup.slice(0, siblingIndex),
      nextSibling,
      ...currentGroup.slice(siblingIndex + 1)
    ];
    return { panes: [
      ...currentPanes.slice(0, groupIndex),
      nextGroup,
      ...currentPanes.slice(groupIndex + 1)
    ] };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return /* @__PURE__ */ jsxRuntime.jsx(router$1.StateLink, { ref, ...rest, state: nextState });
}), ReferenceChildLink = React.forwardRef(function({ documentId, documentType, parentRefPath, children, template: template2, ...rest }, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ChildLink,
    {
      ...rest,
      ref,
      childId: documentId,
      childPayload: template2 == null ? void 0 : template2.params,
      childParameters: {
        type: documentType,
        parentRefPath: PathUtils.toString(parentRefPath),
        ...template2 && { template: template2 == null ? void 0 : template2.id }
      },
      children
    }
  );
});
function usePaneRouter() {
  return React.useContext(PaneRouterContext);
}
const EMPTY_ARRAY$g = [];
function ReferencePreviewLink(props) {
  const { onClick, type, value } = props, publishedId = sanity.getPublishedId(value == null ? void 0 : value._id), documentPresence = sanity.useDocumentPresence(publishedId), documentPreviewStore = sanity.useDocumentPreviewStore(), { ReferenceChildLink: ReferenceChildLink2 } = usePaneRouter(), Link2 = React.useCallback(
    function(linkProps) {
      return /* @__PURE__ */ jsxRuntime.jsx(
        ReferenceChildLink2,
        {
          documentId: value == null ? void 0 : value._id,
          documentType: type == null ? void 0 : type.name,
          parentRefPath: EMPTY_ARRAY$g,
          ...linkProps
        }
      );
    },
    [ReferenceChildLink2, type == null ? void 0 : type.name, value == null ? void 0 : value._id]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.PreviewCard, { __unstable_focusRing: !0, as: Link2, "data-as": "a", onClick, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: type == null ? void 0 : type.icon,
      layout: "compact",
      presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY$g,
      schemaType: type,
      value
    }
  ) });
}
function ConfirmDeleteDialogBody({
  crossDatasetReferences,
  internalReferences,
  documentTitle,
  totalCount,
  action,
  datasetNames,
  hasUnknownDatasetNames,
  onReferenceLinkClick
}) {
  const schema2 = sanity.useSchema(), toast = ui.useToast(), { t } = sanity.useTranslation(structureLocaleNamespace), renderPreviewItem = React.useCallback(
    (item) => {
      const type = schema2.get(item._type);
      return type ? /* @__PURE__ */ jsxRuntime.jsx(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick }) : (
        // Padding added to match the ReferencePreviewLink styling
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          sanity.SanityDefaultPreview,
          {
            icon: icons.UnknownIcon,
            title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"),
            subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", {
              documentId: item._id
            }),
            layout: "default"
          }
        ) })
      );
    },
    [schema2, t, onReferenceLinkClick]
  );
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.Translate,
      {
        t,
        i18nKey: "confirm-delete-dialog.confirmation.text",
        context: action,
        components: { DocumentTitle: () => /* @__PURE__ */ jsxRuntime.jsx("strong", { children: documentTitle }) }
      }
    ) });
  const normalizedDatasetNames = [
    ...datasetNames,
    ...hasUnknownDatasetNames ? ["unavailable"] : []
  ], datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", {
    count: normalizedDatasetNames.length,
    datasets: normalizedDatasetNames.join(", "),
    context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : ""
  });
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { "aria-hidden": "true", size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, marginLeft: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          i18nKey: "confirm-delete-dialog.referring-document-count.text",
          components: { DocumentTitle: () => documentTitle },
          t,
          values: { count: totalCount }
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.Translate,
      {
        i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, shadow: 1, flex: "auto", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", children: [
      internalReferences.totalCount > 0 && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [
        internalReferences == null ? void 0 : internalReferences.references.map((item) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "li", children: renderPreviewItem(item) }, item._id)),
        internalReferences.totalCount > internalReferences.references.length && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "li", padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(OtherReferenceCount, { ...internalReferences }) })
      ] }),
      crossDatasetReferences.totalCount > 0 && /* @__PURE__ */ jsxRuntime.jsxs(
        CrossDatasetReferencesDetails,
        {
          "data-testid": "cross-dataset-references",
          style: {
            // only add the border if needed
            borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
          },
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(CrossDatasetReferencesSummary, { children: /* @__PURE__ */ jsxRuntime.jsx(
              ui.Card,
              {
                as: "a",
                marginTop: internalReferences.totalCount > 0 ? 2 : 0,
                radius: 2,
                shadow: 1,
                paddingY: 1,
                children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [
                  /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentsIcon, {}) }),
                  /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", {
                      count: normalizedDatasetNames.length,
                      documentCount: t("confirm-delete-dialog.cdr-summary.document-count", {
                        count: crossDatasetReferences.totalCount
                      })
                    }) }),
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: !0, children: datasetSubtitle })
                  ] }),
                  /* @__PURE__ */ jsxRuntime.jsx(ChevronWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, {}) }) })
                ] })
              }
            ) }),
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { overflow: "auto", paddingTop: 2, children: [
              /* @__PURE__ */ jsxRuntime.jsxs(Table, { children: [
                /* @__PURE__ */ jsxRuntime.jsx("thead", { children: /* @__PURE__ */ jsxRuntime.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntime.jsx("th", { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, style: { minWidth: "5rem" }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }),
                  /* @__PURE__ */ jsxRuntime.jsx("th", { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }),
                  /* @__PURE__ */ jsxRuntime.jsx("th", { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })
                ] }) }),
                /* @__PURE__ */ jsxRuntime.jsx("tbody", { children: crossDatasetReferences.references.filter((reference) => "projectId" in reference).map(({ projectId, datasetName, documentId }, index) => (
                  // eslint-disable-next-line react/no-array-index-key
                  /* @__PURE__ */ jsxRuntime.jsxs("tr", { children: [
                    /* @__PURE__ */ jsxRuntime.jsx("td", { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: projectId }) }),
                    /* @__PURE__ */ jsxRuntime.jsx("td", { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: datasetName || "unavailable" }) }),
                    /* @__PURE__ */ jsxRuntime.jsx("td", { children: /* @__PURE__ */ jsxRuntime.jsxs(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [
                      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }),
                      documentId && /* @__PURE__ */ jsxRuntime.jsx(
                        CopyToClipboard__default.default,
                        {
                          text: documentId,
                          onCopy: () => {
                            toast.push({
                              title: t(
                                "confirm-delete-dialog.cdr-table.id-copied-toast.title"
                              ),
                              status: "success"
                            });
                          },
                          children: /* @__PURE__ */ jsxRuntime.jsx(
                            getJsonStream.Button,
                            {
                              mode: "bleed",
                              icon: icons.CopyIcon,
                              tooltipProps: {
                                content: t(
                                  "confirm-delete-dialog.cdr-table.copy-id-button.tooltip"
                                )
                              }
                            }
                          )
                        }
                      )
                    ] }) })
                  ] }, `${documentId}-${index}`)
                )) })
              ] }),
              /* @__PURE__ */ jsxRuntime.jsx(OtherReferenceCount, { ...crossDatasetReferences })
            ] })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.Translate,
      {
        i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text",
        t,
        context: action,
        components: { DocumentTitle: () => documentTitle }
      }
    ) }) })
  ] });
}
function isClientError(e) {
  return typeof e != "object" || !e ? !1 : "statusCode" in e && "response" in e;
}
const POLL_INTERVAL = 5e3;
let visiblePoll$;
const getVisiblePoll$ = () => (visiblePoll$ || (visiblePoll$ = rxjs.fromEvent(document, "visibilitychange").pipe(
  // add empty emission to have this fire on creation
  operators.startWith(null),
  operators.map(() => document.visibilityState === "visible"),
  operators.distinctUntilChanged(),
  operators.switchMap(
    (visible) => visible ? (
      // using timer instead of interval since timer will emit on creation
      rxjs.timer(0, POLL_INTERVAL)
    ) : rxjs.EMPTY
  ),
  operators.shareReplay({ refCount: !0, bufferSize: 1 })
)), visiblePoll$);
function getDocumentExistence(documentId, { versionedClient }) {
  const draftId = sanity.getDraftId(documentId), publishedId = sanity.getPublishedId(documentId), requestOptions = {
    uri: versionedClient.getDataUrl("doc", `${draftId},${publishedId}`),
    json: !0,
    query: { excludeContent: "true" },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(
    operators.map(({ omitted }) => {
      const nonExistant = omitted.filter((doc) => doc.reason === "existence");
      if (nonExistant.length !== 2)
        return nonExistant.length === 0 || nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
    })
  );
}
function fetchCrossDatasetReferences(documentId, context) {
  const { versionedClient } = context;
  return getVisiblePoll$().pipe(
    operators.switchMap(() => getDocumentExistence(documentId, context)),
    operators.switchMap((checkDocumentId) => {
      if (!checkDocumentId)
        return rxjs.of({ totalCount: 0, references: [] });
      const currentDataset = versionedClient.config().dataset;
      return versionedClient.observable.request({
        url: `/data/references/${currentDataset}/documents/${checkDocumentId}/to?excludeInternalReferences=true&excludePaths=true`,
        tag: "use-referring-documents.external"
      }).pipe(
        operators.catchError((e) => {
          if (isClientError(e) && e.statusCode === 404)
            return rxjs.of({ totalCount: 0, references: [] });
          throw e;
        })
      );
    })
  );
}
const useInternalReferences = sanity.createHookFromObservableFactory(
  ([documentId, documentStore]) => documentStore.listenQuery(
    { fetch: '{"references":*[references($documentId)][0...100]{_id,_type},"totalCount":count(*[references($documentId)])}', listen: "*[references($documentId)]" },
    { documentId },
    { tag: "use-referring-documents", transitions: ["appear", "disappear"], throttleTime: 5e3 }
  )
), useCrossDatasetReferences = sanity.createHookFromObservableFactory(
  ([documentId, versionedClient]) => getVisiblePoll$().pipe(
    operators.switchMap(
      () => fetchCrossDatasetReferences(documentId, {
        versionedClient
      })
    )
  )
);
function useReferringDocuments(documentId) {
  const versionedClient = sanity.useClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS), documentStore = sanity.useDocumentStore(), publishedId = sanity.getPublishedId(documentId), [internalReferences, isInternalReferencesLoading] = useInternalReferences(
    React.useMemo(() => [publishedId, documentStore], [documentStore, publishedId])
  ), [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(
    React.useMemo(() => [publishedId, versionedClient], [publishedId, versionedClient])
  ), projectIds = React.useMemo(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean)
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), datasetNames = React.useMemo(() => Array.from(
    new Set(
      crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => !!datasetName && datasetName !== "")
    )
  ).sort(), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]), hasUnknownDatasetNames = React.useMemo(() => !!(crossDatasetReferences != null && crossDatasetReferences.references.some(
    (crossDatasetReference) => typeof crossDatasetReference.datasetName != "string"
  )), [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}
const DialogBody = styled__default.default(ui.Box)`
  box-sizing: border-box;
`, LoadingContainer = styled__default.default(ui.Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
})`
  height: 110px;
`;
function ConfirmDeleteDialog({
  id,
  type,
  action = "delete",
  onCancel,
  onConfirm
}) {
  const { t } = sanity.useTranslation(structureLocaleNamespace), dialogId = `deletion-confirmation-${React.useId()}`, {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id), documentTitle = /* @__PURE__ */ jsxRuntime.jsx(DocTitle, { document: React.useMemo(() => ({ _id: id, _type: type }), [id, type]) }), showConfirmButton = !isLoading;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      width: 1,
      id: dialogId,
      header: t("confirm-delete-dialog.header.text", { context: action }),
      footer: {
        cancelButton: {
          onClick: onCancel,
          text: t("confirm-delete-dialog.cancel-button.text")
        },
        confirmButton: showConfirmButton ? {
          text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", { context: action }) : t("confirm-delete-dialog.confirm-button.text", { context: action }),
          onClick: onConfirm
        } : void 0
      },
      onClose: onCancel,
      onClickOutside: onCancel,
      children: /* @__PURE__ */ jsxRuntime.jsx(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading ? /* @__PURE__ */ jsxRuntime.jsx(
        ConfirmDeleteDialogBody,
        {
          crossDatasetReferences,
          internalReferences,
          documentTitle,
          isLoading,
          totalCount,
          action,
          projectIds,
          datasetNames,
          hasUnknownDatasetNames,
          onReferenceLinkClick: onCancel
        }
      ) : /* @__PURE__ */ jsxRuntime.jsx(LoadingContainer, { "data-testid": "loading-container", children: /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0, title: t("confirm-delete-dialog.loading.text") }) }) })
    }
  );
}
function ConfirmDeleteDialogContainer(props) {
  const { t } = sanity.useTranslation(structureLocaleNamespace), id = React.useId(), [error, setError] = React.useState(null), handleRetry = React.useCallback(() => setError(null), []);
  return error ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      id: `dialog-error-${id}`,
      "data-testid": "confirm-delete-error-dialog",
      header: t("confirm-delete-dialog.error.title.text"),
      footer: {
        confirmButton: {
          text: t("confirm-delete-dialog.error.retry-button.text"),
          onClick: handleRetry,
          tone: "default"
        }
      },
      onClose: props.onCancel,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: setError, children: /* @__PURE__ */ jsxRuntime.jsx(ConfirmDeleteDialog, { ...props }) });
}
function Delay({
  children,
  ms = 0
}) {
  const [ready, setReady] = React.useState(ms <= 0);
  return React.useEffect(() => {
    if (ms <= 0)
      return;
    const timeoutId = setTimeout(() => setReady(!0), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]), !ready || !children ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {}) : typeof children == "function" ? children() : children;
}
const PANE_DEBUG = !1, PANE_COLLAPSED_WIDTH = 51, PANE_DEFAULT_MIN_WIDTH = 204, PaneContext = React.createContext(null), Root$g = styled__default.default(ui.Layer)`
  position: relative;
  width: 1px;
  min-width: 1px;

  &:before {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 1px;
    background-color: var(--card-border-color);
  }

  &:not([data-disabled]) {
    cursor: ew-resize;
    width: 9px;
    min-width: 9px;
    margin: 0 -4px;

    &:before {
      left: 4px;
    }

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    &[data-dragging]:after,
    &:hover:after {
      opacity: 0.2;
    }
  }
`;
function PaneDivider({
  disabled,
  element
}) {
  const { resize } = usePaneLayout(), [dragging, setDragging] = React.useState(!1), handleMouseDown = React.useCallback(
    (event) => {
      if (!element)
        return;
      setDragging(!0), event.preventDefault();
      const startX = event.pageX;
      resize("start", element, 0);
      const handleMouseMove = (e) => {
        e.preventDefault();
        const deltaX = e.pageX - startX;
        resize("move", element, deltaX);
      }, handleMouseUp = (e) => {
        e.preventDefault(), setDragging(!1), window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp), resize("end", element, 0);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [element, resize]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$g,
    {
      "data-disabled": disabled ? "" : void 0,
      "data-dragging": dragging ? "" : void 0,
      onMouseDown: handleMouseDown
    }
  );
}
const Root$f = styled__default.default(ui.Card)`
  outline: none;

  // NOTE: This will render a border to the right side of each pane
  // without taking up physical space.
  box-shadow: 1px 0 0 var(--card-border-color);
`, Pane = React.forwardRef(function(props, ref) {
  var _a, _b, _c;
  const {
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: flexProp = 1,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected = !1,
    ...restProps
  } = props, [rootElement, setRootElement] = React.useState(null), {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout(), pane = panes.find((p) => p.element === rootElement), paneIndex = pane && panes.indexOf(pane), nextPane = typeof paneIndex == "number" ? panes[paneIndex + 1] : void 0, isLast = paneIndex === panes.length - 1, collapsed = layoutCollapsed ? !1 : (pane == null ? void 0 : pane.collapsed) || !1, nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || !1, forwardedRef = ui.useForwardedRef(ref), flex = (_a = pane == null ? void 0 : pane.flex) != null ? _a : flexProp, currentMinWidth = (_b = pane == null ? void 0 : pane.currentMinWidth) != null ? _b : currentMinWidthProp, currentMaxWidth = (_c = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c : currentMaxWidthProp, setRef = React.useCallback(
    (refValue) => {
      setRootElement(refValue), forwardedRef.current = refValue;
    },
    [forwardedRef]
  );
  React.useEffect(() => {
    if (rootElement)
      return mount(rootElement, {
        currentMinWidth: currentMinWidthProp,
        currentMaxWidth: currentMaxWidthProp,
        flex: flexProp,
        id,
        minWidth: minWidthProp,
        maxWidth: maxWidthProp
      });
  }, [
    currentMinWidthProp,
    currentMaxWidthProp,
    flexProp,
    id,
    minWidthProp,
    maxWidthProp,
    mount,
    rootElement
  ]);
  const handleCollapse = React.useCallback(() => {
    rootElement && collapse(rootElement);
  }, [collapse, rootElement]), handleExpand = React.useCallback(() => {
    rootElement && expand(rootElement);
  }, [expand, rootElement]), contextValue = React.useMemo(
    () => ({
      collapse: handleCollapse,
      collapsed: layoutCollapsed ? !1 : collapsed,
      expand: handleExpand,
      index: paneIndex,
      isLast,
      rootElement
    }),
    [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]
  ), minWidth = React.useMemo(() => {
    if (!layoutCollapsed)
      return collapsed ? PANE_COLLAPSED_WIDTH : currentMinWidth === 0 || isLast ? minWidthProp || PANE_DEFAULT_MIN_WIDTH : currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]), maxWidth = React.useMemo(() => {
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (!(layoutCollapsed && isLast))
      return isLast ? maxWidthProp ? currentMaxWidth != null ? currentMaxWidth : maxWidthProp : void 0 : currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]), hidden = layoutCollapsed && !isLast, divider = React.useMemo(
    () => !isLast && !layoutCollapsed && /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "paneResizer", children: /* @__PURE__ */ jsxRuntime.jsx(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }),
    [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]
  ), style = React.useMemo(
    () => ({
      flex,
      minWidth,
      maxWidth: maxWidth === 1 / 0 ? void 0 : maxWidth
    }),
    [flex, minWidth, maxWidth]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "pane", children: /* @__PURE__ */ jsxRuntime.jsx(PaneContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntime.jsxs(
      Root$f,
      {
        "data-testid": "pane",
        "data-ui": "Pane",
        tone: "inherit",
        hidden,
        id,
        overflow: layoutCollapsed ? void 0 : "hidden",
        ...restProps,
        "data-pane-collapsed": collapsed ? "" : void 0,
        "data-pane-index": paneIndex,
        "data-pane-selected": selected ? "" : void 0,
        ref: setRef,
        style,
        children: [
          PANE_DEBUG,
          /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: rootElement, children: !hidden && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", height: "fill", children }) })
        ]
      }
    ) }) }),
    divider
  ] });
}), Root$e = styled__default.default(ui.Card)`
  position: relative;
  outline: none;
`;
Root$e.displayName = "PaneContent__root";
function usePane() {
  const pane = React.useContext(PaneContext);
  if (!pane)
    throw new Error("Pane: missing context value");
  return pane;
}
const PaneContent = React.forwardRef(function(props, ref) {
  const { as, children, overflow, padding, ...restProps } = props, { collapsed } = usePane(), { collapsed: layoutCollapsed } = usePaneLayout();
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$e,
    {
      "data-testid": "pane-content",
      forwardedAs: as,
      ...restProps,
      flex: 1,
      hidden: collapsed,
      overflow: layoutCollapsed ? void 0 : overflow,
      padding,
      ref,
      tone: "inherit",
      children
    }
  );
}), MENU_GROUP_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "left-start",
  portal: !0
};
function PaneMenuButtonItem(props) {
  const { disabled, isAfterGroup, node } = props, getI18nText = sanity.useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider")
    return /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {});
  const { title } = getI18nText(node);
  return node.type === "group" ? node.children.length === 0 ? null : node.expanded ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isAfterGroup && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    node.children.map((child, childIndex) => {
      var _a;
      return /* @__PURE__ */ jsxRuntime.jsx(
        PaneMenuButtonItem,
        {
          disabled: disabled || !!node.disabled,
          isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
          node: child
        },
        child.key
      );
    })
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isAfterGroup && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuGroup,
      {
        disabled,
        icon: node.icon,
        popover: MENU_GROUP_POPOVER_PROPS,
        text: title,
        children: node.children.map((child, childIndex) => {
          var _a;
          return /* @__PURE__ */ jsxRuntime.jsx(
            PaneMenuButtonItem,
            {
              disabled: disabled || !!node.disabled,
              isAfterGroup: ((_a = node.children[childIndex - 1]) == null ? void 0 : _a.type) === "group",
              node: child
            },
            child.key
          );
        })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    isAfterGroup && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
    /* @__PURE__ */ jsxRuntime.jsx(PaneContextMenuItemResolver, { disabled, node })
  ] });
}
function PaneContextMenuItemResolver(props) {
  const { node } = props;
  return node.intent ? /* @__PURE__ */ jsxRuntime.jsx(PaneContextIntentMenuItem, { ...props, intent: node.intent }) : /* @__PURE__ */ jsxRuntime.jsx(PaneContextMenuItem, { ...props });
}
function PaneContextMenuItem(props) {
  var _a;
  const { disabled, node } = props, tooltipContent = typeof node.disabled == "object" && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: node.disabled.reason }), { title } = sanity.useI18nText(node);
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.TooltipOfDisabled, { content: tooltipContent, placement: "left", children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      icon: node.icon,
      iconRight: node.iconRight || node.selected && icons.CheckmarkIcon,
      onClick: node.onAction,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
function PaneContextIntentMenuItem(props) {
  var _a;
  const { disabled, intent, node } = props, tooltipContent = typeof node.disabled == "object" && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: node.disabled.reason }), intentLink = router$1.useIntentLink({ intent: intent.type, params: intent.params }), handleClick = React.useCallback(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { title } = sanity.useI18nText(node);
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.TooltipOfDisabled, { content: tooltipContent, placement: "left", children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      as: "a",
      disabled: disabled || !!node.disabled,
      hotkeys: (_a = node.hotkey) == null ? void 0 : _a.split("+"),
      href: intentLink.href,
      icon: node.icon,
      iconRight: node.selected ? icons.CheckmarkIcon : void 0,
      onClick: handleClick,
      pressed: node.selected,
      text: title,
      tone: node.tone
    }
  ) });
}
const CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone));
}
function PaneContextMenuButton(props) {
  const { nodes, actionsNodes } = props, id = React.useId(), hasCritical = nodesHasTone(nodes, "critical"), hasCaution = nodesHasTone(nodes, "caution");
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.ContextMenuButton,
        {
          tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0,
          "data-testid": "pane-context-menu-button"
        }
      ),
      id,
      menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
        actionsNodes && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          actionsNodes,
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
        ] }),
        nodes.map((node, nodeIndex) => {
          var _a;
          const isAfterGroup = ((_a = nodes[nodeIndex - 1]) == null ? void 0 : _a.type) === "group";
          return /* @__PURE__ */ jsxRuntime.jsx(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
        })
      ] }),
      popover: CONTEXT_MENU_POPOVER_PROPS
    }
  );
}
const Root$d = styled__default.default(ui.Layer)`
  position: sticky;
  bottom: 0;

  &:before {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -1px;
    border-bottom: 1px solid var(--card-border-color);
  }
`, RootCard$2 = styled__default.default(ui.Card)`
  padding-bottom: env(safe-area-inset-bottom);
`, PaneFooter = React.forwardRef(function(props, ref) {
  const { children, padding } = props, { collapsed } = usePane();
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsxRuntime.jsx(Root$d, { "data-testid": "pane-footer", hidden: collapsed, ref, children: /* @__PURE__ */ jsxRuntime.jsx(RootCard$2, { tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding, children }) }) }) });
}), Root$c = styled__default.default(ui.Layer)(({ $border }) => styled.css`
    line-height: 0;
    position: sticky;
    top: 0;

    &:not([data-collapsed]):after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      border-bottom: 1px solid ${$border ? "var(--card-border-color)" : "transparent"};
      opacity: 1;
    }
  `), Layout = styled__default.default(ui.Flex)`
  transform-origin: calc(51px / 2);

  [data-collapsed] > div > & {
    transform: rotate(90deg);
  }
`, TitleCard = styled__default.default(ui.Card)(({ theme: theme2 }) => {
  const { fg, bg } = theme2.sanity.color.card.enabled;
  return styled.css`
    background-color: ${bg};

    [data-ui='Text'] {
      color: ${fg};
    }
  `;
}), TitleTextSkeleton = styled__default.default(ui.TextSkeleton)`
  width: 66%;
  max-width: 175px;
`, TitleText = styled__default.default(ui.Text)`
  cursor: default;
  outline: none;
`, TabsBox = styled__default.default(ui.Box)(({ theme: theme2 }) => {
  const { color: color2, space } = theme2.sanity;
  return styled.css`
    overflow: hidden;
    overflow: clip;
    position: relative;

    & > div {
      white-space: nowrap;
      overflow: auto;
      /* Hide scrollbars */
      scrollbar-width: none;
      &::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
    }

    /* right padding */
    & > div:after {
      content: '';
      display: inline-block;
      top: 0;
      right: 0;
      bottom: 0;
      width: ${space[3]}px;
      height: 1px;
    }

    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */
    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to right, ${ui.rgba(color2.base.bg, 0)}, var(--card-bg-color));
      width: ${space[3]}px;
      pointer-events: none;
    }
  `;
}), PaneHeader = React.forwardRef(function(props, ref) {
  const { actions, backButton, border, contentAfter, loading, subActions, tabs, tabIndex, title } = props, { collapse, collapsed, expand, rootElement: paneElement } = usePane(), paneRect = ui.useElementRect(paneElement || null), layoutStyle = React.useMemo(
    () => ({
      width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0
    }),
    [collapsed, paneRect]
  ), handleTitleClick = React.useCallback(() => {
    collapsed || collapse();
  }, [collapse, collapsed]), handleLayoutClick = React.useCallback(() => {
    collapsed && expand();
  }, [collapsed, expand]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsxRuntime.jsx(
    Root$c,
    {
      $border: border,
      "data-collapsed": collapsed ? "" : void 0,
      "data-testid": "pane-header",
      ref,
      children: /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "paneHeader", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { "data-collapsed": collapsed ? "" : void 0, tone: "inherit", children: [
        /* @__PURE__ */ jsxRuntime.jsxs(
          Layout,
          {
            gap: 1,
            onClick: handleLayoutClick,
            padding: 3,
            paddingBottom: collapsed ? 3 : 2,
            sizing: "border",
            style: layoutStyle,
            children: [
              backButton && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: backButton }),
              /* @__PURE__ */ jsxRuntime.jsxs(
                TitleCard,
                {
                  __unstable_focusRing: !0,
                  flex: 1,
                  forwardedAs: "button",
                  onClick: handleTitleClick,
                  paddingLeft: backButton ? 1 : 2,
                  padding: 2,
                  tabIndex,
                  children: [
                    loading && /* @__PURE__ */ jsxRuntime.jsx(TitleTextSkeleton, { animated: !0, radius: 1, size: 1 }),
                    !loading && /* @__PURE__ */ jsxRuntime.jsx(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title })
                  ]
                }
              ),
              actions && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", hidden: collapsed, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) })
            ]
          }
        ),
        !!(!collapsed && (tabs || subActions)) && /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Flex,
          {
            align: "center",
            hidden: collapsed,
            overflow: "auto",
            paddingBottom: 3,
            paddingX: 3,
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(TabsBox, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }),
              subActions && subActions
            ]
          }
        ),
        !collapsed && contentAfter && contentAfter
      ] }) })
    }
  ) });
});
function getDisabledReason$1(node) {
  var _a;
  if (!node.disabled)
    return { disabledReason: void 0, ariaLabel: void 0, isDisabled: !1 };
  const disabledReason = typeof node.disabled == "object" ? node.disabled.reason : void 0, ariaLabel = typeof node.disabled == "object" && typeof ((_a = node.disabled) == null ? void 0 : _a.reason) == "string" ? node.disabled.reason : "This is disabled";
  return { disabledReason, ariaLabel, isDisabled: !!node.disabled };
}
function PaneHeaderActionButton(props) {
  const { node } = props;
  return node.type === "item" ? /* @__PURE__ */ jsxRuntime.jsx(PaneHeaderMenuItemActionButton, { node }) : node.type === "group" ? /* @__PURE__ */ jsxRuntime.jsx(PaneHeaderMenuGroupActionButton, { node }) : (console.warn('unknown menu node (expected `type: "item" | "group"`):', node), null);
}
function PaneHeaderMenuItemActionButton(props) {
  const { node } = props, { title } = sanity.useI18nText(node);
  if (node.intent)
    return /* @__PURE__ */ jsxRuntime.jsx(PaneHeaderActionIntentButton, { ...props, intent: node.intent });
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return /* @__PURE__ */ jsxRuntime.jsx(
    sanity.StatusButton,
    {
      disabled: isDisabled,
      icon: node.icon,
      onClick: node.onAction,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel,
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : title
      }
    }
  );
}
function PaneHeaderActionIntentButton(props) {
  const { intent, node } = props, intentLink = router$1.useIntentLink({ intent: intent.type, params: intent.params }), handleClick = React.useCallback(
    (event) => {
      intentLink.onClick(event), node.onAction();
    },
    [intentLink, node]
  ), { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return /* @__PURE__ */ jsxRuntime.jsx(
    sanity.StatusButton,
    {
      forwardedAs: "a",
      disabled: isDisabled,
      href: intentLink.href,
      icon: node.icon,
      onClick: handleClick,
      selected: node.selected,
      tone: node.tone,
      "aria-label": ariaLabel,
      tooltipProps: {
        hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0,
        content: isDisabled ? disabledReason : node.title,
        placement: "bottom",
        portal: !0
      }
    }
  );
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a;
  const { node } = props, { title } = sanity.useI18nText(node);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          disabled: !!node.disabled,
          icon: (_a = node.icon) != null ? _a : icons.UnknownIcon,
          label: title,
          mode: "bleed",
          tooltipProps: { content: node.title, portal: !0 }
        }
      ),
      id: React.useId(),
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: node.children.map((child, idx) => {
        var _a2;
        return /* @__PURE__ */ jsxRuntime.jsx(
          PaneMenuButtonItem,
          {
            disabled: !!node.disabled,
            isAfterGroup: ((_a2 = node.children[idx - 1]) == null ? void 0 : _a2.type) === "group",
            node: child
          },
          child.key
        );
      }) })
    }
  );
}
const Root$b = styled__default.default(ui.Card)`
  transition: opacity 200ms;
  position: relative;
  z-index: 1;
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  opacity: 0;

  &:not([hidden]) {
    display: flex;
  }

  &:not([data-collapsed]) {
    overflow: auto;
  }

  &[data-mounted] {
    opacity: 1;
  }

  &[data-resizing] {
    pointer-events: none;
  }
`;
function _calcPaneResize(cache, left, right, deltaX) {
  var _a, _b;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  }, leftMinWidth = (_a = left.minWidth) != null ? _a : PANE_DEFAULT_MIN_WIDTH, rightMinWidth = (_b = right.minWidth) != null ? _b : PANE_DEFAULT_MIN_WIDTH, leftMaxWidth = Math.min(left.maxWidth || 1 / 0, sum.width - rightMinWidth), rightMaxWidth = Math.min(right.maxWidth || 1 / 0, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  minDeltaX < rightMinDeltaX && (minDeltaX = rightMinDeltaX);
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  maxDeltaX > leftMaxDeltaX && (maxDeltaX = leftMaxDeltaX);
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX), leftW = cache.left.width + _deltaX, rightW = cache.right.width - _deltaX, leftFlex = leftW / sum.width * sum.flex, rightFlex = rightW / sum.width * sum.flex;
  return { leftFlex, leftW, rightFlex, rightW };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement)
      return path;
    const index = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map = /* @__PURE__ */ new WeakMap();
  for (const element of elements)
    map.set(element, _getDOMPath(rootElement, element));
  const _sortByElementPath = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH, _b = map.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [], elements = [], optionsMap = /* @__PURE__ */ new WeakMap(), userCollapsedElementSet = /* @__PURE__ */ new Set(), cache = {};
  let rootElement = null, rootWidth = 0, expandedElement = null, resizeDataMap = /* @__PURE__ */ new Map(), resizing = !1;
  function collapse(element) {
    userCollapsedElementSet.add(element), expandedElement === element && (expandedElement = null), _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element), expandedElement = element, _notifyObservers();
  }
  function mount(element, options) {
    return optionsMap.set(element, { ...options, original: options }), elements.push(element), rootElement && _sortElements(rootElement, elements), expand(element), () => {
      const idx = elements.indexOf(element);
      idx > -1 && elements.splice(idx, 1), optionsMap.delete(element), _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a, _b, _c, _d;
    const leftIndex = elements.indexOf(leftElement), leftOptions = optionsMap.get(leftElement);
    if (!leftOptions)
      return;
    const rightElement = elements[leftIndex + 1], rightOptions = optionsMap.get(rightElement);
    if (rightOptions) {
      if (type === "start" && (resizing = !0, cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      }, cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      }, _notifyObservers()), type === "move" && cache.left && cache.right) {
        resizeDataMap = /* @__PURE__ */ new Map();
        const { leftW, rightW, leftFlex, rightFlex } = _calcPaneResize(
          cache,
          leftOptions,
          rightOptions,
          deltaX
        );
        resizeDataMap.set(leftElement, { flex: leftFlex, width: leftW }), resizeDataMap.set(rightElement, { flex: rightFlex, width: rightW }), _notifyObservers();
      }
      if (type === "end") {
        resizing = !1;
        const leftResizeData = resizeDataMap.get(leftElement), rightResizeData = resizeDataMap.get(rightElement);
        optionsMap.set(leftElement, {
          ...leftOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_a = leftOptions.maxWidth) != null ? _a : 1 / 0,
          flex: (_b = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b : leftOptions.flex
        }), optionsMap.set(rightElement, {
          ...rightOptions,
          currentMinWidth: 0,
          currentMaxWidth: (_c = leftOptions.maxWidth) != null ? _c : 1 / 0,
          flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
        }), resizeDataMap = /* @__PURE__ */ new Map(), delete cache.left, delete cache.right, _notifyObservers();
      }
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth, _notifyObservers();
  }
  function subscribe(observer) {
    return observers.push(observer), () => {
      const idx = observers.push(observer);
      idx > -1 && observers.splice(idx, 1);
    };
  }
  return { collapse, expand, mount, resize, setRootElement, setRootWidth, subscribe };
  function _notifyObservers() {
    var _a, _b, _c, _d;
    if (!rootWidth)
      return;
    const _elements = [];
    for (const element of elements)
      element !== expandedElement && _elements.unshift(element);
    expandedElement && _elements.unshift(expandedElement);
    const dataMap = /* @__PURE__ */ new WeakMap(), len = _elements.length, lastElement = _elements[0], collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options)
        continue;
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH, isLast = element === lastElement, userCollapsed = userCollapsedElementSet.has(element), sizeCollapsed = minWidth > remaingWidth, collapsed = isLast ? !1 : userCollapsed || sizeCollapsed, resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a = resizeData == null ? void 0 : resizeData.width) != null ? _a : options.currentMinWidth,
        currentMaxWidth: (_b = resizeData == null ? void 0 : resizeData.width) != null ? _b : options.currentMaxWidth,
        flex: (_d = (_c = resizeData == null ? void 0 : resizeData.flex) != null ? _c : options.flex) != null ? _d : 1
      }), collapsed ? remaingWidth -= PANE_COLLAPSED_WIDTH : remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      data && panes.push(data);
    }
    for (const observer of observers)
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
  }
}
function PaneLayout(props) {
  const { children, minWidth, onCollapse, onExpand, ...restProps } = props, controller = React.useMemo(() => createPaneLayoutController(), []), [rootElement, setRootElement] = React.useState(null), rootRect = ui.useElementRect(rootElement), width = (rootRect == null ? void 0 : rootRect.width) || 0, collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth, [state2, setState] = React.useState({
    expandedElement: null,
    panes: [],
    resizing: !1
  });
  React.useEffect(() => controller.setRootElement(rootElement), [controller, rootElement]), React.useEffect(() => controller.setRootWidth(width), [controller, width]), React.useEffect(() => controller.subscribe(setState), [controller]), React.useEffect(() => {
    collapsed !== void 0 && (collapsed && onCollapse && onCollapse(), !collapsed && onExpand && onExpand());
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = React.useMemo(
    () => ({
      collapse: controller.collapse,
      collapsed,
      expand: controller.expand,
      expandedElement: state2.expandedElement,
      mount: controller.mount,
      panes: state2.panes,
      resize: controller.resize,
      resizing: state2.resizing
    }),
    [collapsed, controller, state2.expandedElement, state2.panes, state2.resizing]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(PaneLayoutContext.Provider, { value: paneLayout, children: /* @__PURE__ */ jsxRuntime.jsx(
    Root$b,
    {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state2.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    }
  ) });
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
const isNotMenuNodeButton = negate__default.default(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a, _b;
  const { fieldActions = [], menuItems, menuItemGroups } = params, nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, `${i}-${a.type}`));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups)
    groups.find((g) => g.key === itemGroup.id) || groups.push({
      type: "group",
      key: itemGroup.id,
      children: [],
      expanded: !0,
      renderAsButton: !1,
      title: itemGroup.title,
      i18n: itemGroup.i18n
    });
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    item.group && !group && (group = {
      type: "group",
      key: item.group,
      expanded: !0,
      icon: item.icon,
      title: item.group,
      children: [],
      renderAsButton: !1
    }, groups.push(group)), group ? group.children.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_a = item.showAsAction) != null ? _a : !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    }) : ungroupedItems.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      onAction: () => params.actionHandler(item),
      renderAsButton: (_b = item.showAsAction) != null ? _b : !1,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    });
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a, _b, _c;
  return a.type === "divider" ? {
    type: "divider",
    key
  } : a.type === "group" ? {
    type: "group",
    key,
    children: a.children.map(
      (child, childIdx) => mapFieldActionToPaneMenuNode(child, `${key}-${childIdx}-${child.type}`)
    ),
    disabled: a.disabled,
    expanded: (_a = a.expanded) != null ? _a : !0,
    icon: a.icon,
    title: a.title,
    i18n: a.i18n,
    renderAsButton: (_b = a.renderAsButton) != null ? _b : !1
  } : {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: (_c = a.renderAsButton) != null ? _c : !1,
    selected: a.selected,
    title: a.title,
    i18n: a.i18n,
    tone: a.tone
  };
}
const IntentButton = React.forwardRef(function(props, ref) {
  const { intent, ...restProps } = props, Link2 = React.useMemo(
    () => (
      // eslint-disable-next-line @typescript-eslint/no-shadow
      React.forwardRef(function(linkProps, linkRef) {
        return /* @__PURE__ */ jsxRuntime.jsx(router$1.IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef });
      })
    ),
    [intent]
  );
  return props.disabled ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      ...restProps,
      as: Link2,
      "data-as": "a",
      ref
    }
  );
});
function InsufficientPermissionsMessageTooltip({
  reveal,
  context,
  loading,
  children
}) {
  const currentUser = sanity.useCurrentUser(), { t } = sanity.useTranslation(structureLocaleNamespace);
  return reveal ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: loading ? t("insufficient-permissions-message-tooltip.loading-text") : /* @__PURE__ */ jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, { context, currentUser }),
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children });
}
const POPOVER_PROPS$1 = {
  constrainSize: !0,
  placement: "bottom",
  portal: !0
}, getIntent = (schema2, templates, item) => {
  var _a;
  const typeName = (_a = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a.schemaType;
  if (!typeName)
    return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams
  };
};
function PaneHeaderCreateButton({ templateItems }) {
  const schema2 = sanity.useSchema(), templates = sanity.useTemplates(), { t } = sanity.useTranslation(structureLocaleNamespace), getI18nText = sanity.useGetI18nText([...templateItems, ...templates]), [templatePermissions, isTemplatePermissionsLoading] = sanity.useTemplatePermissions({
    templateItems
  }), nothingGranted = React.useMemo(() => !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted)), [isTemplatePermissionsLoading, templatePermissions]), permissionsById = React.useMemo(() => templatePermissions ? templatePermissions.reduce(
    (acc, permission) => (acc[permission.id] = permission, acc),
    {}
  ) : {}, [templatePermissions]);
  if (nothingGranted)
    return /* @__PURE__ */ jsxRuntime.jsx(
      InsufficientPermissionsMessageTooltip,
      {
        context: "create-document-type",
        reveal: !0,
        loading: isTemplatePermissionsLoading,
        children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            "aria-label": t("pane-header.disabled-created-button.aria-label"),
            icon: icons.AddIcon,
            "data-testid": "action-intent-button",
            disabled: !0,
            mode: "bleed",
            tooltipProps: null
          }
        )
      }
    );
  if (templateItems.length === 1) {
    const firstItem = templateItems[0], permissions = permissionsById[firstItem.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema2, templates, firstItem);
    return intent ? /* @__PURE__ */ jsxRuntime.jsx(
      InsufficientPermissionsMessageTooltip,
      {
        reveal: disabled,
        loading: isTemplatePermissionsLoading,
        context: "create-document-type",
        children: /* @__PURE__ */ jsxRuntime.jsx(
          IntentButton,
          {
            "aria-label": getI18nText(firstItem).title,
            icon: firstItem.icon || icons.AddIcon,
            intent,
            mode: "bleed",
            disabled,
            "data-testid": "action-intent-button",
            tooltipProps: disabled ? null : { content: t("pane-header.create-new-button.tooltip") }
          }
        )
      }
    ) : null;
  }
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: icons.AddIcon,
          mode: "bleed",
          "data-testid": "multi-action-intent-button",
          tooltipProps: { content: t("pane-header.create-new-button.tooltip") }
        }
      ),
      id: "create-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: templateItems.map((item, itemIndex) => {
        const permissions = permissionsById[item.id], disabled = !(permissions != null && permissions.granted), intent = getIntent(schema2, templates, item), template2 = templates.find((i) => i.id === item.templateId);
        if (!template2 || !intent)
          return null;
        const Link2 = React.forwardRef(
          (linkProps, linkRef) => disabled ? /* @__PURE__ */ jsxRuntime.jsx("button", { type: "button", disabled: !0, ...linkProps, ref: linkRef }) : /* @__PURE__ */ jsxRuntime.jsx(
            router$1.IntentLink,
            {
              ...linkProps,
              intent: intent.type,
              params: intent.params,
              ref: linkRef
            }
          )
        );
        Link2.displayName = "Link";
        const { title } = getI18nText({
          ...item,
          // replace the title with the template title
          title: item.title || getI18nText(template2).title
        });
        return /* @__PURE__ */ jsxRuntime.jsx(
          InsufficientPermissionsMessageTooltip,
          {
            context: "create-document-type",
            reveal: disabled,
            loading: isTemplatePermissionsLoading,
            children: /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                as: Link2,
                "data-as": disabled ? "button" : "a",
                text: title,
                "aria-label": disabled ? t("pane-header.disabled-created-button.aria-label") : title,
                disabled,
                "data-testid": `action-intent-button-${itemIndex}`
              }
            )
          },
          item.id
        );
      }) }),
      popover: POPOVER_PROPS$1
    }
  );
}
function isNonNullable(value) {
  return value != null;
}
const hashObject = (value) => {
  const sortObject = (v) => typeof v != "object" || !v ? v : Array.isArray(v) ? v.map(sortObject) : Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, "en"));
  return JSON.stringify(sortObject(((v) => JSON.parse(JSON.stringify(v)))(value)));
}, PaneHeaderActions = React.memo(function(props) {
  const {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = sanity.EMPTY_ARRAY,
    menuItems = sanity.EMPTY_ARRAY,
    menuItemGroups = sanity.EMPTY_ARRAY,
    actionHandlers = sanity.EMPTY_OBJECT
  } = props, templates = sanity.useTemplates(), handleAction = React.useCallback(
    (item) => {
      if (typeof item.action == "string" && !(item.action in actionHandlers))
        return console.warn("No handler for action:", item.action), !1;
      const handler = (
        // eslint-disable-next-line no-nested-ternary
        typeof item.action == "function" ? item.action : typeof item.action == "string" ? actionHandlers[item.action] : null
      );
      return handler ? (handler(item.params), !0) : !1;
    },
    [actionHandlers]
  ), menuNodes = React.useMemo(
    () => resolveMenuNodes({
      actionHandler: handleAction,
      menuItemGroups,
      menuItems: menuItems.filter((item) => {
        var _a;
        return ((_a = item.intent) == null ? void 0 : _a.type) !== "create";
      })
    }),
    [handleAction, menuItemGroups, menuItems]
  ), actionNodes = React.useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = React.useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), initialValueTemplateItemFromMenuItems = React.useMemo(() => menuItems.map((item, menuItemIndex) => {
    var _a;
    if (((_a = item.intent) == null ? void 0 : _a.type) !== "create")
      return null;
    const { params } = item.intent;
    if (!params)
      return null;
    const intentParams = Array.isArray(params) ? params[0] : params, templateParams = Array.isArray(params) ? params[1] : void 0, templateId = intentParams.template || intentParams.type;
    if (!templateId)
      return null;
    const template2 = templates.find((t) => t.id === templateId);
    if (!template2)
      return null;
    const initialDocumentId = intentParams.id;
    return {
      item,
      template: template2,
      templateParams,
      menuItemIndex,
      initialDocumentId
    };
  }).filter(isNonNullable).map(({ initialDocumentId, item, template: template2, menuItemIndex, templateParams }) => ({
    id: `menuItem${menuItemIndex}`,
    initialDocumentId,
    templateId: template2.id,
    type: "initialValueTemplateItem",
    title: item.title || template2.title,
    i18n: item.i18n || template2.i18n,
    icon: item.icon,
    description: template2.description,
    parameters: templateParams,
    schemaType: template2.schemaType
  })), [menuItems, templates]), combinedInitialValueTemplates = React.useMemo(() => uniqBy__default.default(
    [...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure],
    (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters])
  ), [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
    combinedInitialValueTemplates.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }),
    actionNodes.map((node) => /* @__PURE__ */ jsxRuntime.jsx(PaneHeaderActionButton, { node }, node.key)),
    contextMenuNodes.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(PaneContextMenuButton, { nodes: contextMenuNodes })
  ] });
});
function MissingSchemaType(props) {
  const { t } = sanity.useTranslation(structureLocaleNamespace), { layout, value } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    sanity.SanityDefaultPreview,
    {
      title: /* @__PURE__ */ jsxRuntime.jsx("em", { children: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.title",
          components: { Code: "code" },
          values: { documentType: value._type }
        }
      ) }),
      subtitle: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          t,
          i18nKey: "pane-item.missing-schema-type.subtitle",
          components: { Code: "code" },
          values: { documentId: value._id }
        }
      ),
      media: () => /* @__PURE__ */ jsxRuntime.jsx(icons.WarningOutlineIcon, {}),
      layout
    }
  );
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  return icon === !1 ? !1 : icon || schemaType && schemaType.icon || defaultIcon || !1;
}
function PaneItem(props) {
  const {
    icon,
    id,
    layout = "default",
    pressed,
    schemaType,
    selected,
    title,
    value,
    margin,
    marginBottom,
    marginTop
  } = props, schema2 = sanity.useSchema(), documentPreviewStore = sanity.useDocumentPreviewStore(), { ChildLink: ChildLink2 } = usePaneRouter(), documentPresence = sanity.useDocumentPresence(id), hasSchemaType = !!(schemaType && schemaType.name && schema2.get(schemaType.name)), [clicked, setClicked] = React.useState(!1), preview = React.useMemo(() => value && types.isSanityDocument(value) ? !schemaType || !hasSchemaType ? /* @__PURE__ */ jsxRuntime.jsx(MissingSchemaType, { value }) : /* @__PURE__ */ jsxRuntime.jsx(
    PaneItemPreview,
    {
      documentPreviewStore,
      icon: getIconWithFallback(icon, schemaType, icons.DocumentIcon),
      layout,
      schemaType,
      value,
      presence: documentPresence
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    sanity.SanityDefaultPreview,
    {
      status: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { opacity: 0.5 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}) }) }),
      icon: getIconWithFallback(icon, schemaType, icons.FolderIcon),
      layout: "compact",
      title
    }
  ), [
    documentPreviewStore,
    hasSchemaType,
    icon,
    layout,
    schemaType,
    title,
    value,
    documentPresence
  ]), Link2 = React.useMemo(
    () => function(linkProps) {
      return /* @__PURE__ */ jsxRuntime.jsx(ChildLink2, { ...linkProps, childId: id });
    },
    [ChildLink2, id]
  ), handleClick = React.useCallback((e) => {
    if (e.metaKey) {
      setClicked(!1);
      return;
    }
    setClicked(!0);
  }, []);
  return React.useEffect(() => setClicked(!1), [selected]), /* @__PURE__ */ jsxRuntime.jsx(
    sanity.PreviewCard,
    {
      __unstable_focusRing: !0,
      as: Link2,
      "data-as": "a",
      margin,
      marginBottom,
      marginTop,
      onClick: handleClick,
      pressed,
      radius: 2,
      selected: selected || clicked,
      sizing: "border",
      tabIndex: -1,
      tone: "inherit",
      children: preview
    }
  );
}
const RenderActionCollectionState = (props) => {
  const { actions, children, actionProps, onActionComplete, group } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    sanity.GetHookCollectionState,
    {
      onReset: onActionComplete,
      hooks: actions,
      args: actionProps,
      group,
      children
    }
  );
}, RenderBadgeCollectionState = (props) => {
  const { badges, children, badgeProps, ...rest } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.GetHookCollectionState, { ...rest, hooks: badges, args: badgeProps, children });
};
function useNotificationTarget(opts) {
  const { documentId, documentType } = opts || {}, schemaType = sanity.useSchema().get(documentType), { title: workspaceTitle } = sanity.useWorkspace(), { createPathWithParams, params } = usePaneRouter(), documentPreviewStore = sanity.useDocumentPreviewStore(), previewState = reactRx.useMemoObservable(() => !documentId || !schemaType ? rxjs.of(null) : sanity.getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title) || "Sanity document";
  return {
    getNotificationValue: React.useCallback(
      ({ commentId }) => {
        const path = createPathWithParams({
          ...params,
          comment: commentId,
          inspect: COMMENTS_INSPECTOR_NAME
        }), url = `${window.location.origin}${path}`;
        return { documentTitle, url, workspaceTitle };
      },
      [createPathWithParams, documentTitle, params, workspaceTitle]
    )
  };
}
async function createOperation(props) {
  const {
    activeTool,
    client,
    comment,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getIntent: getIntent2,
    getNotificationValue,
    getThreadLength,
    onCreate,
    onCreateError,
    projectId,
    createAddonDataset,
    workspace
  } = props, commentId = (comment == null ? void 0 : comment.id) || uuid.uuid(), authorId = currentUser.id, currentThreadLength = ((getThreadLength == null ? void 0 : getThreadLength(comment.threadId)) || 0) + 1;
  let nextComment;
  if (comment.type === "task" && (nextComment = {
    _id: commentId,
    _type: "comment",
    authorId,
    message: comment.message,
    lastEditedAt: void 0,
    parentCommentId: comment.parentCommentId,
    status: comment.status,
    threadId: comment.threadId,
    reactions: comment.reactions,
    context: {
      payload: {
        workspace
      },
      notification: comment.context.notification,
      tool: (activeTool == null ? void 0 : activeTool.name) || ""
    },
    target: {
      document: {
        _ref: documentId,
        _type: "reference",
        _weak: !0
      },
      documentType
    }
  }), comment.type === "field") {
    const {
      documentTitle = "",
      url = "",
      workspaceTitle = ""
    } = getNotificationValue({ commentId }) || {}, notification = {
      currentThreadLength,
      documentTitle,
      url,
      workspaceTitle
    }, intent = getIntent2 == null ? void 0 : getIntent2({ id: documentId, type: documentType, path: comment.fieldPath });
    nextComment = {
      _id: commentId,
      _type: "comment",
      authorId,
      message: comment.message,
      lastEditedAt: void 0,
      parentCommentId: comment.parentCommentId,
      status: comment.status,
      threadId: comment.threadId,
      reactions: comment.reactions,
      context: {
        payload: {
          workspace
        },
        intent,
        notification,
        tool: (activeTool == null ? void 0 : activeTool.name) || ""
      },
      contentSnapshot: comment.contentSnapshot,
      target: {
        documentRevisionId: documentRevisionId || "",
        path: {
          field: comment.fieldPath,
          selection: comment.selection
        },
        document: {
          _dataset: dataset,
          _projectId: projectId,
          _ref: documentId,
          _type: "crossDatasetReference",
          _weak: !0
        },
        documentType
      }
    };
  }
  if (nextComment) {
    if (onCreate == null || onCreate(nextComment), !client) {
      try {
        const newAddonClient = await createAddonDataset();
        if (!newAddonClient)
          throw new Error("Failed to create addon dataset client");
        await newAddonClient.create(nextComment);
      } catch (err) {
        throw onCreateError == null || onCreateError(nextComment._id, err), err;
      }
      return;
    }
    try {
      await client.create(nextComment);
    } catch (err) {
      throw onCreateError == null || onCreateError(nextComment._id, err), err;
    }
  }
}
function createReactionKey(userId, shortName) {
  return `${userId}-${shortName}`;
}
async function reactOperation(props) {
  var _a;
  const { client, currentUser, id, reaction, getComment, onUpdate } = props, reactions = ((_a = getComment == null ? void 0 : getComment(id)) == null ? void 0 : _a.reactions) || [], currentUserReactions = reactions.filter((r) => r.userId === currentUser.id), _key = createReactionKey(currentUser.id, reaction.shortName), currentReaction = currentUserReactions.find(
    (r) => r._key === _key && r._optimisticState !== "removed"
  );
  if (currentReaction) {
    const next = reactions.map((r) => r._key === currentReaction._key ? { ...r, _optimisticState: "removed" } : r);
    onUpdate == null || onUpdate(id, { reactions: next }), await client.patch(id).unset([`reactions[_key=="${_key}"]`]).commit();
    return;
  }
  if (!currentReaction) {
    const reactionItem = {
      _key,
      addedAt: (/* @__PURE__ */ new Date()).toISOString(),
      shortName: reaction.shortName,
      userId: currentUser.id
    }, optimisticReactionItem = { ...reactionItem, _optimisticState: "added" }, next = reactions.concat(optimisticReactionItem).filter((r) => !(r._key === reactionItem._key && r._optimisticState === "removed"));
    onUpdate == null || onUpdate(id, { reactions: next }), await client.patch(id).setIfMissing({ reactions: [] }).append("reactions", [reactionItem]).commit();
  }
}
async function removeOperation(props) {
  const { client, id, onRemove } = props;
  onRemove == null || onRemove(id), await Promise.all([
    client.delete({ query: `*[_type == "comment" && parentCommentId == "${id}"]` }),
    client.delete(id)
  ]);
}
const THROTTLE_TIME_MS = 1e3, THROTTLE_SETTINGS = {
  trailing: !0,
  leading: !1
}, throttleFunctionsMap = /* @__PURE__ */ new Map();
function getThrottledFunction(id) {
  if (!throttleFunctionsMap.has(id)) {
    const throttledFunction = throttle__default.default(postCommentUpdate, THROTTLE_TIME_MS, THROTTLE_SETTINGS);
    return throttleFunctionsMap.set(id, throttledFunction), throttledFunction;
  }
  return throttleFunctionsMap.get(id);
}
async function postCommentUpdate(props) {
  const { client, id, comment, transactionId: transactionIdProp, onUpdate } = props, transactionId = transactionIdProp || uuid.uuid(), patch = client == null ? void 0 : client.patch(id).set(comment), transaction = client.transaction().transactionId(transactionId).patch(patch);
  onUpdate == null || onUpdate(id, comment), comment.status ? (await transaction.commit(), await client.patch({ query: `*[_type == "comment" && parentCommentId == "${id}"]` }).set({
    status: comment.status
  }).commit()) : await transaction.commit(), throttleFunctionsMap.delete(id);
}
async function updateOperation(props) {
  const { id, comment, throttled: throttledProp } = props, hasEditedMessage = "message" in comment, editedComment = {
    ...comment,
    lastEditedAt: (/* @__PURE__ */ new Date()).toISOString()
  }, nextComment = hasEditedMessage ? editedComment : comment;
  if (!throttledProp) {
    await postCommentUpdate({
      ...props,
      comment: nextComment
    });
    return;
  }
  await getThrottledFunction(id)({
    ...props,
    comment: nextComment
  });
}
function useCommentOperations(opts) {
  const {
    client,
    currentUser,
    dataset,
    documentId,
    documentRevisionId,
    documentType,
    getComment,
    getThreadLength,
    onCreate,
    onCreateError,
    onRemove,
    onTransactionStart,
    onUpdate,
    projectId,
    createAddonDataset,
    workspace
  } = opts, getIntent2 = useCommentsIntent(), activeToolName = router$1.useRouterState(
    React.useCallback(
      (routerState) => typeof routerState.tool == "string" ? routerState.tool : void 0,
      []
    )
  ), tools = sanity.useTools(), activeTool = React.useMemo(
    () => tools.find((tool) => tool.name === activeToolName),
    [activeToolName, tools]
  ), { getNotificationValue } = useNotificationTarget({ documentId, documentType }), handleCreate = React.useCallback(
    async (comment) => {
      currentUser != null && currentUser.id && await createOperation({
        activeTool,
        client,
        comment,
        currentUser,
        dataset,
        documentId,
        documentRevisionId,
        documentType,
        getIntent: getIntent2,
        getNotificationValue,
        getThreadLength,
        onCreate,
        onCreateError,
        projectId,
        createAddonDataset,
        workspace
      });
    },
    [
      activeTool,
      client,
      currentUser,
      dataset,
      documentId,
      documentRevisionId,
      documentType,
      getIntent2,
      getNotificationValue,
      getThreadLength,
      onCreate,
      onCreateError,
      projectId,
      createAddonDataset,
      workspace
    ]
  ), handleRemove = React.useCallback(
    async (id) => {
      client && await removeOperation({
        client,
        id,
        onRemove
      });
    },
    [client, onRemove]
  ), handleUpdate = React.useCallback(
    async (id, comment, updateOpts) => {
      if (!client)
        return;
      const { throttled } = updateOpts || {}, nextTransactionId = uuid.uuid();
      onTransactionStart(id, nextTransactionId), await updateOperation({
        client,
        comment,
        throttled,
        id,
        onUpdate,
        transactionId: nextTransactionId
      });
    },
    [client, onTransactionStart, onUpdate]
  ), handleReact = React.useCallback(
    async (id, reaction) => {
      !client || !(currentUser != null && currentUser.id) || await reactOperation({
        client,
        currentUser,
        id,
        reaction,
        getComment,
        onUpdate
      });
    },
    [client, currentUser, getComment, onUpdate]
  );
  return React.useMemo(
    () => ({
      operation: {
        create: handleCreate,
        react: handleReact,
        remove: handleRemove,
        update: handleUpdate
      }
    }),
    [handleCreate, handleRemove, handleUpdate, handleReact]
  );
}
function useComments() {
  const value = React.useContext(CommentsContext);
  if (!value)
    throw new Error("useComments must be used within a CommentsProvider");
  return value;
}
function useCommentsAuthoringPath() {
  const value = React.useContext(CommentsAuthoringPathContext);
  if (!value)
    throw new Error("useCommentsAuthoringPath: missing context value");
  return value;
}
function useCommentsEnabled() {
  const ctx = React.useContext(CommentsEnabledContext);
  if (ctx === null)
    throw new Error("useCommentsEnabled: missing context value");
  return ctx;
}
function useCommentsOnboarding() {
  const ctx = React.useContext(CommentsOnboardingContext);
  if (!ctx)
    throw new Error("useCommentsOnboarding: missing context value");
  return ctx;
}
const BASE_SCROLL_OPTIONS = {
  behavior: "smooth",
  inline: "center",
  scrollMode: "if-needed"
}, GROUP_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "start"
}, INLINE_COMMENT_SCROLL_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_TO_FIELD_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_TO_COMMENT_OPTIONS = {
  ...BASE_SCROLL_OPTIONS,
  block: "center"
}, SCROLL_OPTIONS_BY_TYPE = {
  comment: SCROLL_TO_COMMENT_OPTIONS,
  field: SCROLL_TO_FIELD_OPTIONS,
  group: GROUP_SCROLL_OPTIONS,
  "inline-comment": INLINE_COMMENT_SCROLL_OPTIONS
};
function generateValidAttrValue(id) {
  const symbolsToRemove = /[[\]_"_=.]/g;
  return id.replace(symbolsToRemove, "");
}
function applyCommentIdAttr(id) {
  return {
    "data-comments-comment-id": generateValidAttrValue(id)
  };
}
function applyCommentsFieldAttr(id) {
  return {
    "data-comments-field-id": generateValidAttrValue(id)
  };
}
function applyCommentsGroupAttr(id) {
  return {
    "data-comments-group-id": generateValidAttrValue(id)
  };
}
function applyInlineCommentIdAttr(id) {
  return {
    "data-comments-inline-comment-id": generateValidAttrValue(id)
  };
}
function useCommentsScroll(opts) {
  const { boundaryElement } = opts || {}, [scrollTarget, setScrollTarget] = React.useState(null), scrollOpts = React.useMemo(() => ({
    ...SCROLL_OPTIONS_BY_TYPE[(scrollTarget == null ? void 0 : scrollTarget.type) || "comment"],
    boundary: boundaryElement
  }), [boundaryElement, scrollTarget == null ? void 0 : scrollTarget.type]), handleScrollToComment = React.useCallback((commentId) => {
    setScrollTarget({ type: "comment", id: commentId });
  }, []), handleScrollToGroup = React.useCallback((threadId) => {
    setScrollTarget({ type: "group", id: threadId });
  }, []), handleScrollToField = React.useCallback((fieldPath) => {
    setScrollTarget({ type: "field", id: fieldPath });
  }, []), handleScrollToInlineComment = React.useCallback((commentId) => {
    setScrollTarget({ type: "inline-comment", id: commentId });
  }, []);
  return React.useEffect(() => {
    const raf = requestAnimationFrame(() => {
      if (!scrollTarget)
        return;
      const { type, id } = scrollTarget, element = document == null ? void 0 : document.querySelector(
        `[data-comments-${type}-id="${generateValidAttrValue(id)}"]`
      );
      element && scrollIntoView__default.default(element, scrollOpts);
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [scrollOpts, scrollTarget]), React.useMemo(
    () => ({
      scrollToComment: handleScrollToComment,
      scrollToField: handleScrollToField,
      scrollToGroup: handleScrollToGroup,
      scrollToInlineComment: handleScrollToInlineComment
    }),
    [handleScrollToComment, handleScrollToField, handleScrollToGroup, handleScrollToInlineComment]
  );
}
function useCommentsSelectedPath() {
  const ctx = React.useContext(CommentsSelectedPathContext);
  if (!ctx)
    throw new Error("useCommentsSelectedPath: missing context value");
  return ctx;
}
function useCommentsUpsell() {
  return React.useContext(CommentsUpsellContext) || {
    upsellData: null,
    handleOpenDialog: () => null,
    upsellDialogOpen: !1,
    telemetryLogs: {
      dialogSecondaryClicked: () => null,
      dialogPrimaryClicked: () => null,
      panelViewed: () => null,
      panelDismissed: () => null,
      panelPrimaryClicked: () => null,
      panelSecondaryClicked: () => null
    }
  };
}
function useResolveCommentsEnabled(documentId, documentType) {
  const { enabled: featureEnabled, isLoading, error } = sanity.useFeatureEnabled("studioComments"), { enabled } = sanity.useSource().document.unstable_comments, enabledFromConfig = React.useMemo(
    () => enabled({ documentType, documentId: sanity.getPublishedId(documentId) }),
    [documentId, documentType, enabled]
  );
  return React.useMemo(() => isLoading || !enabledFromConfig || error ? { enabled: !1, mode: null } : {
    enabled: !0,
    mode: featureEnabled ? "default" : "upsell"
  }, [isLoading, enabledFromConfig, error, featureEnabled]);
}
const StyledAvatar = styled__default.default(ui.Avatar)`
  svg > ellipse {
    stroke: transparent;
  }
`, SYMBOLS = /[^\p{Alpha}\p{White_Space}]/gu, WHITESPACE = new RegExp("\\p{White_Space}+", "u");
function nameToInitials(fullName) {
  const namesArray = fullName.replace(SYMBOLS, "").split(WHITESPACE);
  return namesArray.length === 1 ? `${namesArray[0].charAt(0)}`.toUpperCase() : `${namesArray[0].charAt(0)}${namesArray[namesArray.length - 1].charAt(0)}`;
}
function CommentsAvatar(props) {
  const { user: userProp, ...restProps } = props, user = userProp, initials = React.useMemo(() => nameToInitials((user == null ? void 0 : user.displayName) || ""), [user == null ? void 0 : user.displayName]);
  return user ? /* @__PURE__ */ jsxRuntime.jsx(
    StyledAvatar,
    {
      initials,
      src: user == null ? void 0 : user.imageUrl,
      title: user == null ? void 0 : user.displayName,
      ...restProps
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(StyledAvatar, { ...restProps });
}
const SpacerAvatar = styled__default.default.div((props) => {
  var _a;
  const theme$1 = theme.getTheme_v2(props.theme), { $size = 1 } = props;
  return styled.css`
    min-width: ${(_a = theme$1.avatar.sizes[$size]) == null ? void 0 : _a.size}px;
  `;
}), mentionObject = types.defineField({
  name: "mention",
  type: "object",
  fields: [
    {
      name: "userId",
      type: "string"
    }
  ]
}), blockType = types.defineField({
  type: "block",
  name: "block",
  of: [mentionObject],
  marks: {
    annotations: []
  },
  styles: [{ title: "Normal", value: "normal" }],
  lists: []
}), portableTextType = types.defineArrayMember({
  type: "array",
  name: "body",
  of: [blockType]
}), schema = schema$1.Schema.compile({
  name: "comments",
  types: [portableTextType]
}), editorSchemaType = schema.get("body"), Span$1 = styled__default.default.span(({ theme: theme2 }) => {
  var _a, _b, _c;
  const { regular } = ((_a = theme2.sanity.fonts) == null ? void 0 : _a.text.weights) || {}, { hovered } = ((_b = theme2.sanity.color) == null ? void 0 : _b.card) || {}, { bg } = ((_c = theme2.sanity.color.selectable) == null ? void 0 : _c.caution.pressed) || {};
  return styled.css`
    font-weight: ${regular};
    color: var(--card-link-fg-color);
    border-radius: 2px;
    background-color: ${hovered.bg};
    padding: 1px;
    box-sizing: border-box;

    &[data-active='true'] {
      background-color: ${bg};
    }
  `;
});
function MentionInlineBlock(props) {
  const { selected, userId } = props, [user, loading] = sanity.useUser(userId), currentUser = sanity.useCurrentUser();
  return !user || loading ? /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextSkeleton,
    {
      "data-testid": "comment-mentions-loading-skeleton",
      style: { width: "10ch" },
      size: 0,
      muted: !0,
      radius: 1,
      animated: !0
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      portal: !0,
      content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: user.displayName })
      ] }),
      children: /* @__PURE__ */ jsxRuntime.jsxs(Span$1, { "data-selected": selected, "data-active": (currentUser == null ? void 0 : currentUser.id) === userId, children: [
        "@",
        user.displayName
      ] })
    }
  );
}
const NormalText$1 = styled__default.default(ui.Text)`
  word-break: break-word;
`;
function NormalBlock(props) {
  const { children } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(NormalText$1, { size: 1, children });
}
const renderBlock$1 = (blockProps) => {
  const { children } = blockProps;
  return /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children });
}, renderChild = (childProps) => {
  const { children, value, selected } = childProps;
  return value._type === "mention" && value.userId ? /* @__PURE__ */ jsxRuntime.jsx(MentionInlineBlock, { selected, userId: value == null ? void 0 : value.userId }) : children;
}, Z_OFFSET = 9999999;
function CommentInputDiscardDialog(props) {
  const { t } = sanity.useTranslation(commentsLocaleNamespace), { onClose, onConfirm } = props, handleCancelClick = React.useCallback(
    (e) => {
      e.stopPropagation(), onClose();
    },
    [onClose]
  ), handleConfirmClick = React.useCallback(
    (e) => {
      e.stopPropagation(), onConfirm();
    },
    [onConfirm]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeColorProvider, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(ui.DialogProvider, { zOffset: Z_OFFSET, children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      header: t("discard.header"),
      id: "discard-comment-dialog",
      onClose,
      width: 0,
      onClickOutside: onClose,
      footer: {
        cancelButton: {
          onClick: handleCancelClick
        },
        confirmButton: {
          onClick: handleConfirmClick,
          text: t("discard.button-confirm"),
          tone: "critical"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t("discard.text") })
    }
  ) }) });
}
const InnerFlex = styled__default.default(ui.Flex)``, SKELETON_INLINE_STYLE$1 = { width: "50%" };
function MentionsMenuItem(props) {
  const { user, onSelect } = props, [loadedUser] = sanity.useUser(user.id), { t } = sanity.useTranslation(commentsLocaleNamespace), avatar = /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user: loadedUser, status: user.granted ? void 0 : "inactive" }), text = loadedUser ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", title: loadedUser.displayName, children: loadedUser.displayName }) : /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE$1 }), handleSelect = React.useCallback(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "button", disabled: !user.granted, onClick: handleSelect, padding: 2, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(InnerFlex, { align: "center", gap: 2, flex: 1, children: [
      avatar,
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: text })
    ] }),
    !user.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t("mentions.unauthorized-user") })
  ] }) });
}
const EMPTY_ARRAY$f = [], Root$a = styled__default.default(ui.Stack)({
  maxWidth: "220px"
  // todo: improve
}), ITEM_HEIGHT = 41, LIST_PADDING = 4, MAX_ITEMS = 7, FlexWrap = styled__default.default(ui.Flex)({
  maxHeight: ITEM_HEIGHT * MAX_ITEMS + LIST_PADDING * 2 + ITEM_HEIGHT / 2
}), MentionsMenu$1 = React__namespace.forwardRef(function(props, ref) {
  const { t } = sanity.useTranslation(commentsLocaleNamespace), { loading, onSelect, options = [], inputElement } = props, [searchTerm, setSearchTerm] = React.useState(""), commandListRef = React.useRef(null);
  React.useImperativeHandle(
    ref,
    () => ({
      setSearchTerm(term) {
        setSearchTerm(term);
      }
    }),
    []
  );
  const renderItem2 = React.useCallback(
    (itemProps) => /* @__PURE__ */ jsxRuntime.jsx(MentionsMenuItem, { user: itemProps, onSelect }),
    [onSelect]
  ), getItemDisabled = React.useCallback(
    (index) => {
      var _a;
      return !((_a = options == null ? void 0 : options[index]) != null && _a.granted);
    },
    [options]
  ), filteredOptions = React.useMemo(() => {
    var _a;
    if (!searchTerm)
      return options || EMPTY_ARRAY$f;
    const deburredSearchTerm = deburr__default.default(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      displayName: deburr__default.default(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a2;
      return (_a2 = option == null ? void 0 : option.displayName) == null ? void 0 : _a2.includes(deburredSearchTerm);
    })) == null ? void 0 : _a.sort((a, b) => {
      var _a2, _b;
      const matchA = (_a2 = a.displayName) == null ? void 0 : _a2.startsWith(deburredSearchTerm), matchB = (_b = b.displayName) == null ? void 0 : _b.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || EMPTY_ARRAY$f;
  }, [options, searchTerm]);
  if (loading)
    return /* @__PURE__ */ jsxRuntime.jsx(Root$a, { children: /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0 }) });
  const _inputElement = inputElement || void 0;
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", "data-testid": "comments-mentions-menu", children: [
    filteredOptions.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, children: t("mentions.no-users-found") }) }),
    filteredOptions.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(FlexWrap, { direction: "column", flex: 1, overflow: "hidden", children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: t("mentions.user-list-aria-label"),
        fixedHeight: !0,
        getItemDisabled,
        inputElement: _inputElement,
        itemHeight: 41,
        items: filteredOptions,
        padding: 1,
        ref: commandListRef,
        renderItem: renderItem2
      }
    ) })
  ] });
}), CommentInputContext = React__namespace.default.createContext(null);
function CommentInputProvider(props) {
  const {
    children,
    expandOnFocus = !1,
    focused,
    focusOnMount = !1,
    mentionOptions,
    onMentionMenuOpenChange,
    value,
    readOnly
  } = props, editor = portableTextEditor.usePortableTextEditor(), [mentionsMenuOpen, setMentionsMenuOpen] = React.useState(!1), [mentionsSearchTerm, setMentionsSearchTerm] = React.useState(""), [selectionAtMentionInsert, setSelectionAtMentionInsert] = React.useState(null), canSubmit = React.useMemo(() => hasCommentMessageValue(value), [value]), hasChanges = useCommentHasChanged(value), focusEditor = React.useCallback(() => {
    readOnly || portableTextEditor.PortableTextEditor.focus(editor);
  }, [editor, readOnly]), closeMentions = React.useCallback(() => {
    setMentionsMenuOpen(!1), setMentionsSearchTerm(""), setSelectionAtMentionInsert(null);
  }, []), openMentions = React.useCallback(() => {
    setMentionsMenuOpen(!0), setMentionsSearchTerm(""), setMentionsMenuOpen(!0), setSelectionAtMentionInsert(portableTextEditor.PortableTextEditor.getSelection(editor));
  }, [editor]), onBeforeInput = React.useCallback(
    (event) => {
      const selection = portableTextEditor.PortableTextEditor.getSelection(editor), cursorOffset = selection ? selection.focus.offset : 0, focusChild = portableTextEditor.PortableTextEditor.focusChild(editor), focusSpan = types.isPortableTextSpan(focusChild) && focusChild || void 0, isInsertText = event.inputType === "insertText", isDeleteText = event.inputType === "deleteContentBackward", isInsertingAtChar = isInsertText && event.data === "@", lastIndexOfAt = (focusSpan == null ? void 0 : focusSpan.text.substring(0, cursorOffset).lastIndexOf("@")) || 0, isWhitespaceCharBeforeCursorPosition = (focusSpan == null ? void 0 : focusSpan.text.substring(cursorOffset - 1, cursorOffset)) === " ", filterStartsWithSpaceChar = isInsertText && event.data === " " && !mentionsSearchTerm;
      if (isInsertingAtChar && (cursorOffset < 1 || isWhitespaceCharBeforeCursorPosition)) {
        openMentions();
        return;
      }
      if (filterStartsWithSpaceChar || isDeleteText && ((focusSpan == null ? void 0 : focusSpan.text.length) === 1 || lastIndexOfAt === ((focusSpan == null ? void 0 : focusSpan.text.length) || 0) - 1)) {
        closeMentions();
        return;
      }
      if (types.isPortableTextSpan(focusChild)) {
        let term = focusChild.text.substring(lastIndexOfAt + 1, cursorOffset);
        isInsertText && (term += event.data), isDeleteText && (term = term.substring(0, term.length - 1)), setMentionsSearchTerm(term);
      }
    },
    [closeMentions, editor, mentionsSearchTerm, openMentions]
  ), insertAtChar = React.useCallback(() => {
    setMentionsMenuOpen(!0), portableTextEditor.PortableTextEditor.focus(editor), portableTextEditor.PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: "@" }), setSelectionAtMentionInsert(portableTextEditor.PortableTextEditor.getSelection(editor));
  }, [editor]);
  sanity.useDidUpdate(mentionsMenuOpen, () => onMentionMenuOpenChange == null ? void 0 : onMentionMenuOpenChange(mentionsMenuOpen));
  const insertMention = React.useCallback(
    (userId) => {
      var _a;
      const mentionSchemaType = editor.schemaTypes.inlineObjects.find((t) => t.name === "mention"), [span, spanPath] = selectionAtMentionInsert && portableTextEditor.PortableTextEditor.findByPath(editor, selectionAtMentionInsert.focus.path) || [];
      if (span && types.isPortableTextSpan(span) && spanPath && mentionSchemaType) {
        portableTextEditor.PortableTextEditor.focus(editor);
        const offset = (_a = portableTextEditor.PortableTextEditor.getSelection(editor)) == null ? void 0 : _a.focus.offset;
        typeof offset < "u" && (portableTextEditor.PortableTextEditor.delete(
          editor,
          {
            anchor: { path: spanPath, offset: span.text.lastIndexOf("@") },
            focus: { path: spanPath, offset }
          },
          { mode: "selected" }
        ), portableTextEditor.PortableTextEditor.insertChild(editor, mentionSchemaType, {
          userId
        }), portableTextEditor.PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: " " }));
      }
    },
    [editor, selectionAtMentionInsert]
  ), ctxValue = React.useMemo(
    () => ({
      canSubmit,
      closeMentions,
      editor,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly: !!readOnly,
      value
    }),
    [
      canSubmit,
      closeMentions,
      editor,
      expandOnFocus,
      focused,
      focusEditor,
      focusOnMount,
      hasChanges,
      insertAtChar,
      insertMention,
      mentionOptions,
      mentionsMenuOpen,
      mentionsSearchTerm,
      onBeforeInput,
      openMentions,
      readOnly,
      value
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(CommentInputContext.Provider, { value: ctxValue, children });
}
function useCommentInput() {
  const ctx = React.useContext(CommentInputContext);
  if (!ctx)
    throw new Error("useCommentInputContext must be used within a CommentInputProvider");
  return ctx;
}
const EVENT_LISTENER_OPTIONS = { passive: !0 };
function useCursorElement(opts) {
  const { disabled, rootElement } = opts, [cursorRect, setCursorRect] = React.useState(null), cursorElement = React.useMemo(() => cursorRect ? {
    getBoundingClientRect: () => cursorRect
  } : null, [cursorRect]), handleSelectionChange = React.useCallback(() => {
    if (disabled) {
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || !sel.isCollapsed || sel.rangeCount === 0)
      return;
    const range = sel.getRangeAt(0);
    if (!(rootElement != null && rootElement.contains(range.commonAncestorContainer))) {
      setCursorRect(null);
      return;
    }
    const rect = range == null ? void 0 : range.getBoundingClientRect();
    rect && setCursorRect(rect);
  }, [disabled, rootElement]);
  return React.useEffect(() => (document.addEventListener("selectionchange", handleSelectionChange, EVENT_LISTENER_OPTIONS), () => {
    document.removeEventListener("selectionchange", handleSelectionChange);
  }), [handleSelectionChange]), cursorElement;
}
const POPOVER_FALLBACK_PLACEMENTS$4 = ["bottom", "top"], INLINE_STYLE = { outline: "none" }, EMPTY_ARRAY$e = [], PlaceholderWrapper = styled__default.default.span((props) => {
  const { color: color2 } = theme.getTheme_v2(props.theme);
  return styled.css`
    color: ${color2.input.default.enabled.placeholder};
    overflow: hidden;
    text-overflow: ellipsis;
    text-wrap: nowrap;
    display: block;
  `;
}), StyledPopover$1 = styled__default.default(getJsonStream.Popover)(({ theme: theme2 }) => {
  const { space, radius } = theme2.sanity;
  return styled.css`
    &[data-placement='bottom'] {
      transform: translateY(${space[1]}px);
    }

    &[data-placement='top'] {
      transform: translateY(-${space[1]}px);
    }

    [data-ui='Popover__wrapper'] {
      border-radius: ${radius[3]}px;
      display: flex;
      flex-direction: column;
      overflow: clip;
      overflow: hidden;
      position: relative;
      width: 300px; // todo: improve
    }
  `;
});
function Editable(props) {
  const { t } = sanity.useTranslation(commentsLocaleNamespace), {
    focusLock,
    onFocus,
    onBlur,
    onKeyDown,
    onSubmit,
    placeholder = t("compose.create-comment-placeholder"),
    renderBlock: renderBlock2
  } = props, [popoverElement, setPopoverElement] = React.useState(null), rootElementRef = React.useRef(null), editableRef = React.useRef(null), mentionsMenuRef = React.useRef(null), selection = portableTextEditor.usePortableTextEditorSelection(), {
    canSubmit,
    closeMentions,
    insertMention,
    mentionOptions,
    mentionsMenuOpen,
    mentionsSearchTerm,
    onBeforeInput,
    value
  } = useCommentInput(), cursorElement = useCursorElement({
    disabled: !mentionsMenuOpen,
    rootElement: rootElementRef.current
  }), renderPlaceholder = React.useCallback(
    () => /* @__PURE__ */ jsxRuntime.jsx(PlaceholderWrapper, { children: placeholder }),
    [placeholder]
  ), handleClickOutside = React.useCallback(() => {
    mentionsMenuOpen && closeMentions();
  }, [closeMentions, mentionsMenuOpen]);
  ui.useClickOutside(handleClickOutside, [popoverElement]);
  const handleKeyDown = React.useCallback(
    (event) => {
      switch (event.key) {
        case "Enter":
          if (event.shiftKey)
            break;
          if (mentionsMenuOpen) {
            event.preventDefault(), event.stopPropagation(), closeMentions();
            break;
          }
          onSubmit && canSubmit && (event.preventDefault(), event.stopPropagation(), onSubmit());
          break;
        case "Escape":
        case "ArrowLeft":
        case "ArrowRight":
          mentionsMenuOpen && (event.preventDefault(), event.stopPropagation(), closeMentions());
          break;
      }
      onKeyDown && onKeyDown(event);
    },
    [canSubmit, closeMentions, mentionsMenuOpen, onKeyDown, onSubmit]
  ), initialSelectionAtEndOfContent = React.useMemo(() => {
    if (selection)
      return;
    const lastBlock = (value || EMPTY_ARRAY$e).slice(-1)[0], lastChild = types.isPortableTextTextBlock(lastBlock) ? lastBlock.children.slice(-1)[0] : void 0;
    if (!lastChild)
      return;
    const point = {
      path: [{ _key: lastBlock._key }, "children", { _key: lastChild._key }],
      offset: types.isPortableTextSpan(lastChild) ? lastChild.text.length : 0
    };
    return {
      focus: point,
      anchor: point
    };
  }, [value, selection]);
  React.useEffect(() => {
    var _a;
    (_a = mentionsMenuRef.current) == null || _a.setSearchTerm(mentionsSearchTerm);
  }, [mentionsSearchTerm]), React.useEffect(() => {
    mentionsMenuOpen && selection && !isEqual__default.default(selection.anchor, selection.focus) && closeMentions();
  }, [mentionsMenuOpen, closeMentions, selection]);
  const popoverContent = /* @__PURE__ */ jsxRuntime.jsx(
    MentionsMenu$1,
    {
      inputElement: editableRef.current,
      loading: mentionOptions.loading,
      onSelect: insertMention,
      options: mentionOptions.data || EMPTY_ARRAY$e,
      ref: mentionsMenuRef
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs("div", { ref: rootElementRef, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      StyledPopover$1,
      {
        arrow: !1,
        constrainSize: !0,
        content: popoverContent,
        disabled: !mentionsMenuOpen,
        fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$4,
        open: mentionsMenuOpen,
        placement: "bottom",
        ref: setPopoverElement,
        referenceElement: cursorElement
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      portableTextEditor.PortableTextEditable,
      {
        "data-testid": "comment-input-editable",
        "data-ui": "EditableElement",
        onBeforeInput,
        onBlur,
        onFocus,
        onKeyDown: handleKeyDown,
        ref: editableRef,
        renderBlock: renderBlock2,
        renderChild,
        renderPlaceholder,
        selection: initialSelectionAtEndOfContent,
        style: INLINE_STYLE,
        tabIndex: focusLock ? 0 : void 0
      }
    )
  ] });
}
const EditableWrap = styled__default.default(ui.Box)`
  max-height: 20vh;
  overflow-y: auto;
`, ButtonDivider = styled__default.default(ui.MenuDivider)({
  height: 20,
  width: 1
});
function focusRingBorderStyle(border) {
  return `inset 0 0 0 ${border.width}px ${border.color}`;
}
const RootCard$1 = styled__default.default(ui.Card)(({ theme: theme$1 }) => {
  const { color: color2, input, radius } = theme.getTheme_v2(theme$1), radii = radius[2];
  return styled.css`
    border-radius: ${radii}px;
    box-shadow: var(--input-box-shadow);

    --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};

    &:not([data-expand-on-focus='false'], :focus-within) {
      background: transparent;
      box-shadow: unset;
    }

    &[data-focused='true']:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }

      /* box-shadow: inset 0 0 0 1px var(--card-focus-ring-color); */
      --input-box-shadow: ${focusRingBorderStyle({
    color: "var(--card-focus-ring-color)",
    width: input.border.width
  })};
    }

    &:focus-within {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='false'] {
      ${EditableWrap} {
        min-height: 1em;
      }
    }

    &[data-expand-on-focus='true'] {
      [data-ui='CommentInputActions']:not([hidden]) {
        display: none;
      }

      &:focus-within {
        [data-ui='CommentInputActions'] {
          display: flex;
        }
      }
    }
    &:hover {
      --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.hovered.border,
    width: input.border.width
  })};
    }
  `;
}), AvatarContainer = styled__default.default.div((props) => {
  var _a;
  return `
    min-height: ${(_a = theme.getTheme_v2(props.theme).avatar.sizes[1]) == null ? void 0 : _a.size}px;
    display: flex;
    align-items: center;
  `;
});
function CommentInputInner(props) {
  const {
    avatarSize = 1,
    currentUser,
    focusLock,
    onBlur,
    onFocus,
    onKeyDown,
    onSubmit,
    placeholder,
    renderBlock: renderBlock2,
    withAvatar
  } = props, [user] = sanity.useUser(currentUser.id), { canSubmit, expandOnFocus, focused, hasChanges, insertAtChar, openMentions, readOnly } = useCommentInput(), { t } = sanity.useTranslation(commentsLocaleNamespace), avatar = withAvatar ? /* @__PURE__ */ jsxRuntime.jsx(AvatarContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user, size: avatarSize }) }) : null, handleMentionButtonClicked = React.useCallback(
    (e) => {
      e.stopPropagation(), insertAtChar(), openMentions();
    },
    [insertAtChar, openMentions]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 2, children: [
    avatar,
    /* @__PURE__ */ jsxRuntime.jsx(
      RootCard$1,
      {
        id: "comment-input-root",
        "data-expand-on-focus": expandOnFocus && !canSubmit ? "true" : "false",
        "data-focused": focused ? "true" : "false",
        flex: 1,
        sizing: "border",
        tone: readOnly ? "transparent" : "default",
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(EditableWrap, { paddingX: 1, paddingY: 2, sizing: "border", "data-ui": "editable-wrap", children: /* @__PURE__ */ jsxRuntime.jsx(
            Editable,
            {
              focusLock,
              onBlur,
              onFocus,
              onKeyDown,
              onSubmit,
              placeholder,
              renderBlock: renderBlock2
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", "data-ui": "CommentInputActions", gap: 1, justify: "flex-end", padding: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(getJsonStream.TooltipDelayGroupProvider, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.Button,
              {
                "aria-label": t("compose.mention-user-aria-label"),
                "data-testid": "comment-input-mention-button",
                disabled: readOnly,
                icon: MentionIcon,
                mode: "bleed",
                type: "button",
                onClick: handleMentionButtonClicked,
                tooltipProps: { content: t("compose.mention-user-tooltip") }
              }
            ),
            onSubmit && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
              /* @__PURE__ */ jsxRuntime.jsx(ButtonDivider, {}),
              /* @__PURE__ */ jsxRuntime.jsx(
                getJsonStream.Button,
                {
                  "aria-label": t("compose.send-comment-aria-label"),
                  "data-testid": "comment-input-send-button",
                  disabled: !canSubmit || !hasChanges || readOnly,
                  icon: SendIcon,
                  mode: hasChanges && canSubmit ? "default" : "bleed",
                  onClick: onSubmit,
                  tone: hasChanges && canSubmit ? "primary" : "default",
                  tooltipProps: { content: t("compose.send-comment-tooltip") }
                }
              )
            ] })
          ] }) })
        ] })
      }
    )
  ] });
}
const EMPTY_ARRAY$d = [], SCROLL_INTO_VIEW_OPTIONS = {
  behavior: "smooth",
  block: "center",
  inline: "center"
}, CommentInput = React.forwardRef(
  function(props, ref) {
    const {
      avatarSize,
      currentUser,
      expandOnFocus,
      focusLock = !1,
      focusOnMount,
      mentionOptions,
      onBlur,
      onChange,
      onDiscardCancel,
      onDiscardConfirm,
      onFocus,
      onKeyDown,
      onMentionMenuOpenChange,
      onSubmit,
      placeholder,
      readOnly,
      renderBlock: renderBlock2 = renderBlock$1,
      value = EMPTY_ARRAY$d,
      withAvatar = !0
    } = props, [focused, setFocused] = React.useState(!1), editorRef = React.useRef(null), editorContainerRef = React.useRef(null), [showDiscardDialog, setShowDiscardDialog] = React.useState(!1), preDivRef = React.useRef(null), postDivRef = React.useRef(null), innerRef = React.useRef(null), [editorInstanceKey, setEditorInstanceKey] = React.useState(portableTextEditor.keyGenerator()), requestFocus = React.useCallback(() => {
      requestAnimationFrame(() => {
        editorRef.current && portableTextEditor.PortableTextEditor.focus(editorRef.current);
      });
    }, []), resetEditorInstance = React.useCallback(() => {
      setEditorInstanceKey(portableTextEditor.keyGenerator());
    }, []), handleChange = React.useCallback(
      (change) => {
        if (change.type === "ready" && focusOnMount && requestFocus(), change.type === "focus" && setFocused(!0), change.type === "blur" && setFocused(!1), change.type === "patch" && editorRef.current) {
          const editorStateValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current);
          onChange(editorStateValue || EMPTY_ARRAY$d);
        }
      },
      [focusOnMount, onChange, requestFocus]
    ), scrollToEditor = React.useCallback(() => {
      var _a;
      (_a = editorContainerRef.current) == null || _a.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS);
    }, []), handleSubmit = React.useCallback(() => {
      onSubmit == null || onSubmit(), resetEditorInstance(), requestFocus(), scrollToEditor();
    }, [onSubmit, requestFocus, resetEditorInstance, scrollToEditor]), handleDiscardConfirm = React.useCallback(() => {
      onDiscardConfirm(), resetEditorInstance();
    }, [onDiscardConfirm, resetEditorInstance]), discardDialogController = React.useMemo(() => ({
      open: () => {
        setShowDiscardDialog(!0);
      },
      close: () => {
        setShowDiscardDialog(!1), requestFocus();
      }
    }), [requestFocus]);
    React.useImperativeHandle(
      ref,
      () => ({
        focus: requestFocus,
        blur() {
          editorRef.current && portableTextEditor.PortableTextEditor.blur(editorRef.current);
        },
        scrollTo: scrollToEditor,
        reset: resetEditorInstance,
        discardDialogController
      }),
      [discardDialogController, requestFocus, resetEditorInstance, scrollToEditor]
    );
    const handleFocus = React.useCallback(
      (event) => {
        if (!focusLock)
          return;
        const target = event.target, innerEl = innerRef.current;
        if (innerEl && target === preDivRef.current) {
          ui.focusLastDescendant(innerEl);
          return;
        }
        innerEl && target === postDivRef.current && ui.focusFirstDescendant(innerEl);
      },
      [focusLock]
    );
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      showDiscardDialog && onDiscardCancel && /* @__PURE__ */ jsxRuntime.jsx(CommentInputDiscardDialog, { onClose: onDiscardCancel, onConfirm: handleDiscardConfirm }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { ref: editorContainerRef, "data-testid": "comment-input", onFocus: handleFocus, children: /* @__PURE__ */ jsxRuntime.jsx(
        portableTextEditor.PortableTextEditor,
        {
          onChange: handleChange,
          readOnly,
          ref: editorRef,
          schemaType: editorSchemaType,
          value: value || EMPTY_ARRAY$d,
          children: /* @__PURE__ */ jsxRuntime.jsxs(
            CommentInputProvider,
            {
              expandOnFocus,
              focused,
              focusOnMount,
              mentionOptions,
              onMentionMenuOpenChange,
              readOnly,
              value,
              children: [
                focusLock && /* @__PURE__ */ jsxRuntime.jsx("div", { ref: preDivRef, tabIndex: 0 }),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { ref: innerRef, children: /* @__PURE__ */ jsxRuntime.jsx(
                  CommentInputInner,
                  {
                    avatarSize,
                    currentUser,
                    focusLock,
                    onBlur,
                    onFocus,
                    onKeyDown,
                    onSubmit: onSubmit && handleSubmit,
                    placeholder,
                    renderBlock: renderBlock2,
                    withAvatar
                  }
                ) }),
                focusLock && /* @__PURE__ */ jsxRuntime.jsx("div", { ref: postDivRef, tabIndex: 0 })
              ]
            }
          )
        },
        editorInstanceKey
      ) })
    ] });
  }
), COMMENTS_HIGHLIGHT_HUE_KEY = "yellow", COMMENT_REACTION_OPTIONS = [
  {
    shortName: ":+1:",
    title: "Thumbs up"
  },
  {
    shortName: ":-1:",
    title: "Thumbs down"
  },
  {
    shortName: ":heart:",
    title: "Heart"
  },
  {
    shortName: ":rocket:",
    title: "Rocket"
  },
  {
    shortName: ":heavy_plus_sign:",
    title: "Heavy plus sign"
  },
  {
    shortName: ":eyes:",
    title: "Eyes"
  }
], COMMENT_REACTION_EMOJIS = {
  ":-1:": "\u{1F44E}",
  ":+1:": "\u{1F44D}",
  ":eyes:": "\u{1F440}",
  ":heart:": "\u2764\uFE0F",
  ":heavy_plus_sign:": "\u2795",
  ":rocket:": "\u{1F680}"
}, HighlightSpan = styled__default.default.span(({ theme: theme2 }) => {
  var _a;
  const isDark = (_a = theme2.sanity.v2) == null ? void 0 : _a.color._dark, addedBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 800 : 100].hex, addedBorder = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 300].hex, addedHoverBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedHoverBorder = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex, addedNestedBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex, addedNesterBorder = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex;
  return styled.css`
    box-sizing: border-box;
    transition:
      background-color 100ms ease,
      border-color 100ms ease;

    // Make sure that child elements appropriately blend with the
    // background of the highlight span
    * {
      mix-blend-mode: ${isDark ? "screen" : "multiply"};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='true'] {
      background-color: ${addedNestedBg};
      border-bottom: 2px solid ${addedNesterBorder};
    }

    &[data-inline-comment-state='added'][data-inline-comment-nested='false'][data-hovered='true'] {
      background-color: ${addedHoverBg};
      border-bottom: 2px solid ${addedHoverBorder};
    }

    &[data-inline-comment-state='authoring'] {
      background-color: ${addedBg};
      border-bottom: 2px solid ${addedBorder};
    }
  `;
}), CommentInlineHighlightSpan = React.forwardRef(function(props, ref) {
  const { children, isAdded, isAuthoring, isHovered, isNested, ...rest } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    HighlightSpan,
    {
      ...rest,
      "data-hovered": isHovered ? "true" : "false",
      "data-inline-comment-nested": isNested ? "true" : "false",
      "data-inline-comment-state": isAdded ? "added" : isAuthoring ? "authoring" : void 0,
      ref,
      children
    }
  );
}), PortableTextWrap = styled__default.default(ui.Stack)(() => styled.css`
    & > [data-ui='Text']:not(:first-child) {
      margin-top: 1em; // todo: improve
    }

    & > [data-ui='Text']:has(> span:empty) {
      display: none;
    }
  `), EMPTY_ARRAY$c = [], components = {
  block: {
    normal: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    h1: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h2: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h3: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h4: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h5: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    h6: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    blockquote: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    code: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children })
  },
  list: {
    bullet: ({ children }) => children,
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children })
  },
  listItem: {
    bullet: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    number: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children }),
    checkmarks: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(NormalBlock, { children })
  },
  marks: {
    // Since we do not offer any formatting options, we can just use the normal block for all of these.
    strong: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    em: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    code: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    underline: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    strikeThrough: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children }),
    link: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children })
  },
  types: {
    mention: (props) => {
      var _a;
      return /* @__PURE__ */ jsxRuntime.jsx(MentionInlineBlock, { userId: (_a = props == null ? void 0 : props.value) == null ? void 0 : _a.userId, selected: !1 });
    }
  }
};
function CommentMessageSerializer(props) {
  const { blocks } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(PortableTextWrap, { children: /* @__PURE__ */ jsxRuntime.jsx(react.PortableText, { value: blocks || EMPTY_ARRAY$c, components }) });
}
const FLEX_GAP = 3, EmojiText = styled__default.default(ui.Text)`
  font-family: 'Twemoji Mozilla', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
    'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji', sans-serif;
`, GRID_COLUMNS = 6;
function CommentReactionsMenu(props) {
  const { options, onSelect } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), [focusableElements, setFocusableElements] = React.useState([]), [rootElement, setRootElement] = React.useState(null), [focusedIndex, setFocusedIndex] = React.useState(0), handleRootKeyDown = React.useCallback(
    (event) => {
      const focusableLen = focusableElements.length;
      event.key === "ArrowRight" && setFocusedIndex((prev) => (prev + 1) % focusableLen), event.key === "ArrowLeft" && setFocusedIndex((prev) => (prev - 1 + focusableLen) % focusableLen);
    },
    [focusableElements.length]
  ), handleOptionClick = React.useCallback(
    (event) => {
      const index = focusableElements.indexOf(event.currentTarget);
      setFocusedIndex(index), onSelect(options[index]);
    },
    [focusableElements, onSelect, options]
  );
  return React.useEffect(() => {
    if (rootElement) {
      const buttons = rootElement.querySelectorAll("button");
      setFocusableElements(Array.from(buttons));
    }
  }, [rootElement]), React.useEffect(() => {
    focusableElements.length > 0 && focusableElements[focusedIndex].focus();
  }, [focusableElements, focusedIndex]), /* @__PURE__ */ jsxRuntime.jsx(
    ui.Grid,
    {
      columns: GRID_COLUMNS,
      gap: 1,
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      role: "menu",
      children: options.map((o) => {
        const emoji = COMMENT_REACTION_EMOJIS[o.shortName];
        return /* @__PURE__ */ jsxRuntime.jsx(
          ui.Button,
          {
            "aria-label": t("reactions.react-with-aria-label", {
              reactionName: o.title || o.shortName
            }),
            mode: "bleed",
            onClick: handleOptionClick,
            padding: 2,
            role: "menuitem",
            tabIndex: -1,
            children: /* @__PURE__ */ jsxRuntime.jsx(EmojiText, { align: "center", size: 2, children: emoji })
          },
          o.shortName
        );
      })
    }
  );
}
const POPOVER_FALLBACK_PLACEMENTS$3 = ["top", "bottom"];
function CommentReactionsMenuButton(props) {
  const { onMenuClose, onMenuOpen, onSelect, options, readOnly, renderMenuButton: renderMenuButton2, mode } = props, [buttonElement, setButtonElement] = React.useState(null), [popoverElement, setPopoverElement] = React.useState(null), [open, setOpen] = React.useState(!1), { t } = sanity.useTranslation(commentsLocaleNamespace), handleClick = React.useCallback(() => {
    const next = !open;
    setOpen(next), next ? onMenuOpen == null || onMenuOpen() : onMenuClose == null || onMenuClose();
  }, [onMenuClose, onMenuOpen, open]), handleClose = React.useCallback(() => {
    open && (setOpen(!1), onMenuClose == null || onMenuClose(), buttonElement == null || buttonElement.focus());
  }, [buttonElement, onMenuClose, open]), handleClickOutside = React.useCallback(handleClose, [handleClose]), handleKeyDown = React.useCallback(
    (event) => {
      const { key, shiftKey } = event;
      (shiftKey && key === "Tab" || key === "Escape" || key === "Tab") && handleClose();
    },
    [handleClose]
  );
  ui.useClickOutside(handleClickOutside, [popoverElement, buttonElement]);
  const handleSelect = React.useCallback(
    (option) => {
      onSelect(option), handleClose();
    },
    [handleClose, onSelect]
  ), button = React.useMemo(() => {
    const btn = renderMenuButton2({
      open,
      tooltipContent: t(mode === "upsell" ? "list-item.context-menu-add-reaction-upsell" : "list-item.context-menu-add-reaction"),
      t
    });
    return React.cloneElement(btn, {
      "aria-expanded": open,
      "aria-haspopup": "true",
      disabled: readOnly || mode === "upsell",
      id: "reactions-menu-button",
      onClick: handleClick,
      ref: setButtonElement
    });
  }, [handleClick, open, readOnly, renderMenuButton2, t, mode]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          "aria-labelledby": "reactions-menu-button",
          onKeyDown: handleKeyDown,
          padding: 1,
          radius: 3,
          tone: "default",
          children: /* @__PURE__ */ jsxRuntime.jsx(CommentReactionsMenu, { onSelect: handleSelect, options })
        }
      ),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$3,
      open,
      placement: "bottom",
      portal: !0,
      ref: setPopoverElement,
      tone: "default",
      children: button
    }
  );
}
const TEXT_SIZE = 1, ContentStack$1 = styled__default.default(ui.Stack)`
  max-width: 180px;
`, TextGroup = styled__default.default.div`
  display: inline-block;
`, InlineText = styled__default.default(ui.Text).attrs({ size: TEXT_SIZE })`
  display: inline-block !important;

  & > span {
    white-space: break-spaces;
  }
`, TextBox = styled__default.default(ui.Box)`
  line-height: 1;
  text-align: center;
`, LEADING_NON_WHITESPACE_RE = /^\S+/;
function UserDisplayName(props) {
  const { currentUserId, isFirst, userId } = props, [user] = sanity.useUser(userId), { t } = sanity.useTranslation(commentsLocaleNamespace);
  return currentUserId === userId ? t("reactions.user-list.you", { context: isFirst ? "leading" : void 0, replace: { name: user == null ? void 0 : user.displayName } }) : (user == null ? void 0 : user.displayName) || t("reactions.user-list.unknown-user-fallback-name");
}
function CommentReactionsUsersTooltip(props) {
  const { children, ...restProps } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(CommentReactionsUsersTooltipContent, { ...restProps }),
      placement: "bottom",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children })
    }
  );
}
function FormattedUserList({ currentUserId, userIds }) {
  const listFormat = sanity.useListFormat({ style: "long", type: "conjunction" });
  if (userIds.length === 0)
    return null;
  const parts = listFormat.formatToParts(userIds), elements = [];
  for (let i = 0; i < parts.length; i++) {
    const item = parts[i];
    if (item.type === "literal") {
      elements.push(/* @__PURE__ */ jsxRuntime.jsx(InlineText, { children: item.value }, `literal-${i}`));
      continue;
    }
    const nextItem = parts[i + 1];
    if (nextItem && nextItem.type === "literal" && LEADING_NON_WHITESPACE_RE.test(nextItem.value)) {
      const [nonWhitespace = ""] = nextItem.value.match(LEADING_NON_WHITESPACE_RE) || [];
      elements.push(
        // Key (value) is user ID, thus unique
        /* @__PURE__ */ jsxRuntime.jsxs(TextGroup, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(InlineText, { weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }),
          /* @__PURE__ */ jsxRuntime.jsx(InlineText, { children: nonWhitespace })
        ] }, item.value)
      ), nextItem.value = nextItem.value.slice(nonWhitespace.length);
      continue;
    }
    elements.push(
      // Key (value) is user ID, thus unique
      /* @__PURE__ */ jsxRuntime.jsx(InlineText, { weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }, item.value)
    );
  }
  return elements;
}
function CommentReactionsUsersTooltipContent(props) {
  const { currentUser, reactionName, userIds } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), UserList = React.useCallback(() => currentUser ? /* @__PURE__ */ jsxRuntime.jsx(FormattedUserList, { currentUserId: currentUser.id, userIds }) : null, [currentUser, userIds]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ContentStack$1, { padding: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "center", paddingBottom: 2, paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(EmojiText, { size: 4, children: COMMENT_REACTION_EMOJIS[reactionName] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(TextBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.Translate,
      {
        t,
        i18nKey: "reactions.users-reacted-with-reaction",
        values: { reactionName },
        components: {
          UserList,
          ReactionName: () => /* @__PURE__ */ jsxRuntime.jsx(InlineText, { muted: !0, children: reactionName }),
          Text: ({ children }) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            /* @__PURE__ */ jsxRuntime.jsx(InlineText, { muted: !0, children }),
            " ",
            /* @__PURE__ */ jsxRuntime.jsx("wbr", {}),
            " "
          ] })
        }
      }
    ) })
  ] });
}
const TransparentCard = styled__default.default(ui.Card)`
  background: none;
`;
function groupReactionsByName(reactions) {
  const grouped = reactions.reduce(
    (acc, reaction) => {
      const { shortName } = reaction;
      return acc[shortName] || (acc[shortName] = []), acc[shortName].push(reaction), acc;
    },
    {}
  );
  return Object.entries(grouped).sort(([nameA], [nameB]) => {
    const indexA = reactions.findIndex((r) => r.shortName === nameA), indexB = reactions.findIndex((r) => r.shortName === nameB);
    return indexA - indexB;
  });
}
const renderMenuButton$1 = ({ open, tooltipContent }) => /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, mode: "ghost", padding: 0, radius: "full", selected: open, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { paddingX: 3, paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { animate: !0, content: tooltipContent, disabled: open, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ReactionIcon, {}) }) }) }) }), CommentReactionsBar = React__namespace.default.memo(function(props) {
  const { currentUser, onSelect, reactions, readOnly, mode } = props, handleSelect = React.useCallback(
    (name) => {
      const option = COMMENT_REACTION_OPTIONS.find((o) => o.shortName === name);
      option && onSelect(option);
    },
    [onSelect]
  ), currentUserReactionNames = React.useMemo(() => reactions.filter((r) => r.userId === (currentUser == null ? void 0 : currentUser.id)).map((r) => r.shortName), [currentUser == null ? void 0 : currentUser.id, reactions]), groupedReactions = React.useMemo(() => groupReactionsByName(reactions).filter(([name]) => COMMENT_REACTION_EMOJIS[name]), [reactions]), sortOrder = React.useRef(Object.keys(Object.fromEntries(groupedReactions))), sortedReactions = React.useMemo(() => {
    const sorted = groupedReactions.sort(([nameA], [nameB]) => {
      const indexA = sortOrder.current.indexOf(nameA), indexB = sortOrder.current.indexOf(nameB);
      return indexA === -1 ? 1 : indexB === -1 ? -1 : indexA - indexB;
    });
    return sortOrder.current = sorted.map(([name]) => name), sorted;
  }, [groupedReactions]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 1, wrap: "wrap", children: /* @__PURE__ */ jsxRuntime.jsxs(getJsonStream.TooltipDelayGroupProvider, { children: [
    sortedReactions.map(([name, reactionsList]) => {
      const hasReacted = currentUserReactionNames.includes(name), userIds = reactionsList.map((r) => r.userId), emoji = COMMENT_REACTION_EMOJIS[name];
      return /* @__PURE__ */ jsxRuntime.jsx(
        CommentReactionsUsersTooltip,
        {
          currentUser,
          reactionName: name,
          userIds,
          children: /* @__PURE__ */ jsxRuntime.jsx(TransparentCard, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              disabled: readOnly || mode === "upsell",
              mode: "ghost",
              onClick: () => handleSelect(name),
              padding: 2,
              radius: "full",
              selected: hasReacted,
              tone: hasReacted ? "primary" : "default",
              children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
                /* @__PURE__ */ jsxRuntime.jsx(EmojiText, { size: 1, children: emoji }),
                /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, weight: hasReacted ? "semibold" : "medium", children: reactionsList == null ? void 0 : reactionsList.length })
              ] })
            }
          ) })
        },
        name
      );
    }),
    /* @__PURE__ */ jsxRuntime.jsx(TransparentCard, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(
      CommentReactionsMenuButton,
      {
        mode,
        onSelect: (o) => handleSelect(o.shortName),
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton: renderMenuButton$1
      }
    ) })
  ] }) });
}), renderMenuButton = ({
  open,
  tooltipContent,
  t
}) => /* @__PURE__ */ jsxRuntime.jsx(
  getJsonStream.Button,
  {
    "aria-label": t("list-item.context-menu-add-reaction-aria-label"),
    icon: ReactionIcon,
    mode: "bleed",
    selected: open,
    tooltipProps: { content: tooltipContent }
  }
), POPOVER_PROPS = {
  placement: "bottom-end"
}, FloatingCard = styled__default.default(ui.Card)`
  &:empty {
    display: none;
  }
`;
function CommentsListItemContextMenu(props) {
  const {
    canDelete,
    canEdit,
    isParent,
    mode,
    onCopyLink,
    onDeleteStart,
    onEditStart,
    onMenuClose,
    onMenuOpen,
    onReactionSelect,
    onStatusChange,
    readOnly,
    status
  } = props, showMenuButton = !!(onCopyLink || onDeleteStart || onEditStart), { t } = sanity.useTranslation(commentsLocaleNamespace), hasContextMenuOptions = !!(canDelete || canEdit || onCopyLink);
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsxs(FloatingCard, { display: "flex", shadow: 2, padding: 1, radius: 2, sizing: "border", children: [
    onReactionSelect && /* @__PURE__ */ jsxRuntime.jsx(
      CommentReactionsMenuButton,
      {
        mode,
        onMenuClose,
        onMenuOpen,
        onSelect: onReactionSelect,
        options: COMMENT_REACTION_OPTIONS,
        readOnly,
        renderMenuButton
      }
    ),
    isParent && onStatusChange && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "aria-label": t(status === "open" ? "list-item.resolved-tooltip-aria-label" : "list-item.re-open-resolved-aria-label"),
        "data-testid": "comments-list-item-status-button",
        disabled: readOnly,
        icon: status === "open" ? icons.CheckmarkCircleIcon : icons.UndoIcon,
        mode: "bleed",
        onClick: onStatusChange,
        tooltipProps: {
          content: t(status === "open" ? "list-item.resolved-tooltip-content" : "list-item.re-open-resolved")
        }
      }
    ),
    hasContextMenuOptions && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        id: "comment-actions-menu",
        button: /* @__PURE__ */ jsxRuntime.jsx(
          sanity.ContextMenuButton,
          {
            "aria-label": t("list-item.open-menu-aria-label"),
            disabled: readOnly,
            hidden: !showMenuButton
          }
        ),
        onOpen: onMenuOpen,
        onClose: onMenuClose,
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              hidden: !canEdit,
              icon: icons.EditIcon,
              onClick: onEditStart,
              text: t("list-item.edit-comment"),
              tooltipProps: mode === "upsell" ? { content: t("list-item.edit-comment-upsell") } : void 0,
              disabled: mode === "upsell"
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              hidden: !canDelete,
              icon: icons.TrashIcon,
              onClick: onDeleteStart,
              text: t("list-item.delete-comment"),
              tone: "critical"
            }
          ),
          onCopyLink && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, { hidden: !canDelete && !canEdit }),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              hidden: !onCopyLink,
              icon: icons.LinkIcon,
              onClick: onCopyLink,
              text: t("list-item.copy-link")
            }
          )
        ] }),
        popover: POPOVER_PROPS
      }
    )
  ] }) }) });
}
function truncate(str, length = 250) {
  return str.length <= length ? str : `${str.slice(0, length)}...`;
}
const InlineBox = styled__default.default(ui.Box).attrs({ marginLeft: 1, marginRight: 2 })`
  &:not([data-hidden]) {
    display: inline;
  }
`, BlockQuoteStack = styled__default.default(ui.Stack)(({ theme: theme2, $hasReferencedValue }) => {
  var _a;
  const isDark = (_a = theme2.sanity.v2) == null ? void 0 : _a.color._dark, hue = $hasReferencedValue ? COMMENTS_HIGHLIGHT_HUE_KEY : "gray", borderColor = isDark ? color.hues[hue][700].hex : color.hues[hue][300].hex;
  return styled.css`
    border-left: 2px solid ${borderColor};
    word-break: break-word;
  `;
});
function CommentsListItemReferencedValue(props) {
  const { hasReferencedValue, value } = props, { t } = reactI18next.useTranslation(commentsLocaleNamespace), tooltipText = t("list-item.missing-referenced-value-tooltip-content"), resolvedValue = React.useMemo(() => {
    if (Array.isArray(value) && (value == null ? void 0 : value.filter(types.isPortableTextTextBlock).length) > 0) {
      const text = value == null ? void 0 : value.map(react.toPlainText).join(" ");
      return truncate(text);
    }
    return null;
  }, [value]);
  return resolvedValue ? /* @__PURE__ */ jsxRuntime.jsx(
    BlockQuoteStack,
    {
      $hasReferencedValue: !!hasReferencedValue,
      "data-testid": "comments-list-item-referenced-value",
      flex: 1,
      forwardedAs: "blockquote",
      padding: 1,
      paddingLeft: 2,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "flex-start", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, muted: !0, children: [
        !hasReferencedValue && /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: tooltipText, children: /* @__PURE__ */ jsxRuntime.jsx(InlineBox, { children: /* @__PURE__ */ jsxRuntime.jsx(icons.LinkRemovedIcon, {}) }) }),
        resolvedValue
      ] }) })
    }
  ) : null;
}
const stopPropagation = (e) => e.stopPropagation(), ContextMenuBox = styled__default.default(ui.Box)``, SKELETON_INLINE_STYLE = { width: "50%" }, EMPTY_ARRAY$b = [], TimeText = styled__default.default(ui.Text)(({ theme: theme2 }) => {
  const isDark = theme2.sanity.color.dark, fg = color.hues.gray[isDark ? 200 : 800].hex;
  return styled.css`
    min-width: max-content;
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
}), HeaderFlex$1 = styled__default.default(ui.Flex)((props) => {
  var _a;
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    min-height: ${(_a = theme$1.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
  `;
}), IntentText = styled__default.default(ui.Text)(({ theme: theme2 }) => {
  const isDark = theme2.sanity.color.dark, fg = color.hues.gray[isDark ? 200 : 800].hex;
  return styled.css`
    --card-fg-color: ${fg};
    color: var(--card-fg-color);
  `;
}), InnerStack = styled__default.default(ui.Stack)`
  transition: opacity 200ms ease;

  &[data-muted='true'] {
    transition: unset;
    opacity: 0.5;
  }
`, ErrorFlex = styled__default.default(ui.Flex)((props) => {
  var _a;
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    min-height: ${(_a = theme$1.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
  `;
}), RetryCardButton = styled__default.default(ui.Card)`
  // Add not on hover
  &:not(:hover) {
    background-color: transparent;
  }
`, RootStack$1 = styled__default.default(ui.Stack)(({ theme: theme2 }) => {
  const { space } = theme2.sanity;
  return styled.css`
    position: relative;

    // Only show the floating layer on hover when hover is supported.
    // Else, the layer is always visible.
    @media (hover: hover) {
      ${ContextMenuBox} {
        opacity: 0;
        position: absolute;
        right: 0;
        top: 0;
        transform: translate(${space[1]}px, -${space[1]}px);
      }

      ${ContextMenuBox} {
        &:focus-within {
          opacity: 1;
        }
      }

      &:hover {
        ${ContextMenuBox} {
          opacity: 1;
        }
      }
    }

    &[data-menu-open='true'] {
      ${ContextMenuBox} {
        opacity: 1;
      }
    }
  `;
}), RELATIVE_TIME_OPTIONS$1 = { useTemporalPhrase: !0 };
function CommentsListItemLayout(props) {
  var _a;
  const {
    avatarSize = 1,
    canDelete,
    canEdit,
    comment,
    currentUser,
    hasError,
    hasReferencedValue,
    intent,
    isParent,
    isRetrying,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onInputKeyDown,
    onReactionSelect,
    onStatusChange,
    readOnly,
    withAvatar = !0
  } = props, { _createdAt, authorId, message, _id, lastEditedAt } = comment, [user] = sanity.useUser(authorId), { t } = sanity.useTranslation(commentsLocaleNamespace), [value, setValue] = React.useState(message), [isEditing, setIsEditing] = React.useState(!1), [rootElement, setRootElement] = React.useState(null), startMessage = React.useRef(message), [menuOpen, setMenuOpen] = React.useState(!1), commentInputRef = React.useRef(null), hasChanges = useCommentHasChanged(value), hasValue = React.useMemo(() => hasCommentMessageValue(value), [value]), reactions = React.useMemo(
    () => {
      var _a2;
      return (((_a2 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a2.filter((r) => (r == null ? void 0 : r._optimisticState) !== "removed")) || EMPTY_ARRAY$b).filter(
        (r) => "userId" in r && "shortName" in r
      );
    },
    [comment == null ? void 0 : comment.reactions]
  ), hasReactions = !!(reactions != null && reactions.length), createdDate = _createdAt ? new Date(_createdAt) : /* @__PURE__ */ new Date(), editedDate = lastEditedAt ? new Date(lastEditedAt) : null, createdTimeAgo = sanity.useRelativeTime(createdDate, RELATIVE_TIME_OPTIONS$1), dateTimeFormat = sanity.useDateTimeFormat({ dateStyle: "full", timeStyle: "medium" }), formattedCreatedAt = dateTimeFormat.format(createdDate), formattedLastEditAt = editedDate ? dateTimeFormat.format(editedDate) : null, displayError = hasError || isRetrying;
  React.useEffect(() => {
    isEditing || (startMessage.current = message, setValue(message));
  }, [isEditing, message]);
  const handleMenuOpen = React.useCallback(() => setMenuOpen(!0), []), handleMenuClose = React.useCallback(() => setMenuOpen(!1), []), handleCopyLink = React.useCallback(() => onCopyLink == null ? void 0 : onCopyLink(_id), [_id, onCopyLink]), handleCreateRetry = React.useCallback(
    (e) => {
      e.stopPropagation(), onCreateRetry == null || onCreateRetry(_id);
    },
    [_id, onCreateRetry]
  ), handleDelete = React.useCallback(() => onDelete(_id), [_id, onDelete]), cancelEdit = React.useCallback(() => {
    setIsEditing(!1), setValue(startMessage.current);
  }, []), startDiscard = React.useCallback(() => {
    var _a2;
    if (!hasValue || !hasChanges) {
      cancelEdit();
      return;
    }
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.open();
  }, [cancelEdit, hasChanges, hasValue]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onInputKeyDown && onInputKeyDown(event));
    },
    [onInputKeyDown, startDiscard]
  ), cancelDiscard = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close();
  }, []), confirmDiscard = React.useCallback(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null || _a2.discardDialogController.close(), cancelEdit();
  }, [cancelEdit]), handleReactionSelect = React.useCallback(
    (reaction) => {
      onReactionSelect == null || onReactionSelect(_id, reaction);
    },
    [_id, onReactionSelect]
  ), handleEditSubmit = React.useCallback(() => {
    onEdit(_id, { message: value }), setIsEditing(!1);
  }, [_id, onEdit, value]), handleOpenStatusChange = React.useCallback(() => {
    onStatusChange == null || onStatusChange(_id, comment.status === "open" ? "resolved" : "open");
  }, [_id, comment.status, onStatusChange]), toggleEdit = React.useCallback(() => {
    setIsEditing((v) => !v);
  }, []), handleCloseMenu = React.useCallback(() => setMenuOpen(!1), []), handleClickOutside = React.useCallback(() => {
    hasChanges || cancelEdit();
  }, [cancelEdit, hasChanges]), handleRootKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && !hasChanges && cancelEdit();
    },
    [cancelEdit, hasChanges]
  );
  sanity.useDidUpdate(isEditing, handleCloseMenu), ui.useClickOutside(handleClickOutside, [rootElement]);
  const name = user != null && user.displayName ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", textOverflow: "ellipsis", title: user.displayName, children: user.displayName }) : /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE });
  return /* @__PURE__ */ jsxRuntime.jsxs(
    RootStack$1,
    {
      "data-menu-open": menuOpen ? "true" : "false",
      "data-testid": "comments-list-item-layout",
      onKeyDown: handleRootKeyDown,
      ref: setRootElement,
      space: 4,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(InnerStack, { space: 1, "data-muted": displayError, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(HeaderFlex$1, { align: "center", gap: FLEX_GAP, flex: 1, $size: avatarSize, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(CommentsAvatar, { user, size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 2, paddingY: intent ? 2 : 0, children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                ui.Flex,
                {
                  align: "center",
                  paddingBottom: (_a = comment.context) != null && _a.intent ? 0 : 1,
                  sizing: "border",
                  flex: 1,
                  children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-end", gap: 2, children: [
                    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: name }),
                    !displayError && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
                      /* @__PURE__ */ jsxRuntime.jsx(TimeText, { muted: !0, size: 0, children: /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: createdDate.toISOString(), title: formattedCreatedAt, children: createdTimeAgo }) }),
                      formattedLastEditAt && editedDate && /* @__PURE__ */ jsxRuntime.jsx(TimeText, { muted: !0, size: 0, title: formattedLastEditAt, children: /* @__PURE__ */ jsxRuntime.jsxs("time", { dateTime: editedDate.toISOString(), title: formattedLastEditAt, children: [
                        "(",
                        t("list-item.layout-edited"),
                        ")"
                      ] }) })
                    ] })
                  ] })
                }
              ),
              intent && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(IntentText, { muted: !0, size: 0, textOverflow: "ellipsis", children: /* @__PURE__ */ jsxRuntime.jsx(
                sanity.Translate,
                {
                  t,
                  i18nKey: "list-item.layout-context",
                  values: { title: intent.title, intent: "edit" },
                  components: {
                    IntentLink: ({ children }) => intent ? /* @__PURE__ */ jsxRuntime.jsx(router$1.IntentLink, { params: intent.params, intent: intent.name, children }) : void 0
                  }
                }
              ) }) })
            ] }),
            !isEditing && !displayError && /* @__PURE__ */ jsxRuntime.jsx(ContextMenuBox, { "data-root-menu": isParent ? "true" : "false", onClick: stopPropagation, children: /* @__PURE__ */ jsxRuntime.jsx(
              CommentsListItemContextMenu,
              {
                canDelete,
                canEdit,
                isParent,
                mode,
                onCopyLink: onCopyLink ? handleCopyLink : void 0,
                onDeleteStart: handleDelete,
                onEditStart: toggleEdit,
                onMenuClose: handleMenuClose,
                onMenuOpen: handleMenuOpen,
                onReactionSelect: handleReactionSelect,
                onStatusChange: onStatusChange ? handleOpenStatusChange : void 0,
                readOnly,
                status: comment.status
              }
            ) })
          ] }),
          isTextSelectionComment(comment) && !!(comment != null && comment.contentSnapshot) && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: FLEX_GAP, marginBottom: 3, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(
              CommentsListItemReferencedValue,
              {
                hasReferencedValue,
                value: comment == null ? void 0 : comment.contentSnapshot
              }
            )
          ] }),
          isEditing && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 2, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              CommentInput,
              {
                currentUser,
                focusOnMount: !0,
                mentionOptions,
                onChange: setValue,
                onDiscardCancel: cancelDiscard,
                onDiscardConfirm: confirmDiscard,
                onKeyDown: handleInputKeyDown,
                onSubmit: handleEditSubmit,
                readOnly,
                ref: commentInputRef,
                value,
                withAvatar: !1
              }
            ) })
          ] }),
          !isEditing && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: FLEX_GAP, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(CommentMessageSerializer, { blocks: message })
          ] }),
          hasReactions && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: FLEX_GAP, marginTop: 2, children: [
            withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { onClick: stopPropagation, children: /* @__PURE__ */ jsxRuntime.jsx(
              CommentReactionsBar,
              {
                currentUser,
                mode,
                onSelect: handleReactionSelect,
                reactions,
                readOnly
              }
            ) })
          ] })
        ] }),
        displayError && /* @__PURE__ */ jsxRuntime.jsxs(ErrorFlex, { gap: FLEX_GAP, $size: avatarSize, children: [
          withAvatar && /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, { $size: avatarSize }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, flex: 1, children: [
            /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
              hasError && t("list-item.layout-failed-sent"),
              isRetrying && t("list-item.layout-posting")
            ] }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { hidden: isRetrying, children: /* @__PURE__ */ jsxRuntime.jsx(
              RetryCardButton,
              {
                __unstable_focusRing: !0,
                display: "flex",
                forwardedAs: "button",
                onClick: handleCreateRetry,
                padding: 1,
                radius: 2,
                tone: "primary",
                children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t("list-item.layout-retry") })
              }
            ) })
          ] })
        ] })
      ]
    }
  );
}
const ThreadCard = styled__default.default(ui.Card).attrs({ padding: 3, radius: 3, sizing: "border" })(
  (props) => {
    const { theme: theme2 } = props, isDark = theme2.sanity.color.dark, activeBg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 900 : 50].hex, defaultBg = color.hues.gray[isDark ? 900 : 50].hex;
    return styled.css`
      background-color: ${defaultBg};

      &[data-active='true'] {
        background-color: ${activeBg};
      }
    `;
  }
), EMPTY_ARRAY$a = [], MAX_COLLAPSED_REPLIES = 5, DEFAULT_AVATAR_CONFIG = {
  avatarSize: 1,
  parentCommentAvatar: !0,
  replyAvatar: !0,
  threadCommentsAvatar: !0
}, StyledThreadCard = styled__default.default(ThreadCard)(() => styled.css`
    position: relative;

    &:has(> [data-ui='GhostButton']:focus:focus-visible) {
      box-shadow:
        inset 0 0 0 1px var(--card-border-color),
        0 0 0 1px var(--card-bg-color),
        0 0 0 2px var(--card-focus-ring-color);
    }

    // The hover styles is managed with the [data-hovered] attribute instead of the :hover pseudo class
    // since we want to show the hover styles when hovering over the menu items in the context menu as well.
    // The context menu is rendered using a portal, so the :hover pseudo class won't work when hovering over
    // the menu items.
    &:not([data-active='true']) {
      @media (hover: hover) {
        &[data-hovered='true'] {
          [data-root-menu='true'] {
            opacity: 1;
          }
        }
      }
    }
  `), ExpandButton = styled__default.default(getJsonStream.Button)(({ theme: theme2 }) => {
  const { medium } = theme2.sanity.fonts.text.weights;
  return styled.css`
    font-weight: ${medium};
  `;
}), GhostButton = styled__default.default.button`
  opacity: 0;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  left: 0;
`, CommentsListItem = React__namespace.default.memo(function(props) {
  var _a, _b, _c, _d, _e;
  const {
    avatarConfig = DEFAULT_AVATAR_CONFIG,
    canReply,
    currentUser,
    hasReferencedValue,
    innerPadding,
    isSelected,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onKeyDown,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    parentComment,
    readOnly,
    replies = EMPTY_ARRAY$a
  } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), [value, setValue] = React.useState(EMPTY_ARRAY$a), [collapsed, setCollapsed] = React.useState(!0), didExpand = React.useRef(!1), replyInputRef = React.useRef(null), { isTopLayer } = ui.useLayer(), hasValue = React.useMemo(() => hasCommentMessageValue(value), [value]), [mouseOver, setMouseOver] = React.useState(!1), handleMouseEnter = React.useCallback(() => setMouseOver(!0), []), handleMouseLeave = React.useCallback(() => setMouseOver(!1), []), handleReplySubmit = React.useCallback(() => {
    var _a2;
    const nextComment = {
      message: value,
      parentCommentId: parentComment._id,
      status: (parentComment == null ? void 0 : parentComment.status) || "open",
      // Since this is a reply to an existing comment, we use the same thread ID as the parent
      threadId: parentComment.threadId,
      // A new comment will not have any reactions
      reactions: EMPTY_ARRAY$a,
      payload: {
        fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || ""
      }
    };
    onReply == null || onReply(nextComment), setValue(EMPTY_ARRAY$a);
  }, [
    onReply,
    parentComment._id,
    parentComment == null ? void 0 : parentComment.status,
    (_a = parentComment.target.path) == null ? void 0 : _a.field,
    parentComment.threadId,
    value
  ]), startDiscard = React.useCallback(() => {
    var _a2;
    if (!hasValue) {
      setValue(EMPTY_ARRAY$a);
      return;
    }
    (_a2 = replyInputRef.current) == null || _a2.discardDialogController.open();
  }, [hasValue]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), cancelDiscard = React.useCallback(() => {
    var _a2;
    (_a2 = replyInputRef.current) == null || _a2.discardDialogController.close();
  }, []), confirmDiscard = React.useCallback(() => {
    var _a2, _b2;
    setValue(EMPTY_ARRAY$a), (_a2 = replyInputRef.current) == null || _a2.discardDialogController.close(), (_b2 = replyInputRef.current) == null || _b2.focus();
  }, []), handleThreadRootClick = React.useCallback(
    (e) => {
      var _a2;
      e.stopPropagation(), isTopLayer && (onPathSelect == null || onPathSelect({
        fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || "",
        origin: "inspector",
        threadId: parentComment.threadId
      }));
    },
    [isTopLayer, onPathSelect, (_b = parentComment.target.path) == null ? void 0 : _b.field, parentComment.threadId]
  ), handleExpand = React.useCallback((e) => {
    e.stopPropagation(), setCollapsed(!1), didExpand.current = !0;
  }, []), splicedReplies = React.useMemo(() => collapsed ? replies == null ? void 0 : replies.slice(-MAX_COLLAPSED_REPLIES) : replies, [replies, collapsed]), showCollapseButton = React.useMemo(() => replies ? replies.length > MAX_COLLAPSED_REPLIES : !1, [replies]), expandButtonText = React.useMemo(() => `${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES} more ${(replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES === 1 ? "comment" : "comments"}`, [replies == null ? void 0 : replies.length]);
  React.useEffect(() => {
    replies.length > MAX_COLLAPSED_REPLIES && !didExpand.current && setCollapsed(!0);
  }, [replies]);
  const renderedReplies = React.useMemo(
    () => splicedReplies.map((reply) => {
      var _a2, _b2;
      return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", ...applyCommentIdAttr(reply._id), children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentsListItemLayout,
        {
          avatarSize: avatarConfig.avatarSize,
          canDelete: reply.authorId === currentUser.id,
          canEdit: reply.authorId === currentUser.id,
          comment: reply,
          currentUser,
          hasError: ((_a2 = reply._state) == null ? void 0 : _a2.type) === "createError",
          isRetrying: ((_b2 = reply._state) == null ? void 0 : _b2.type) === "createRetrying",
          intent: commentIntentIfDiffers(parentComment, reply),
          mentionOptions,
          mode,
          onCopyLink,
          onCreateRetry,
          onDelete,
          onEdit,
          onInputKeyDown: handleInputKeyDown,
          onReactionSelect,
          readOnly,
          withAvatar: avatarConfig.threadCommentsAvatar
        }
      ) }, reply._id);
    }),
    [
      avatarConfig.threadCommentsAvatar,
      avatarConfig.avatarSize,
      currentUser,
      handleInputKeyDown,
      mentionOptions,
      onCopyLink,
      onCreateRetry,
      onDelete,
      onEdit,
      onReactionSelect,
      parentComment,
      readOnly,
      splicedReplies,
      mode
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    StyledThreadCard,
    {
      "data-active": isSelected ? "true" : "false",
      "data-hovered": mouseOver ? "true" : "false",
      "data-testid": "comments-list-item",
      onClick: handleThreadRootClick,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          GhostButton,
          {
            "data-ui": "GhostButton",
            "aria-label": t("list-item.go-to-field-button.aria-label")
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Stack,
          {
            as: "ul",
            padding: innerPadding,
            paddingBottom: canReply ? void 0 : 1,
            space: 4,
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { as: "li", ...applyCommentIdAttr(parentComment._id), children: /* @__PURE__ */ jsxRuntime.jsx(
                CommentsListItemLayout,
                {
                  avatarSize: avatarConfig.avatarSize,
                  canDelete: parentComment.authorId === currentUser.id,
                  canEdit: parentComment.authorId === currentUser.id,
                  comment: parentComment,
                  currentUser,
                  hasError: ((_c = parentComment._state) == null ? void 0 : _c.type) === "createError",
                  hasReferencedValue,
                  intent: (_d = parentComment.context) == null ? void 0 : _d.intent,
                  isParent: !0,
                  isRetrying: ((_e = parentComment._state) == null ? void 0 : _e.type) === "createRetrying",
                  mentionOptions,
                  mode,
                  onCopyLink,
                  onCreateRetry,
                  onDelete,
                  onEdit,
                  onInputKeyDown: onKeyDown,
                  onReactionSelect,
                  onStatusChange,
                  readOnly,
                  withAvatar: avatarConfig.parentCommentAvatar
                }
              ) }),
              showCollapseButton && !didExpand.current && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, paddingY: 1, sizing: "border", children: [
                /* @__PURE__ */ jsxRuntime.jsx(SpacerAvatar, {}),
                /* @__PURE__ */ jsxRuntime.jsx(
                  ExpandButton,
                  {
                    iconRight: icons.ChevronDownIcon,
                    mode: "bleed",
                    onClick: handleExpand,
                    text: expandButtonText
                  }
                )
              ] }),
              renderedReplies,
              canReply && /* @__PURE__ */ jsxRuntime.jsx(
                CommentInput,
                {
                  avatarSize: avatarConfig.avatarSize,
                  currentUser,
                  expandOnFocus: !0,
                  mentionOptions,
                  onChange: setValue,
                  onDiscardCancel: cancelDiscard,
                  onDiscardConfirm: confirmDiscard,
                  onKeyDown: handleInputKeyDown,
                  onSubmit: handleReplySubmit,
                  placeholder: t(mode === "upsell" ? "compose.reply-placeholder-upsell" : "compose.reply-placeholder"),
                  readOnly: readOnly || mode === "upsell",
                  ref: replyInputRef,
                  value,
                  withAvatar: avatarConfig.replyAvatar
                }
              )
            ]
          }
        )
      ]
    }
  );
});
function getEmptyStateMessages(t) {
  return {
    open: {
      title: t("list-status.empty-state-open-title"),
      message: t("list-status.empty-state-open-text")
    },
    resolved: {
      title: t("list-status.empty-state-resolved-title"),
      message: t("list-status.empty-state-resolved-text")
    }
  };
}
function CommentsListStatus(props) {
  const { status, error, loading, hasNoComments } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), emptyStateMessages = getEmptyStateMessages(t);
  return error ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", flex: 1, padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t("list-status.error") }) }) }) : loading ? /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0, title: t("list-status.loading") }) : hasNoComments ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", flex: 1, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, weight: "medium", children: emptyStateMessages[status].title }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, children: emptyStateMessages[status].message })
  ] }) }) }) : null;
}
function CreateNewThreadInput(props) {
  const {
    currentUser,
    fieldTitle,
    mentionOptions,
    mode,
    onBlur,
    onFocus,
    onKeyDown,
    onNewThreadCreate,
    readOnly
  } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), [value, setValue] = React.useState(sanity.EMPTY_ARRAY), commentInputHandle = React.useRef(null), handleSubmit = React.useCallback(() => {
    onNewThreadCreate == null || onNewThreadCreate(value), setValue(sanity.EMPTY_ARRAY);
  }, [onNewThreadCreate, value]), hasValue = React.useMemo(() => hasCommentMessageValue(value), [value]), startDiscard = React.useCallback(() => {
    var _a;
    hasValue && ((_a = commentInputHandle.current) == null || _a.discardDialogController.open());
  }, [hasValue]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || (event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard()), onKeyDown && onKeyDown(event));
    },
    [onKeyDown, startDiscard]
  ), confirmDiscard = React.useCallback(() => {
    var _a, _b;
    setValue(sanity.EMPTY_ARRAY), (_a = commentInputHandle.current) == null || _a.discardDialogController.close(), (_b = commentInputHandle.current) == null || _b.focus();
  }, []), cancelDiscard = React.useCallback(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close();
  }, []), placeholder = mode === "upsell" ? t("compose.add-comment-input-placeholder-upsell") : /* @__PURE__ */ jsxRuntime.jsx(
    sanity.Translate,
    {
      t,
      i18nKey: "compose.add-comment-input-placeholder",
      values: { field: fieldTitle }
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    CommentInput,
    {
      currentUser,
      expandOnFocus: !0,
      mentionOptions,
      onBlur,
      onChange: setValue,
      onDiscardCancel: cancelDiscard,
      onDiscardConfirm: confirmDiscard,
      onKeyDown: handleInputKeyDown,
      onFocus,
      onSubmit: handleSubmit,
      placeholder,
      readOnly: readOnly || mode === "upsell",
      ref: commentInputHandle,
      value
    }
  );
}
const HeaderFlex = styled__default.default(ui.Flex)`
  min-height: 25px;
`, BreadcrumbsButton = styled__default.default(ui.Button)(({ theme: theme2 }) => {
  const fg = theme2.sanity.color.base.fg;
  return styled.css`
    --card-fg-color: ${fg};

    // The width is needed to make the text ellipsis work
    // in the breadcrumbs component
    max-width: 100%;
  `;
});
function CommentThreadLayout(props) {
  const {
    breadcrumbs,
    canCreateNewThread,
    children,
    currentUser,
    fieldPath,
    isSelected,
    mentionOptions,
    mode,
    onNewThreadCreate,
    onPathSelect,
    readOnly
  } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), handleNewThreadCreate = React.useCallback(
    (payload) => {
      const nextComment = {
        message: payload,
        parentCommentId: void 0,
        status: "open",
        // Since this is a new comment, we generate a new thread ID
        threadId: uuid.uuid(),
        // New comments have no reactions
        reactions: [],
        payload: {
          fieldPath
        }
      };
      onNewThreadCreate == null || onNewThreadCreate(nextComment);
    },
    [onNewThreadCreate, fieldPath]
  ), handleBreadcrumbsClick = React.useCallback(
    (e) => {
      e.stopPropagation(), onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      });
    },
    [fieldPath, onPathSelect]
  ), handleNewThreadClick = React.useCallback(
    (e) => {
      e.stopPropagation(), e.detail !== 0 && (onPathSelect == null || onPathSelect({
        fieldPath,
        origin: "inspector",
        threadId: null
      }));
    },
    [fieldPath, onPathSelect]
  ), crumbsTitlePath = React.useMemo(() => (breadcrumbs == null ? void 0 : breadcrumbs.map((p) => p.title)) || [], [breadcrumbs]), lastCrumb = crumbsTitlePath[crumbsTitlePath.length - 1];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(HeaderFlex, { align: "center", gap: 2, paddingRight: 1, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
      BreadcrumbsButton,
      {
        "aria-label": t("list-item.breadcrumb-button-go-to-field-aria-label", {
          field: lastCrumb
        }),
        mode: "bleed",
        onClick: handleBreadcrumbsClick,
        padding: 2,
        space: 2,
        children: /* @__PURE__ */ jsxRuntime.jsx(CommentBreadcrumbs, { maxLength: 3, titlePath: crumbsTitlePath })
      }
    ) }) }) }),
    canCreateNewThread && /* @__PURE__ */ jsxRuntime.jsx(ThreadCard, { onClick: handleNewThreadClick, "data-active": isSelected, children: /* @__PURE__ */ jsxRuntime.jsx(
      CreateNewThreadInput,
      {
        currentUser,
        fieldTitle: lastCrumb,
        mentionOptions,
        mode,
        onNewThreadCreate: handleNewThreadCreate,
        readOnly
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children })
  ] });
}
function groupThreads(comments2) {
  return comments2.reduce((acc, comment) => {
    const field = comment.fieldPath;
    return acc[field] || (acc[field] = []), acc[field].push(comment), acc;
  }, {});
}
const CommentsListInner = React.forwardRef(function(props, ref) {
  const {
    beforeListNode,
    comments: comments2,
    currentUser,
    error,
    loading,
    mentionOptions,
    mode,
    onCopyLink,
    onCreateRetry,
    onDelete,
    onEdit,
    onNewThreadCreate,
    onPathSelect,
    onReactionSelect,
    onReply,
    onStatusChange,
    readOnly,
    selectedPath,
    status
  } = props, [boundaryElement, setBoundaryElement] = React.useState(null), groupedThreads = React.useMemo(() => Object.entries(groupThreads(comments2)), [comments2]), showComments = !loading && !error && groupedThreads.length > 0;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      "data-testid": "comments-list",
      direction: "column",
      flex: 1,
      height: "fill",
      overflow: "hidden",
      ref: setBoundaryElement,
      sizing: "border",
      children: [
        mode !== "upsell" && /* @__PURE__ */ jsxRuntime.jsx(
          CommentsListStatus,
          {
            error,
            hasNoComments: groupedThreads.length === 0,
            loading,
            status
          }
        ),
        (showComments || beforeListNode) && /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Stack,
          {
            as: "ul",
            flex: 1,
            overflow: "auto",
            padding: 3,
            paddingTop: 1,
            paddingBottom: 6,
            sizing: "border",
            space: 1,
            ref,
            children: [
              beforeListNode,
              /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: boundaryElement, children: groupedThreads == null ? void 0 : groupedThreads.map(([fieldPath, group]) => {
                const breadcrumbs = group[0].breadcrumbs, firstThreadId = group[0].threadId, newThreadSelected = (selectedPath == null ? void 0 : selectedPath.fieldPath) === fieldPath && !selectedPath.threadId;
                return /* @__PURE__ */ jsxRuntime.jsx(
                  ui.Stack,
                  {
                    as: "li",
                    paddingTop: 3,
                    ...applyCommentsGroupAttr(firstThreadId),
                    children: /* @__PURE__ */ jsxRuntime.jsx(
                      CommentThreadLayout,
                      {
                        breadcrumbs,
                        canCreateNewThread: status === "open",
                        currentUser,
                        fieldPath,
                        isSelected: newThreadSelected,
                        mentionOptions,
                        mode,
                        onNewThreadCreate,
                        onPathSelect,
                        readOnly,
                        children: group.map((item) => {
                          var _a, _b, _c;
                          const replies = item.replies.slice().reverse(), canReply = status === "open" && ((_a = item.parentComment._state) == null ? void 0 : _a.type) !== "createError" && ((_b = item.parentComment._state) == null ? void 0 : _b.type) !== "createRetrying", threadIsSelected = (selectedPath == null ? void 0 : selectedPath.threadId) === item.parentComment.threadId && (selectedPath == null ? void 0 : selectedPath.fieldPath) === ((_c = item.parentComment.target.path) == null ? void 0 : _c.field);
                          return /* @__PURE__ */ jsxRuntime.jsx(
                            CommentsListItem,
                            {
                              canReply,
                              currentUser,
                              hasReferencedValue: item.hasReferencedValue,
                              isSelected: threadIsSelected,
                              mentionOptions,
                              mode,
                              onCopyLink,
                              onCreateRetry,
                              onDelete,
                              onEdit,
                              onPathSelect,
                              onReactionSelect,
                              onReply,
                              onStatusChange,
                              parentComment: item.parentComment,
                              readOnly,
                              replies
                            },
                            item.parentComment._id
                          );
                        })
                      },
                      fieldPath
                    )
                  },
                  fieldPath
                );
              }) })
            ]
          }
        )
      ]
    }
  );
}), CommentsList = React.memo(CommentsListInner), Root$9 = styled__default.default(ui.Box)`
  max-width: 280px;
`, fadeInKeyFrame = styled.keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`, StyledPopover = styled__default.default(getJsonStream.Popover)`
  opacity: 0;
  // Fade in the popover after 500ms
  animation: ${fadeInKeyFrame} 200ms 500ms forwards;
`;
function CommentsOnboardingPopover(props) {
  const { onDismiss } = props, { t } = sanity.useTranslation(commentsLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(
    StyledPopover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(Root$9, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "medium", size: 1, children: t("onboarding.header") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t("onboarding.body") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "flex-end", marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { text: t("onboarding.dismiss"), tone: "primary", onClick: onDismiss }) })
      ] }) }),
      open: !0,
      portal: !0,
      ...props
    }
  );
}
const StyledButton$1 = styled__default.default(getJsonStream.Button)(({ theme: theme$1 }) => {
  const { space } = theme.getTheme_v2(theme$1);
  return `
      position: absolute;
      top: ${space[3]}px;
      right: ${space[3]}px;
      z-index: 20;
      background: transparent;
      border-radius: 9999px;
      box-shadow: none;
      color: ${color.white.hex};
      --card-fg-color: ${color.white.hex};
      :hover {
        --card-fg-color: ${color.white.hex};
      }
    `;
}), Image$1 = styled__default.default.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 200px;
`;
function CommentsUpsellDialog(props) {
  var _a, _b, _c;
  const { data, onClose, onPrimaryClick, onSecondaryClick } = props;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    getJsonStream.Dialog,
    {
      id: "comments-upsell",
      onClose,
      onClickOutside: onClose,
      __unstable_hideCloseButton: !0,
      bodyHeight: "fill",
      padding: !1,
      footer: {
        cancelButton: (_a = data.secondaryButton) != null && _a.text ? {
          text: data.secondaryButton.text,
          mode: "bleed",
          tone: "default",
          iconRight: icons.LaunchIcon,
          ...data.secondaryButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.secondaryButton.url
          },
          onClick: onSecondaryClick
        } : void 0,
        confirmButton: {
          text: (_b = data.ctaButton) == null ? void 0 : _b.text,
          mode: "default",
          tone: "primary",
          ...data.ctaButton.url && {
            target: "_blank",
            rel: "noopener noreferrer",
            as: "a",
            href: data.ctaButton.url
          },
          onClick: onPrimaryClick
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          StyledButton$1,
          {
            icon: icons.CloseIcon,
            mode: "bleed",
            tone: "default",
            onClick: onClose,
            tabIndex: -1,
            tooltipProps: null
          }
        ),
        data.image && /* @__PURE__ */ jsxRuntime.jsx(Image$1, { src: data.image.asset.url, alt: (_c = data.image.asset.altText) != null ? _c : "" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, marginTop: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, paddingBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.UpsellDescriptionSerializer, { blocks: data.descriptionText }) }) })
      ]
    }
  );
}
const Image = styled__default.default.img`
  object-fit: cover;
  width: 100%;
  height: 100%;
  height: 180px;
`;
function CommentsUpsellPanel(props) {
  var _a;
  const { data, onPrimaryClick, onSecondaryClick } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 6, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { radius: 3, overflow: "hidden", border: !0, children: [
    data.image && /* @__PURE__ */ jsxRuntime.jsx(Image, { src: data.image.asset.url, alt: (_a = data.image.asset.altText) != null ? _a : "" }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { padding: 3, marginTop: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.UpsellDescriptionSerializer, { blocks: data.descriptionText }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, justify: "flex-end", marginTop: 5, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "bleed",
            text: data.secondaryButton.text,
            tone: "primary",
            iconRight: icons.LaunchIcon,
            ...data.secondaryButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.secondaryButton.url
            },
            onClick: onSecondaryClick
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            text: data.ctaButton.text,
            tone: "primary",
            ...data.ctaButton.url && {
              target: "_blank",
              rel: "noopener noreferrer",
              as: "a",
              href: data.ctaButton.url
            },
            onClick: onPrimaryClick
          }
        )
      ] })
    ] })
  ] }) }) });
}
function CommentsDocumentLayout(props) {
  const { documentId, documentType } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(CommentsEnabledProvider, { documentId, documentType, children: /* @__PURE__ */ jsxRuntime.jsx(CommentsDocumentLayoutInner, { ...props }) });
}
function CommentsDocumentLayoutInner(props) {
  const { documentId, documentType } = props, commentsEnabled = useCommentsEnabled(), { openInspector, inspector } = useDocumentPane(), handleOpenCommentsInspector = React.useCallback(() => {
    (inspector == null ? void 0 : inspector.name) !== COMMENTS_INSPECTOR_NAME && openInspector(COMMENTS_INSPECTOR_NAME);
  }, [inspector == null ? void 0 : inspector.name, openInspector]);
  return commentsEnabled.enabled ? /* @__PURE__ */ jsxRuntime.jsx(
    CommentsProvider,
    {
      documentId,
      documentType,
      isCommentsOpen: (inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME,
      onCommentsOpen: handleOpenCommentsInspector,
      sortOrder: "desc",
      type: "field",
      children: /* @__PURE__ */ jsxRuntime.jsx(CommentsSelectedPathProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsAuthoringPathProvider, { children: props.renderDefault(props) }) })
    }
  ) : props.renderDefault(props);
}
const ContentStack = styled__default.default(ui.Stack)`
  width: 320px;
`;
function CommentsFieldButton(props) {
  const {
    count,
    currentUser,
    fieldTitle,
    isCreatingDataset,
    mentionOptions,
    onChange,
    onClick,
    onClose,
    onCommentAdd,
    onDiscard,
    onInputKeyDown,
    open,
    value
  } = props, { t } = sanity.useTranslation(commentsLocaleNamespace), [popoverElement, setPopoverElement] = React.useState(null), [addCommentButtonElement, setAddCommentButtonElement] = React.useState(
    null
  ), commentInputHandle = React.useRef(null), hasComments = count > 0, closePopover = React.useCallback(() => {
    open && (onClose(), addCommentButtonElement == null || addCommentButtonElement.focus());
  }, [addCommentButtonElement, open, onClose]), handleSubmit = React.useCallback(() => {
    onCommentAdd(), closePopover();
  }, [closePopover, onCommentAdd]), hasValue = React.useMemo(() => hasCommentMessageValue(value), [value]), startDiscard = React.useCallback(() => {
    var _a;
    if (!hasValue) {
      closePopover();
      return;
    }
    (_a = commentInputHandle.current) == null || _a.discardDialogController.open();
  }, [closePopover, hasValue]), handleInputKeyDown = React.useCallback(
    (event) => {
      event.isDefaultPrevented() || onInputKeyDown && onInputKeyDown(event);
    },
    [onInputKeyDown]
  ), handleDiscardCancel = React.useCallback(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close();
  }, []), handleDiscardConfirm = React.useCallback(() => {
    var _a;
    (_a = commentInputHandle.current) == null || _a.discardDialogController.close(), closePopover(), onDiscard();
  }, [closePopover, onDiscard]), handlePopoverKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), startDiscard());
    },
    [startDiscard]
  ), handleClickOutside = React.useCallback(() => {
    open && startDiscard();
  }, [open, startDiscard]);
  return ui.useClickOutside(handleClickOutside, [popoverElement]), hasComments ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { portal: !0, placement: "top", content: t("field-button.content", { count }), children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      "aria-label": t("field-button.aria-label-open"),
      mode: "bleed",
      onClick,
      padding: 2,
      space: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(CommentIcon, {}) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: count > 9 ? "9+" : count })
      ] })
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(ContentStack, { padding: 2, space: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentInput,
        {
          currentUser,
          focusLock: !0,
          focusOnMount: !0,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onKeyDown: handleInputKeyDown,
          onSubmit: handleSubmit,
          placeholder: /* @__PURE__ */ jsxRuntime.jsx(
            sanity.Translate,
            {
              t,
              i18nKey: "compose.add-comment-input-placeholder",
              values: { field: fieldTitle }
            }
          ),
          readOnly: isCreatingDataset,
          ref: commentInputHandle,
          value
        }
      ) }),
      fallbackPlacements: ["bottom-end"],
      open,
      placement: "right-start",
      portal: !0,
      ref: setPopoverElement,
      onKeyDown: handlePopoverKeyDown,
      children: /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": t("field-button.aria-label-add"),
          disabled: isCreatingDataset,
          icon: icons.AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setAddCommentButtonElement,
          selected: open,
          tooltipProps: {
            content: t("field-button.title"),
            placement: "top"
          }
        }
      ) })
    }
  );
}
const messageCache = /* @__PURE__ */ new Map(), EMPTY_ARRAY$9 = [], HIGHLIGHT_BLOCK_VARIANTS = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  exit: {
    opacity: 0
  }
};
function CommentsField(props) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(CommentFieldInner, { ...props, mode }) : props.renderDefault(props);
}
const HighlightDiv = styled__default.default(framerMotion.motion.div)(({ theme: theme2 }) => {
  const { radius, space, color: color$1 } = theme2.sanity, bg = color.hues[COMMENTS_HIGHLIGHT_HUE_KEY][color$1.dark ? 900 : 50].hex;
  return styled.css`
    mix-blend-mode: ${color$1.dark ? "screen" : "multiply"};
    border-radius: ${radius[3]}px;
    top: -${space[2]}px;
    left: -${space[2]}px;
    bottom: -${space[2]}px;
    right: -${space[2]}px;
    pointer-events: none;
    position: absolute;
    z-index: 1;
    width: calc(100% + ${space[2] * 2}px);
    height: calc(100% + ${space[2] * 2}px);
    background-color: ${bg};
  `;
}), FieldStack = styled__default.default(ui.Stack)`
  position: relative;
`;
function CommentFieldInner(props) {
  const { mode } = props, currentUser = sanity.useCurrentUser(), { element: boundaryElement } = ui.useBoundaryElement(), rootRef = React.useRef(null), {
    comments: comments2,
    isCommentsOpen,
    isCreatingDataset,
    mentionOptions,
    onCommentsOpen,
    operation,
    setStatus,
    status
  } = useComments(), { upsellData, handleOpenDialog } = useCommentsUpsell(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { authoringPath, setAuthoringPath } = useCommentsAuthoringPath(), { scrollToGroup } = useCommentsScroll({
    boundaryElement
  }), fieldTitle = React.useMemo(() => sanity.getSchemaTypeTitle(props.schemaType), [props.schemaType]), stringPath = React.useMemo(() => PathUtils__namespace.toString(props.path), [props.path]), cachedValue = messageCache.get(stringPath) || null, [value, setValue] = React.useState(cachedValue), isOpen = React.useMemo(() => authoringPath === stringPath, [authoringPath, stringPath]), isSelected = React.useMemo(() => !isCommentsOpen || (selectedPath == null ? void 0 : selectedPath.origin) === "form" || (selectedPath == null ? void 0 : selectedPath.origin) === "url" ? !1 : (selectedPath == null ? void 0 : selectedPath.fieldPath) === stringPath, [isCommentsOpen, selectedPath == null ? void 0 : selectedPath.fieldPath, selectedPath == null ? void 0 : selectedPath.origin, stringPath]), isInlineCommentThread = React.useMemo(() => comments2.data.open.filter((c) => c.threadId === (selectedPath == null ? void 0 : selectedPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)), [comments2.data.open, selectedPath == null ? void 0 : selectedPath.threadId]), count = React.useMemo(() => comments2.data.open.map((c) => c.fieldPath === stringPath ? c.commentsCount : 0).reduce((acc, val) => acc + val, 0) || 0, [comments2.data.open, stringPath]), hasComments = count > 0, resetMessageValue = React.useCallback(() => {
    setValue(null), messageCache.delete(stringPath);
  }, [stringPath]), handleClick = React.useCallback(() => {
    var _a;
    if (hasComments) {
      status === "resolved" && setStatus("open"), setAuthoringPath(null), onCommentsOpen == null || onCommentsOpen();
      const scrollToThreadId = (_a = comments2.data.open.find(
        (c) => c.fieldPath === PathUtils__namespace.toString(props.path)
      )) == null ? void 0 : _a.threadId;
      scrollToThreadId && (setSelectedPath({
        threadId: scrollToThreadId,
        origin: "form",
        fieldPath: PathUtils__namespace.toString(props.path)
      }), scrollToGroup(scrollToThreadId));
      return;
    }
    if (mode === "upsell") {
      upsellData ? handleOpenDialog("field_action") : onCommentsOpen == null || onCommentsOpen();
      return;
    }
    setAuthoringPath(isOpen ? null : stringPath);
  }, [
    comments2.data.open,
    handleOpenDialog,
    hasComments,
    isOpen,
    mode,
    onCommentsOpen,
    props.path,
    scrollToGroup,
    setAuthoringPath,
    setSelectedPath,
    setStatus,
    status,
    stringPath,
    upsellData
  ]), handleCommentAdd = React.useCallback(() => {
    if (value) {
      const newThreadId = uuid.uuid(), nextComment = {
        type: "field",
        fieldPath: PathUtils__namespace.toString(props.path),
        message: value,
        parentCommentId: void 0,
        status: "open",
        threadId: newThreadId,
        // New comments have no reactions
        reactions: EMPTY_ARRAY$9
      };
      operation.create(nextComment), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), resetMessageValue(), setSelectedPath({
        threadId: newThreadId,
        origin: "form",
        fieldPath: PathUtils__namespace.toString(props.path)
      }), scrollToGroup(newThreadId);
    }
  }, [
    onCommentsOpen,
    operation,
    props.path,
    resetMessageValue,
    scrollToGroup,
    setSelectedPath,
    setStatus,
    status,
    value
  ]), handleClose = React.useCallback(() => setAuthoringPath(null), [setAuthoringPath]), handleOnChange = React.useCallback(
    (nextValue) => {
      setValue(nextValue), messageCache.set(stringPath, nextValue);
    },
    [stringPath]
  ), internalComments = React.useMemo(
    () => ({
      button: currentUser && /* @__PURE__ */ jsxRuntime.jsx(
        CommentsFieldButton,
        {
          count: Number(count),
          currentUser,
          fieldTitle,
          isCreatingDataset,
          mentionOptions,
          onChange: handleOnChange,
          onClick: handleClick,
          onClose: handleClose,
          onCommentAdd: handleCommentAdd,
          onDiscard: resetMessageValue,
          open: isOpen,
          value
        }
      ),
      hasComments,
      isAddingComment: isOpen
    }),
    [
      currentUser,
      count,
      fieldTitle,
      isCreatingDataset,
      mentionOptions,
      handleOnChange,
      handleClick,
      handleClose,
      handleCommentAdd,
      resetMessageValue,
      isOpen,
      value,
      hasComments
    ]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(FieldStack, { ...applyCommentsFieldAttr(PathUtils__namespace.toString(props.path)), ref: rootRef, children: [
    props.renderDefault({
      ...props,
      // eslint-disable-next-line camelcase
      __internal_comments: internalComments
    }),
    /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: isSelected && !isInlineCommentThread && /* @__PURE__ */ jsxRuntime.jsx(
      HighlightDiv,
      {
        animate: "animate",
        exit: "exit",
        initial: "initial",
        variants: HIGHLIGHT_BLOCK_VARIANTS
      }
    ) })
  ] });
}
function createDomRectFromElements(elements) {
  if (!elements || !elements.length)
    return null;
  const rects = elements.map((el) => el.getBoundingClientRect()), minX = Math.min(...rects.map((r) => r.x)) || 0, minY = Math.min(...rects.map((r) => r.y)) || 0, maxRight = Math.max(...rects.map((r) => r.right)) || 0, maxBottom = Math.max(...rects.map((r) => r.bottom)) || 0;
  return {
    x: minX,
    y: minY,
    width: maxRight - minX,
    height: maxBottom - minY,
    top: minY,
    right: maxRight,
    bottom: maxBottom,
    left: minX
  };
}
function useRectFromElements(props) {
  const { scrollElement, disabled, selector } = props, [rect, setRect] = React.useState(null), handleSetRect = React.useCallback(() => {
    const elements = document == null ? void 0 : document.querySelectorAll(selector);
    if (!elements)
      return;
    const nextRect = createDomRectFromElements(Array.from(elements));
    setRect(nextRect);
  }, [selector]);
  return React.useEffect(() => {
    if (disabled)
      return;
    const timeout = setTimeout(() => {
      handleSetRect();
    }, 1);
    return () => {
      clearTimeout(timeout);
    };
  }, [handleSetRect, disabled]), React.useEffect(() => {
    if (!(disabled || !scrollElement))
      return scrollElement.addEventListener("wheel", handleSetRect), () => {
        scrollElement.removeEventListener("wheel", handleSetRect);
      };
  }, [handleSetRect, disabled, scrollElement]), rect;
}
function useAuthoringReferenceElement(props) {
  const { scrollElement, disabled, selector } = props, rect = useRectFromElements({
    scrollElement,
    disabled,
    selector
  });
  return React.useMemo(() => rect ? {
    getBoundingClientRect: () => rect
  } : null, [rect]);
}
function getSelectionBoundingRect() {
  const selection = window.getSelection(), range = selection == null ? void 0 : selection.getRangeAt(0);
  return (range == null ? void 0 : range.getBoundingClientRect()) || null;
}
const MotionPopover$1 = styled__default.default(framerMotion.motion(getJsonStream.Popover))`
  user-select: none;
`, POPOVER_FALLBACK_PLACEMENTS$2 = ["bottom", "top"], VARIANTS$4 = {
  hidden: { opacity: 0, y: -4 },
  visible: { opacity: 1, y: 0 }
};
function FloatingButtonPopover(props) {
  const { disabled, onClick, onClickOutside, referenceElement } = props, [popoverElement, setPopoverElement] = React.useState(null), { t } = reactI18next.useTranslation(commentsLocaleNamespace);
  ui.useClickOutside(onClickOutside, [popoverElement]);
  const disabledText = t("inline-add-comment-button.disabled-overlap-title"), enabledText = t("inline-add-comment-button.title");
  return /* @__PURE__ */ jsxRuntime.jsx(
    MotionPopover$1,
    {
      animate: "visible",
      content: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "data-testid": "inline-comment-button",
          disabled,
          icon: disabled ? CommentDisabledIcon : icons.AddCommentIcon,
          mode: "bleed",
          onClick,
          ref: setPopoverElement,
          text: disabled ? disabledText : enabledText
        }
      ),
      contentEditable: !1,
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2,
      initial: "hidden",
      open: !0,
      padding: 1,
      placement: "bottom",
      portal: !0,
      referenceElement,
      variants: VARIANTS$4
    }
  );
}
const POPOVER_FALLBACK_PLACEMENTS$1 = ["bottom", "top"], MotionPopover = framerMotion.motion(getJsonStream.Popover), RootStack = styled__default.default(ui.Stack)`
  width: 250px;
`, VARIANTS$3 = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
};
function InlineCommentInputPopover(props) {
  const {
    currentUser,
    mentionOptions,
    onChange,
    onClickOutside,
    onDiscardConfirm,
    onSubmit,
    referenceElement,
    value
  } = props, commentInputRef = React.useRef(null), [contentElement, setContentElement] = React.useState(null), handleDiscardConfirm = React.useCallback(() => {
    var _a;
    (_a = commentInputRef.current) == null || _a.discardDialogController.close(), onDiscardConfirm();
  }, [onDiscardConfirm]), handleDiscardCancel = React.useCallback(() => {
    var _a;
    (_a = commentInputRef.current) == null || _a.discardDialogController.close();
  }, []), handleClickOutside = React.useCallback(() => {
    var _a;
    if (hasCommentMessageValue(value)) {
      (_a = commentInputRef.current) == null || _a.discardDialogController.open();
      return;
    }
    onClickOutside();
  }, [onClickOutside, value]);
  return ui.useClickOutside(handleClickOutside, [contentElement]), /* @__PURE__ */ jsxRuntime.jsx(
    MotionPopover,
    {
      animate: "visible",
      content: /* @__PURE__ */ jsxRuntime.jsx(RootStack, { padding: 2, ref: setContentElement, children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentInput,
        {
          currentUser,
          focusLock: !0,
          focusOnMount: !0,
          mentionOptions,
          onChange,
          onDiscardCancel: handleDiscardCancel,
          onDiscardConfirm: handleDiscardConfirm,
          onSubmit,
          ref: commentInputRef,
          value
        }
      ) }),
      "data-ui": "InlineCommentInputPopover",
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1,
      initial: "hidden",
      open: !0,
      placement: "bottom",
      portal: !0,
      referenceElement,
      variants: VARIANTS$3
    }
  );
}
const EMPTY_ARRAY$8 = [], AI_ASSIST_TYPE = "sanity.assist.instruction.prompt";
function CommentsPortableTextInput(props) {
  const { enabled, mode } = useCommentsEnabled(), isAiAssist = props.schemaType.name === AI_ASSIST_TYPE;
  return !enabled || isAiAssist ? props.renderDefault(props) : /* @__PURE__ */ jsxRuntime.jsx(CommentsPortableTextInputInner, { ...props, mode });
}
const CommentsPortableTextInputInner = React__namespace.default.memo(function(props) {
  var _a, _b;
  const { mode } = props, currentUser = sanity.useCurrentUser(), portal = ui.usePortal(), { comments: comments2, getComment, mentionOptions, onCommentsOpen, operation, setStatus, status } = useComments(), { setSelectedPath, selectedPath } = useCommentsSelectedPath(), { scrollToComment, scrollToGroup } = useCommentsScroll(), { handleOpenDialog } = useCommentsUpsell(), editorRef = React.useRef(null), mouseDownRef = React.useRef(!1), [nextCommentValue, setNextCommentValue] = React.useState(null), [nextCommentSelection, setNextCommentSelection] = React.useState(null), [currentSelection, setCurrentSelection] = React.useState(null), [currentSelectionRect, setCurrenSelectionRect] = React.useState(null), [currentHoveredCommentId, setCurrentHoveredCommentId] = React.useState(null), [canSubmit, setCanSubmit] = React.useState(!1), [rootElement, setRootElement] = React.useState(null), [isFullScreen, setIsFullScreen] = React.useState(!1), [addedCommentsDecorations, setAddedCommentsDecorations] = React.useState(EMPTY_ARRAY$8), stringFieldPath = React.useMemo(() => PathUtils__namespace.toString(props.path), [props.path]), handleSetCurrentSelectionRect = React.useCallback(() => {
    const rect = getSelectionBoundingRect();
    setCurrenSelectionRect(rect);
  }, []), resetStates = React.useCallback(() => {
    setCurrentSelection(null), setCurrenSelectionRect(null), setNextCommentSelection(null), setNextCommentValue(null), setCanSubmit(!1);
  }, []), handleSelectCurrentSelection = React.useCallback(() => {
    if (mode === "upsell") {
      handleOpenDialog("pte");
      return;
    }
    setNextCommentSelection(currentSelection);
  }, [currentSelection, handleOpenDialog, mode]), handleCommentDiscardConfirm = React.useCallback(() => {
    resetStates();
  }, [resetStates]), textComments = React.useMemo(() => comments2.data.open.filter((comment) => comment.fieldPath === stringFieldPath).filter((c) => isTextSelectionComment(c.parentComment)).map((c) => c.parentComment), [comments2.data.open, stringFieldPath]), getFragment = React.useCallback(() => editorRef.current ? portableTextEditor.PortableTextEditor.getFragment(editorRef.current) : EMPTY_ARRAY$8, []), handleSubmit = React.useCallback(() => {
    if (!nextCommentSelection || !editorRef.current)
      return;
    const fragment = getFragment() || EMPTY_ARRAY$8, editorValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current);
    if (!editorValue)
      return;
    const textSelection = buildTextSelectionFromFragment({
      fragment,
      selection: nextCommentSelection,
      value: editorValue
    }), threadId = uuid.uuid();
    operation.create({
      type: "field",
      contentSnapshot: fragment,
      fieldPath: stringFieldPath,
      message: nextCommentValue,
      parentCommentId: void 0,
      reactions: EMPTY_ARRAY$8,
      selection: textSelection,
      status: "open",
      threadId
    }), onCommentsOpen == null || onCommentsOpen(), status === "resolved" && setStatus("open"), setSelectedPath({
      fieldPath: stringFieldPath,
      threadId,
      origin: "form"
    }), scrollToGroup(threadId), resetStates();
  }, [
    nextCommentSelection,
    getFragment,
    operation,
    stringFieldPath,
    nextCommentValue,
    onCommentsOpen,
    status,
    setSelectedPath,
    scrollToGroup,
    resetStates,
    setStatus
  ]), handleDecoratorClick = React.useCallback(
    (commentId) => {
      var _a2;
      const comment = getComment(commentId);
      comment && (setSelectedPath({
        fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || "",
        threadId: comment.threadId,
        origin: "form"
      }), onCommentsOpen == null || onCommentsOpen(), scrollToComment(comment._id));
    },
    [getComment, onCommentsOpen, scrollToComment, setSelectedPath]
  ), handleSelectionChange = React.useCallback(
    (selection) => {
      const isRangeSelected = (selection == null ? void 0 : selection.anchor.offset) !== (selection == null ? void 0 : selection.focus.offset), fragment = getFragment();
      if (!(fragment != null && fragment.every(sanity.isPortableTextTextBlock)) || !isRangeSelected) {
        setCanSubmit(!1);
        return;
      }
      mouseDownRef.current || handleSetCurrentSelectionRect(), setCurrentSelection(selection), setCanSubmit(!0);
    },
    [getFragment, handleSetCurrentSelectionRect]
  ), debounceSelectionChange = React.useMemo(
    () => debounce__default.default(handleSelectionChange, 200),
    [handleSelectionChange]
  ), handleMouseDown = React.useCallback(() => {
    mouseDownRef.current = !0;
  }, []), handleMouseUp = React.useCallback(() => {
    mouseDownRef.current = !1, handleSetCurrentSelectionRect();
  }, [handleSetCurrentSelectionRect]), handleRangeDecorationMoved = React.useCallback((details) => {
    var _a2;
    const { rangeDecoration, newSelection } = details, commentId = (_a2 = rangeDecoration.payload) == null ? void 0 : _a2.commentId;
    setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a3;
      return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === commentId ? {
        ...rangeDecoration,
        selection: newSelection,
        payload: { ...rangeDecoration.payload, dirty: !0 }
      } : p;
    }));
  }, []), updateCommentRange = React.useCallback(() => {
    const decoratorsToUpdate = addedCommentsDecorations.filter(
      (decorator) => {
        var _a2;
        return (_a2 = decorator.payload) == null ? void 0 : _a2.dirty;
      }
    );
    decoratorsToUpdate.length !== 0 && (decoratorsToUpdate.forEach((decorator) => {
      var _a2, _b2, _c, _d, _e;
      const commentId = (_a2 = decorator.payload) == null ? void 0 : _a2.commentId, comment = getComment(commentId || "");
      if (!comment || !editorRef.current)
        return;
      const editorValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$8, [updatedDecoration] = buildRangeDecorationSelectionsFromComments({
        comments: [comment],
        value: editorValue
      }), nextRange = updatedDecoration != null && updatedDecoration.range ? [updatedDecoration.range] : EMPTY_ARRAY$8, nextValue = updatedDecoration ? [
        ...((_c = (_b2 = comment.target.path) == null ? void 0 : _b2.selection) == null ? void 0 : _c.value.filter((r) => {
          var _a3;
          return r._key !== ((_a3 = nextRange[0]) == null ? void 0 : _a3._key);
        }).concat(nextRange).flat()) || EMPTY_ARRAY$8
      ] : EMPTY_ARRAY$8, nextComment = {
        target: {
          ...comment.target,
          path: {
            ...((_d = comment.target) == null ? void 0 : _d.path) || {},
            field: ((_e = comment.target.path) == null ? void 0 : _e.field) || "",
            selection: {
              type: "text",
              value: nextValue
            }
          }
        }
      };
      operation.update(comment._id, nextComment);
    }), setAddedCommentsDecorations((prev) => prev.map((p) => {
      var _a2, _b2;
      return (_b2 = (_a2 = decoratorsToUpdate.find(
        (d) => {
          var _a3, _b3;
          return ((_a3 = d.payload) == null ? void 0 : _a3.commentId) === ((_b3 = p.payload) == null ? void 0 : _b3.commentId);
        }
      )) == null ? void 0 : _a2.payload) != null && _b2.dirty ? {
        ...p,
        payload: { ...p.payload, dirty: !1 }
      } : p;
    }).filter((p) => p.selection !== null)));
  }, [addedCommentsDecorations, getComment, operation]), handleBuildRangeDecorations = React.useCallback(
    (commentsToDecorate) => {
      if (!editorRef.current)
        return EMPTY_ARRAY$8;
      const editorValue = portableTextEditor.PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$8;
      return buildRangeDecorations({
        comments: commentsToDecorate,
        currentHoveredCommentId,
        onDecorationClick: handleDecoratorClick,
        onDecorationHoverEnd: setCurrentHoveredCommentId,
        onDecorationHoverStart: setCurrentHoveredCommentId,
        onDecorationMoved: handleRangeDecorationMoved,
        selectedThreadId: (selectedPath == null ? void 0 : selectedPath.threadId) || null,
        value: editorValue
      });
    },
    [
      currentHoveredCommentId,
      handleDecoratorClick,
      handleRangeDecorationMoved,
      selectedPath == null ? void 0 : selectedPath.threadId
    ]
  ), onEditorChange = React.useCallback(
    (change) => {
      change.type === "mutation" && updateCommentRange(), change.type === "selection" && debounceSelectionChange(change.selection);
    },
    [debounceSelectionChange, updateCommentRange]
  ), authoringDecoration = React.useMemo(() => nextCommentSelection ? {
    component: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx(CommentInlineHighlightSpan, { isAuthoring: !0, children }),
    selection: nextCommentSelection
  } : null, [nextCommentSelection]), rangeDecorations = React.useMemo(() => [
    // Existing range decorations
    ...(props == null ? void 0 : props.rangeDecorations) || EMPTY_ARRAY$8,
    // The range decoration when adding a comment
    ...authoringDecoration ? [authoringDecoration] : EMPTY_ARRAY$8,
    // The range decorations for existing comments
    ...addedCommentsDecorations
  ], [addedCommentsDecorations, authoringDecoration, props == null ? void 0 : props.rangeDecorations]), currentSelectionIsOverlapping = React.useMemo(() => !currentSelection || addedCommentsDecorations.length === 0 ? !1 : addedCommentsDecorations.some((d) => {
    if (!editorRef.current)
      return !1;
    const testA = portableTextEditor.PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      currentSelection,
      d.selection
    ), testB = portableTextEditor.PortableTextEditor.isSelectionsOverlapping(
      editorRef.current,
      d.selection,
      currentSelection
    );
    return testA || testB;
  }), [addedCommentsDecorations, currentSelection]), scrollElement = isFullScreen ? document.body : ((_a = portal.elements) == null ? void 0 : _a.documentScrollElement) || document.body, boundaryElement = isFullScreen ? ((_b = portal.elements) == null ? void 0 : _b.documentScrollElement) || document.body : rootElement, popoverAuthoringReferenceElement = useAuthoringReferenceElement({
    scrollElement,
    disabled: !nextCommentSelection,
    selector: '[data-inline-comment-state="authoring"]'
  }), selectionReferenceElement = React.useMemo(() => currentSelectionRect ? {
    getBoundingClientRect: () => currentSelectionRect
  } : null, [currentSelectionRect]);
  React.useEffect(() => {
    if (currentSelection)
      return scrollElement == null || scrollElement.addEventListener("wheel", handleSetCurrentSelectionRect), () => {
        scrollElement == null || scrollElement.removeEventListener("wheel", handleSetCurrentSelectionRect);
      };
  }, [currentSelection, scrollElement, handleSetCurrentSelectionRect]), React.useEffect(() => {
    const nextDecorations = handleBuildRangeDecorations(textComments);
    setAddedCommentsDecorations((current) => nextDecorations.map((nextDecoration) => {
      var _a2;
      const prevDecoration = current.find(
        (p) => {
          var _a3, _b2;
          return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === ((_b2 = nextDecoration.payload) == null ? void 0 : _b2.commentId);
        }
      );
      return (_a2 = prevDecoration == null ? void 0 : prevDecoration.payload) != null && _a2.dirty ? {
        ...nextDecoration,
        payload: { ...nextDecoration.payload, dirty: prevDecoration.payload.dirty }
      } : nextDecoration;
    }));
  }, [handleBuildRangeDecorations, textComments]);
  const showFloatingButton = !!(currentSelection && canSubmit && selectionReferenceElement && !mouseDownRef.current), showFloatingInput = !!(nextCommentSelection && popoverAuthoringReferenceElement);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: boundaryElement, children: /* @__PURE__ */ jsxRuntime.jsxs(framerMotion.AnimatePresence, { children: [
      showFloatingInput && currentUser && /* @__PURE__ */ jsxRuntime.jsx(
        InlineCommentInputPopover,
        {
          currentUser,
          mentionOptions,
          onChange: setNextCommentValue,
          onClickOutside: resetStates,
          onDiscardConfirm: handleCommentDiscardConfirm,
          onSubmit: handleSubmit,
          referenceElement: popoverAuthoringReferenceElement,
          value: nextCommentValue
        }
      ),
      showFloatingButton && !showFloatingInput && /* @__PURE__ */ jsxRuntime.jsx(
        FloatingButtonPopover,
        {
          disabled: currentSelectionIsOverlapping,
          onClick: handleSelectCurrentSelection,
          onClickOutside: resetStates,
          referenceElement: selectionReferenceElement
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { ref: setRootElement, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, children: props.renderDefault({
      ...props,
      onEditorChange,
      editorRef,
      rangeDecorations,
      onFullScreenChange: setIsFullScreen
    }) })
  ] });
});
function isPortableTextInputProps(inputProps) {
  return sanity.isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function CommentsInput(props) {
  return isPortableTextInputProps(props) ? /* @__PURE__ */ jsxRuntime.jsx(CommentsPortableTextInput, { ...props }) : props.renderDefault(props);
}
const _DEBUG = !1, EMPTY_PARAMS$1 = {}, LOADING_PANE = Symbol("LOADING_PANE"), DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement", DocumentPaneContext = React.createContext(null);
function useDocumentPane() {
  const documentPane = React.useContext(DocumentPaneContext);
  if (!documentPane)
    throw new Error("DocumentPane: missing context value");
  return documentPane;
}
const FEEDBACK_FORM_LINK = "https://snty.link/comments-beta-feedback", Span = styled__default.default.span`
  margin-right: 0.2em;
`, Link = styled__default.default.a`
  white-space: nowrap;
`, FooterCard = styled__default.default(ui.Card)({
  position: "relative",
  zIndex: 1
});
function CommentsInspectorFeedbackFooter() {
  const { t } = sanity.useTranslation(commentsLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(FooterCard, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
    t("feature-feedback.title"),
    " ",
    /* @__PURE__ */ jsxRuntime.jsxs(Link, { href: FEEDBACK_FORM_LINK, target: "_blank", rel: "noreferrer", children: [
      /* @__PURE__ */ jsxRuntime.jsxs(Span, { children: [
        t("feature-feedback.link"),
        " "
      ] }),
      " ",
      /* @__PURE__ */ jsxRuntime.jsx(icons.LaunchIcon, {})
    ] })
  ] }) });
}
const Root$8 = styled__default.default(ui.Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
}), CommentsInspectorHeader = React.forwardRef(function(props, ref) {
  const { t } = sanity.useTranslation(commentsLocaleNamespace), { onClose, onViewChange, view, mode } = props, handleSetOpenView = React.useCallback(() => onViewChange("open"), [onViewChange]), handleSetResolvedView = React.useCallback(() => onViewChange("resolved"), [onViewChange]);
  return /* @__PURE__ */ jsxRuntime.jsx(Root$8, { ref, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, padding: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "medium", children: t("feature-name") }),
      /* @__PURE__ */ jsxRuntime.jsx(sanity.BetaBadge, {})
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: "none", padding: 1, gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.MenuButton,
        {
          id: "comment-status-menu-button",
          button: /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              text: t(view === "open" ? "status-filter.status-open" : "status-filter.status-resolved"),
              mode: "bleed",
              iconRight: icons.ChevronDownIcon
            }
          ),
          menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { style: { width: "180px" }, children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                iconRight: view === "open" ? icons.CheckmarkIcon : void 0,
                onClick: handleSetOpenView,
                text: t("status-filter.status-open-full")
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(
              getJsonStream.MenuItem,
              {
                iconRight: view === "resolved" ? icons.CheckmarkIcon : void 0,
                onClick: handleSetResolvedView,
                text: t("status-filter.status-resolved-full"),
                tooltipProps: mode === "upsell" ? { content: t("status-filter.status-resolved-full-upsell") } : void 0,
                disabled: mode === "upsell"
              }
            )
          ] }),
          popover: { placement: "bottom-end" }
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": t("close-pane-button-text-aria-label"),
          icon: icons.CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("close-pane-button-text") }
        }
      )
    ] })
  ] }) });
}), RootLayer = styled__default.default(ui.Layer)`
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
`;
function CommentsInspector(props) {
  const { enabled, mode } = useCommentsEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(RootLayer, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsInspectorInner, { ...props, mode }) }) : null;
}
function CommentsInspectorInner(props) {
  const { t } = sanity.useTranslation(commentsLocaleNamespace), { onClose, mode } = props, [showDeleteDialog, setShowDeleteDialog] = React.useState(!1), [commentToDelete, setCommentToDelete] = React.useState(null), [deleteLoading, setDeleteLoading] = React.useState(!1), [deleteError, setDeleteError] = React.useState(null), rootRef = React.useRef(null), currentUser = sanity.useCurrentUser(), { params, createPathWithParams, setParams } = usePaneRouter(), uniqueParams = sanity.useUnique(params) || EMPTY_PARAMS$1, commentIdParamRef = React.useRef(uniqueParams == null ? void 0 : uniqueParams.comment), didScrollToCommentFromParam = React.useRef(!1), pushToast = ui.useToast().push, { isTopLayer } = ui.useLayer(), { onPathOpen, connectionState } = useDocumentPane(), { scrollToComment, scrollToField, scrollToInlineComment } = useCommentsScroll(), { selectedPath, setSelectedPath } = useCommentsSelectedPath(), { isDismissed, setDismissed } = useCommentsOnboarding(), { comments: comments2, getComment, isCreatingDataset, mentionOptions, setStatus, status, operation } = useComments(), { upsellData, telemetryLogs } = useCommentsUpsell(), currentComments = React.useMemo(() => comments2.data[status], [comments2, status]), loading = React.useMemo(() => comments2.loading || connectionState === "connecting", [comments2.loading, connectionState]);
  React.useEffect(() => (mode === "upsell" && ((selectedPath == null ? void 0 : selectedPath.origin) === "form" ? telemetryLogs.panelViewed("field_action") : commentIdParamRef.current ? telemetryLogs.panelViewed("link") : telemetryLogs.panelViewed("document_action")), () => {
    mode === "upsell" && telemetryLogs.panelDismissed();
  }), []);
  const handleChangeView = React.useCallback(
    (nextView) => {
      setStatus(nextView), setSelectedPath(null);
    },
    [setSelectedPath, setStatus]
  ), handleCloseInspector = React.useCallback(() => {
    onClose(), setSelectedPath(null);
  }, [onClose, setSelectedPath]), handleCopyLink = React.useCallback(
    (id) => {
      const path = createPathWithParams({
        ...params,
        comment: id
      }), url = `${window.location.origin}${path}`;
      navigator.clipboard.writeText(url).then(() => {
        pushToast({
          closable: !0,
          status: "info",
          title: t("copy-link-success-message")
        });
      }).catch(() => {
        pushToast({
          closable: !0,
          status: "error",
          title: t("copy-link-error-message")
        });
      });
    },
    [createPathWithParams, params, pushToast, t]
  ), handleCreateRetry = React.useCallback(
    (id) => {
      var _a;
      const comment = getComment(id);
      comment && operation.create({
        type: "field",
        fieldPath: ((_a = comment.target.path) == null ? void 0 : _a.field) || "",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || [],
        status: comment.status,
        threadId: comment.threadId
      });
    },
    [getComment, operation]
  ), closeDeleteDialog = React.useCallback(() => {
    deleteLoading || (setShowDeleteDialog(!1), setCommentToDelete(null));
  }, [deleteLoading]), handlePathSelect = React.useCallback(
    (nextPath) => {
      if (setSelectedPath(nextPath), nextPath != null && nextPath.fieldPath) {
        const path = PathUtils__namespace.fromString(nextPath.fieldPath);
        onPathOpen(path), scrollToField(nextPath.fieldPath), comments2.data.open.filter((c) => c.threadId === (nextPath == null ? void 0 : nextPath.threadId)).some((x) => isTextSelectionComment(x.parentComment)) && nextPath.threadId && scrollToInlineComment(nextPath.threadId);
      }
    },
    [comments2.data.open, onPathOpen, scrollToField, scrollToInlineComment, setSelectedPath]
  ), handleNewThreadCreate = React.useCallback(
    (nextComment) => {
      var _a;
      const fieldPath = ((_a = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a.fieldPath) || "";
      operation.create({
        type: "field",
        fieldPath,
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: nextComment.reactions,
        status: nextComment.status,
        threadId: nextComment.threadId
      }), setSelectedPath({
        fieldPath,
        origin: "inspector",
        threadId: nextComment.threadId
      });
    },
    [operation, setSelectedPath]
  ), handleReply = React.useCallback(
    (nextComment) => {
      var _a;
      operation.create({
        ...nextComment,
        type: "field",
        fieldPath: ((_a = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a.fieldPath) || ""
      });
    },
    [operation]
  ), handleEdit = React.useCallback(
    (id, nextComment) => {
      operation.update(id, nextComment);
    },
    [operation]
  ), onDeleteStart = React.useCallback(
    (id) => {
      var _a;
      const parent = currentComments.find((c) => {
        var _a2;
        return ((_a2 = c.parentComment) == null ? void 0 : _a2._id) === id;
      }), isParent = !!(parent && ((_a = parent == null ? void 0 : parent.replies) == null ? void 0 : _a.length) > 0);
      setShowDeleteDialog(!0), setCommentToDelete({
        commentId: id,
        isParent
      });
    },
    [currentComments]
  ), handleDeleteConfirm = React.useCallback(
    async (id) => {
      try {
        setDeleteLoading(!0), await operation.remove(id), closeDeleteDialog();
      } catch (err) {
        setDeleteError(err);
      } finally {
        setDeleteLoading(!1);
      }
    },
    [closeDeleteDialog, operation]
  ), handleStatusChange = React.useCallback(
    (id, nextStatus) => {
      var _a;
      if (operation.update(id, {
        status: nextStatus
      }), nextStatus === "open") {
        setStatus("open");
        const comment = getComment(id);
        if (!comment)
          return;
        setSelectedPath({
          fieldPath: ((_a = comment.target.path) == null ? void 0 : _a.field) || null,
          origin: "inspector",
          threadId: comment.threadId || null
        }), scrollToComment(id);
      }
    },
    [getComment, operation, scrollToComment, setSelectedPath, setStatus]
  ), handleReactionSelect = React.useCallback(
    (id, reaction) => {
      operation.react(id, reaction);
    },
    [operation]
  ), handleDeselectPath = React.useCallback(() => {
    selectedPath && isTopLayer && setSelectedPath(null);
  }, [isTopLayer, selectedPath, setSelectedPath]), handleClickOutside = React.useCallback(
    (e) => {
      var _a;
      e.target instanceof HTMLElement && ((_a = e.target) != null && _a.hasAttribute("data-slate-string")) || handleDeselectPath();
    },
    [handleDeselectPath]
  );
  ui.useClickOutside(handleClickOutside, [rootRef.current]), React.useEffect(() => {
    var _a;
    const commentToScrollTo = getComment(commentIdParamRef.current || "");
    !loading && commentToScrollTo && didScrollToCommentFromParam.current === !1 && (setStatus(commentToScrollTo.status || "open"), setSelectedPath({
      fieldPath: ((_a = commentToScrollTo.target.path) == null ? void 0 : _a.field) || null,
      origin: "url",
      threadId: commentToScrollTo.threadId || null
    }), scrollToComment(commentToScrollTo._id), didScrollToCommentFromParam.current = !0, commentIdParamRef.current = void 0, setParams({
      ...params,
      comment: void 0
    }));
  }, [getComment, loading, params, scrollToComment, setParams, setSelectedPath, setStatus]);
  const beforeListNode = React.useMemo(() => mode === "upsell" && upsellData ? /* @__PURE__ */ jsxRuntime.jsx(
    CommentsUpsellPanel,
    {
      data: upsellData,
      onPrimaryClick: telemetryLogs.panelPrimaryClicked,
      onSecondaryClick: telemetryLogs.panelSecondaryClicked
    }
  ) : null, [mode, telemetryLogs.panelPrimaryClicked, telemetryLogs.panelSecondaryClicked, upsellData]);
  return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
    commentToDelete && showDeleteDialog && /* @__PURE__ */ jsxRuntime.jsx(
      CommentDeleteDialog,
      {
        ...commentToDelete,
        error: deleteError,
        loading: deleteLoading,
        onClose: closeDeleteDialog,
        onConfirm: handleDeleteConfirm
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Flex,
      {
        direction: "column",
        flex: 1,
        height: "fill",
        onClick: handleDeselectPath,
        overflow: "hidden",
        ref: rootRef,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            CommentsOnboardingPopover,
            {
              onDismiss: setDismissed,
              open: !isDismissed,
              placement: "left-start",
              children: /* @__PURE__ */ jsxRuntime.jsx(
                CommentsInspectorHeader,
                {
                  onClose: handleCloseInspector,
                  onViewChange: handleChangeView,
                  view: status,
                  mode
                }
              )
            }
          ),
          currentUser && /* @__PURE__ */ jsxRuntime.jsx(
            CommentsList,
            {
              beforeListNode,
              comments: currentComments,
              currentUser,
              error: comments2.error,
              loading,
              mentionOptions,
              mode,
              onCopyLink: handleCopyLink,
              onCreateRetry: handleCreateRetry,
              onDelete: onDeleteStart,
              onEdit: handleEdit,
              onNewThreadCreate: handleNewThreadCreate,
              onPathSelect: handlePathSelect,
              onReactionSelect: handleReactionSelect,
              onReply: handleReply,
              onStatusChange: handleStatusChange,
              readOnly: isCreatingDataset,
              selectedPath,
              status
            }
          ),
          mode === "default" && /* @__PURE__ */ jsxRuntime.jsx(CommentsInspectorFeedbackFooter, {})
        ]
      }
    )
  ] });
}
function useMenuItem$1() {
  const { t } = sanity.useTranslation(commentsLocaleNamespace), { enabled } = useCommentsEnabled();
  return {
    hidden: !enabled,
    icon: icons.CommentIcon,
    showAsAction: !0,
    title: t("feature-name")
  };
}
const commentsInspector = sanity.defineDocumentInspector({
  name: COMMENTS_INSPECTOR_NAME,
  component: CommentsInspector,
  useMenuItem: useMenuItem$1
});
function CommentsStudioLayout(props) {
  const { enabled, isLoading } = sanity.useFeatureEnabled("studioComments");
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.AddonDatasetProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(CommentsOnboardingProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.ConditionalWrapper,
    {
      condition: !enabled && !isLoading,
      wrapper: (children) => /* @__PURE__ */ jsxRuntime.jsx(CommentsUpsellProvider, { children }),
      children: props.renderDefault(props)
    }
  ) }) });
}
const comments = sanity.definePlugin({
  name: "sanity/structure/comments",
  document: {
    inspectors: [commentsInspector],
    components: {
      unstable_layout: CommentsDocumentLayout
    }
  },
  form: {
    components: {
      field: CommentsField,
      input: CommentsInput
    }
  },
  studio: {
    components: {
      layout: CommentsStudioLayout
    }
  },
  i18n: { bundles: [commentsUsEnglishLocaleBundle] }
});
function ErrorPane(props) {
  const {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return /* @__PURE__ */ jsxRuntime.jsxs(
    Pane,
    {
      currentMinWidth,
      flex,
      id: paneKey,
      minWidth,
      tone,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(PaneHeader, { title }),
        /* @__PURE__ */ jsxRuntime.jsx(PaneContent, { overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 4, paddingY: 5, children }) })
      ]
    }
  );
}
function getWaitMessages(path) {
  const thresholds = [
    { ms: 300, messageKey: "panes.resolving.default-message" },
    { ms: 5e3, messageKey: "panes.resolving.slow-resolve-message" }
  ];
  if (sanity.isDev) {
    const message = [
      "Check console for errors?",
      "Is your observable/promise resolving?",
      path.length > 0 ? `Structure path: ${path.join(" \u279D ")}` : ""
    ];
    thresholds.push({
      ms: 1e4,
      message: message.join(`
`)
    });
  }
  const src = rxjs.of(null);
  return rxjs.merge(
    ...thresholds.map(
      (threshold) => src.pipe(
        operators.mapTo(
          "messageKey" in threshold ? { messageKey: threshold.messageKey } : { message: threshold.message }
        ),
        operators.delay(threshold.ms)
      )
    )
  );
}
const DEFAULT_MESSAGE_KEY = "panes.resolving.default-message", Content$1 = styled__default.default(ui.Flex)`
  opacity: 0;
  transition: opacity 200ms;

  &[data-mounted] {
    opacity: 1;
  }
`, LoadingPane = React.memo((props) => {
  const {
    delay = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props, { t } = sanity.useTranslation(structureLocaleNamespace), resolvedMessage = React.useMemo(() => typeof messageProp == "function" ? messageProp(path ? path.split(";") : []) : messageProp, [messageProp, path]), [currentMessage, setCurrentMessage] = React.useState(() => typeof resolvedMessage == "string" ? resolvedMessage : t(DEFAULT_MESSAGE_KEY));
  React.useEffect(() => {
    if (typeof resolvedMessage != "object" || typeof resolvedMessage.subscribe != "function")
      return;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, [resolvedMessage, t]);
  const [contentElement, setContentElement] = React.useState(null), [mounted, setMounted] = React.useState(!1);
  React.useEffect(() => {
    if (contentElement)
      return ui._raf2(() => setMounted(!0));
  }, [contentElement]);
  const content = /* @__PURE__ */ jsxRuntime.jsx(
    Content$1,
    {
      align: "center",
      "data-mounted": mounted ? "" : void 0,
      direction: "column",
      height: "fill",
      justify: "center",
      ref: setContentElement,
      children: /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0, title: title || currentMessage })
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Pane, { flex, id: paneKey, minWidth, selected, tone, children: /* @__PURE__ */ jsxRuntime.jsx(PaneContent, { children: content }) });
});
LoadingPane.displayName = "LoadingPane";
const StructureToolContext = React.createContext(null);
function useStructureTool() {
  const structureTool2 = React.useContext(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
const InspectorMenuItem = React.memo(function(props) {
  const { documentId, documentType, index, setMenuItem, useMenuItem: useMenuItem2 } = props, node = sanity.useUnique(
    useMenuItem2({
      documentId,
      documentType
    })
  );
  return React.useEffect(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const { documentId, documentType, inspectors: inspectors2, onMenuItems } = props, len = inspectors2.length, lenRef = React.useRef(len), [menuItems, setMenuItems] = React.useState(
    () => Array.from(new Array(len))
  ), menuItemsRef = React.useRef(menuItems);
  React.useEffect(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = menuItemsRef.current[i];
      lenRef.current = len, setMenuItems(() => (menuItemsRef.current = newFieldActions, newFieldActions));
    }
  }, [len]);
  const setMenuItem = React.useCallback((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      return next[index] = node, menuItemsRef.current = next, next;
    });
  }, []);
  return React.useEffect(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: inspectors2.map(
    (inspector, inspectorIndex) => inspector.useMenuItem && /* @__PURE__ */ jsxRuntime.jsx(
      InspectorMenuItem,
      {
        documentId,
        documentType,
        index: inspectorIndex,
        setMenuItem,
        useMenuItem: inspector.useMenuItem
      },
      inspector.name
    )
  ) });
}
function useDocumentTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = sanity.unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  return connectionState === "connecting" ? { error: void 0, title: void 0 } : title ? { error: void 0, title } : documentValue ? error ? { error: `Error: ${error.message}`, title: void 0 } : { error: void 0, title: value == null ? void 0 : value.title } : { error: void 0, title: `New ${(schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)}` };
}
const IGNORE_OPS = ["patch", "commit"], DocumentOperationResults = React.memo(function() {
  const { push: pushToast } = ui.useToast(), { documentId, documentType } = useDocumentPane(), { title } = useDocumentTitle(), event = sanity.useDocumentOperationEvent(documentId, documentType), prevEvent = React.useRef(event), paneRouter = usePaneRouter(), { t } = sanity.useTranslation(structureLocaleNamespace), documentTitleBase = title || t("panes.document-operation-results.operation-undefined-title"), documentTitle = documentTitleBase.length > 25 ? `${documentTitleBase.slice(0, 25)}...` : documentTitleBase;
  return React.useEffect(() => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    return event.type === "error" && pushToast({
      closable: !0,
      duration: 3e4,
      // 30s
      status: "error",
      title: t("panes.document-operation-results.operation-error", { context: event.op }),
      description: /* @__PURE__ */ jsxRuntime.jsxs("details", { children: [
        /* @__PURE__ */ jsxRuntime.jsx("summary", { children: t("panes.document-operation-results.error.summary.title") }),
        event.error.message
      ] })
    }), event.type === "success" && !IGNORE_OPS.includes(event.op) && pushToast({
      closable: !0,
      status: "success",
      title: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          context: event.op,
          i18nKey: "panes.document-operation-results.operation-success",
          t,
          values: {
            title: documentTitle
          },
          components: {
            Strong: "strong"
          }
        }
      )
    }), event.type === "success" && event.op === "delete" && (cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0)), prevEvent.current = event, () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast, t, documentTitle]), null;
}), Root$7 = styled__default.default(ui.Card)({
  position: "relative",
  zIndex: 1,
  lineHeight: 0
});
function DocumentInspectorHeader(props) {
  const { as: forwardedAs, children, closeButtonLabel, onClose, title, ...restProps } = props, { t } = sanity.useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$7, { ...restProps, as: forwardedAs, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "medium", children: title }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          "aria-label": closeButtonLabel,
          icon: icons.CloseIcon,
          mode: "bleed",
          onClick: onClose,
          tooltipProps: { content: t("document-inspector.close-button.tooltip") }
        }
      ) })
    ] }),
    children
  ] });
}
const Root$6 = styled__default.default.div`
  position: absolute;
  top: 0;
  left: -4px;
  bottom: 0;
  width: 9px;
  z-index: 201;
  cursor: ew-resize;

  /* Border */
  & > span:nth-child(1) {
    display: block;
    border-left: 1px solid var(--card-border-color);
    position: absolute;
    top: 0;
    left: 4px;
    bottom: 0;
    transition: opacity 200ms;
  }

  /* Hover effect */
  & > span:nth-child(2) {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 9px;
    bottom: 0;
    background-color: var(--card-border-color);
    opacity: 0;
    transition: opacity 150ms;
  }

  @media (hover: hover) {
    &:hover > span:nth-child(2) {
      opacity: 0.2;
    }
  }
`;
function Resizer(props) {
  const { onResize, onResizeStart } = props, mouseXRef = React.useRef(0), handleMouseDown = React.useCallback(
    (event) => {
      event.preventDefault(), mouseXRef.current = event.pageX, onResizeStart();
      const handleMouseMove = (e) => {
        e.preventDefault(), onResize(e.pageX - mouseXRef.current);
      }, handleMouseUp = () => {
        window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp);
      };
      window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
    },
    [onResize, onResizeStart]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$6, { onMouseDown: handleMouseDown, children: [
    /* @__PURE__ */ jsxRuntime.jsx("span", {}),
    /* @__PURE__ */ jsxRuntime.jsx("span", {})
  ] });
}
const Root$5 = styled__default.default(ui.Box)`
  position: relative;
  flex: 1;
  padding-left: 1px;
`;
function Resizable(props) {
  const { as: forwardedAs, children, minWidth, maxWidth, ...restProps } = props, [element, setElement] = React.useState(null), elementWidthRef = React.useRef(), [targetWidth, setTargetWidth] = React.useState(), handleResizeStart = React.useCallback(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]), handleResize = React.useCallback(
    (deltaX) => {
      const w = elementWidthRef.current;
      w && setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
    },
    [minWidth, maxWidth]
  ), style = React.useMemo(
    () => targetWidth ? { flex: "none", width: targetWidth } : { minWidth, maxWidth },
    [minWidth, maxWidth, targetWidth]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Root$5, { as: forwardedAs, ...restProps, ref: setElement, style, children: [
    children,
    /* @__PURE__ */ jsxRuntime.jsx(Resizer, { onResize: handleResize, onResizeStart: handleResizeStart })
  ] });
}
function DocumentInspectorPanel(props) {
  const { documentId, documentType, flex } = props, { collapsed } = usePane(), { closeInspector, inspector } = useDocumentPane(), { features } = useStructureTool(), handleClose = React.useCallback(() => {
    inspector && closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector)
    return null;
  const element = React.createElement(inspector.component, {
    onClose: handleClose,
    documentId,
    documentType
  });
  return features.resizablePanes ? /* @__PURE__ */ jsxRuntime.jsx(
    Resizable,
    {
      as: "aside",
      "data-ui": "DocumentInspectorPanel",
      flex,
      maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH,
      minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH,
      children: element
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element });
}
const STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const keyValueStore = sanity.useKeyValueStore(), [value, setValue] = React.useState(defaultValue), keyValueStoreKey = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean).join("."), settings = React.useMemo(() => keyValueStore.getKey(keyValueStoreKey), [keyValueStore, keyValueStoreKey]);
  React.useEffect(() => {
    const sub = settings.pipe(
      operators.startWith(defaultValue),
      operators.map((fetchedValue) => fetchedValue === null ? defaultValue : fetchedValue)
    ).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, keyValueStoreKey, settings]);
  const set = React.useCallback(
    (newValue) => {
      newValue !== value && (setValue(newValue), keyValueStore.setKey(keyValueStoreKey, newValue));
    },
    [keyValueStore, keyValueStoreKey, value]
  );
  return React.useMemo(() => [value, set], [set, value]);
}
const VIEW_MODE_PARSED = { id: "parsed", title: "document-inspector.view-mode.parsed" }, VIEW_MODE_RAW = { id: "raw", title: "document-inspector.view-mode.raw-json" }, VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW], lru = HLRU__default.default(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  return cached === void 0 ? (lru.set(keyPath, Array.isArray(value) || sanity.isRecord(value)), isExpanded(keyPath, value)) : cached;
}
function toggleExpanded(event) {
  const { path } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges(), range.selectNodeContents(element), sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  event.keyCode === 65 && (event.metaKey || event.ctrlKey) && (event.preventDefault(), selectElement(event.currentTarget));
}
function isDocumentLike(value) {
  return sanity.isRecord(value) && sanity.isString(value._id) && sanity.isString(value._type);
}
const JSONInspectorWrapper = styled__default.default.div(({ theme: theme2 }) => {
  const { color: color2, fonts, space } = theme2.sanity;
  return styled.css`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${ui.rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${ui.rem(space[3])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: ' ';
      margin-left: calc(0 - ${ui.rem(space[4])} + 3px);
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: ' ';
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${ui.rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color2.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color2.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${ui.rem(space[3])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color2.syntax.string};
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color2.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color2.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
});
function Search(props) {
  const { onChange, query } = props, handleChange = React.useCallback(
    (event) => onChange(event.target.value),
    [onChange]
  ), { t } = sanity.useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      icon: icons.SearchIcon,
      onChange: handleChange,
      placeholder: t("document-inspector.search.placeholder"),
      radius: 2,
      value: query || ""
    }
  );
}
function InspectDialog(props) {
  const { value } = props, { onInspectClose, paneKey } = useDocumentPane(), dialogIdPrefix = `${paneKey}_inspect_`, [viewModeId, onViewModeChange] = useStructureToolSetting(
    "inspect-view-mode",
    null,
    "parsed"
  ), viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId), setParsedViewMode = React.useCallback(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]), setRawViewMode = React.useCallback(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]), { t } = sanity.useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      bodyHeight: "fill",
      id: `${dialogIdPrefix}dialog`,
      header: isDocumentLike(value) ? /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          t,
          i18nKey: "document-inspector.dialog.title",
          components: {
            DocumentTitle: () => /* @__PURE__ */ jsxRuntime.jsx("em", { children: /* @__PURE__ */ jsxRuntime.jsx(DocTitle, { document: value }) })
          }
        }
      ) : /* @__PURE__ */ jsxRuntime.jsx("em", { children: t("document-inspector.dialog.title-no-value") }),
      onClose: onInspectClose,
      onClickOutside: onInspectClose,
      padding: !1,
      width: 2,
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Card,
          {
            padding: 3,
            paddingTop: 0,
            shadow: 1,
            style: { position: "sticky", bottom: 0, zIndex: 3 },
            children: /* @__PURE__ */ jsxRuntime.jsxs(ui.TabList, { space: 1, children: [
              /* @__PURE__ */ jsxRuntime.jsx(
                getJsonStream.Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_PARSED.id}`,
                  label: t(VIEW_MODE_PARSED.title),
                  onClick: setParsedViewMode,
                  selected: viewMode === VIEW_MODE_PARSED
                }
              ),
              /* @__PURE__ */ jsxRuntime.jsx(
                getJsonStream.Tab,
                {
                  "aria-controls": `${dialogIdPrefix}tabpanel`,
                  id: `${dialogIdPrefix}tab-${VIEW_MODE_RAW.id}`,
                  label: t(VIEW_MODE_RAW.title),
                  onClick: setRawViewMode,
                  selected: viewMode === VIEW_MODE_RAW
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.TabPanel,
          {
            "aria-labelledby": `${dialogIdPrefix}tab-${viewModeId}`,
            flex: 1,
            id: `${dialogIdPrefix}tabpanel`,
            overflow: "auto",
            padding: 4,
            style: { outline: "none" },
            children: [
              viewMode === VIEW_MODE_PARSED && /* @__PURE__ */ jsxRuntime.jsx(JSONInspectorWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(
                JSONInspector__default.default,
                {
                  data: value,
                  isExpanded,
                  onClick: toggleExpanded,
                  search: Search
                }
              ) }),
              viewMode === VIEW_MODE_RAW && /* @__PURE__ */ jsxRuntime.jsx(
                ui.Code,
                {
                  language: "json",
                  tabIndex: 0,
                  onKeyDown: maybeSelectAll,
                  onDoubleClick: select,
                  onFocus: select,
                  size: 1,
                  children: JSON.stringify(value, null, 2)
                }
              )
            ]
          }
        )
      ] })
    }
  );
}
function SpacerButton({ size }) {
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      "aria-hidden": !0,
      disabled: !0,
      size,
      style: {
        pointerEvents: "none",
        visibility: "hidden",
        width: 0
      },
      text: "-"
    }
  );
}
function Banner(props) {
  const { action, content, icon: Icon, tone = "transparent", ...rest } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: !0, paddingX: 4, paddingY: 2, tone, ...rest, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    Icon && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 0, children: /* @__PURE__ */ jsxRuntime.jsx(Icon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", flex: 1, gap: 2, paddingY: 3, children: content }),
    /* @__PURE__ */ jsxRuntime.jsx(SpacerButton, {}),
    action && /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        as: action == null ? void 0 : action.as,
        mode: "ghost",
        onClick: action == null ? void 0 : action.onClick,
        text: action.text,
        tone: action.tone || "default"
      }
    )
  ] }) });
}
function DeletedDocumentBanner({ revisionId }) {
  const { documentId, documentType } = useDocumentPane(), { restore } = sanity.useDocumentOperation(documentId, documentType), { navigateIntent } = router$1.useRouter(), handleRestore = React.useCallback(() => {
    revisionId && (restore.execute(revisionId), navigateIntent("edit", { id: documentId, type: documentType }));
  }, [documentId, documentType, navigateIntent, restore, revisionId]), { t } = sanity.useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(
    Banner,
    {
      action: revisionId ? {
        onClick: handleRestore,
        text: t("banners.deleted-document-banner.restore-button.text")
      } : void 0,
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t("banners.deleted-document-banner.text") }),
      "data-testid": "deleted-document-banner",
      icon: icons.ReadOnlyIcon
    }
  );
}
function DeprecatedDocumentTypeBanner() {
  const { schemaType } = useDocumentPane(), { t } = sanity.useTranslation(structureLocaleNamespace);
  return sanity.isDeprecatedSchemaType(schemaType) ? /* @__PURE__ */ jsxRuntime.jsx(
    Banner,
    {
      content: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "medium", children: [
        /* @__PURE__ */ jsxRuntime.jsx(sanity.Translate, { t, i18nKey: "banners.deprecated-document-type-banner.text" }),
        " ",
        schemaType.deprecated.reason
      ] }),
      "data-testid": "deprecated-document-type-banner",
      icon: icons.ErrorOutlineIcon
    }
  ) : null;
}
function PermissionCheckBanner({ granted, requiredPermission }) {
  const currentUser = sanity.useCurrentUser(), listFormat = sanity.useListFormat({ style: "short" }), { t } = sanity.useTranslation(structureLocaleNamespace);
  if (granted)
    return null;
  const roleTitles = ((currentUser == null ? void 0 : currentUser.roles) || []).map((role) => role.title), roles = listFormat.formatToParts(roleTitles).map(
    (part) => part.type === "element" ? /* @__PURE__ */ jsxRuntime.jsx("code", { children: part.value }, part.value) : part.value
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Banner,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          t,
          i18nKey: "banners.permission-check-banner.missing-permission",
          components: { Roles: () => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: roles }) },
          values: { count: roles.length, roles: roleTitles },
          context: requiredPermission
        }
      ) }),
      "data-testid": "permission-check-banner",
      icon: icons.ReadOnlyIcon
    }
  );
}
const ReferenceChangedBanner = React.memo(() => {
  var _a, _b, _c, _d, _e, _f, _g;
  const documentPreviewStore = sanity.useDocumentPreviewStore(), { params, groupIndex, routerPanesState, replaceCurrent, BackLink: BackLink2 } = usePaneRouter(), routerReferenceId = (_a = routerPanesState[groupIndex]) == null ? void 0 : _a[0].id, parentGroup = routerPanesState[groupIndex - 1], parentSibling = parentGroup == null ? void 0 : parentGroup[0], parentId = parentSibling == null ? void 0 : parentSibling.id, hasHistoryOpen = !!((_b = parentSibling == null ? void 0 : parentSibling.params) != null && _b.rev), parentRefPath = React.useMemo(() => (params == null ? void 0 : params.parentRefPath) && PathUtils.fromString(params.parentRefPath) || null, [params == null ? void 0 : params.parentRefPath]), { t } = sanity.useTranslation(structureLocaleNamespace), referenceInfo = reactRx.useMemoObservable(
    () => {
      const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
      if (!parentId || !parentRefPathSegment || !parentRefPath)
        return rxjs.of({ loading: !1 });
      const publishedId = sanity.getPublishedId(parentId), path = PathUtils.fromString(parentRefPathSegment), keyedSegmentIndex = path.findIndex(
        (p) => typeof p == "object" && "_key" in p
      );
      return rxjs.concat(
        // emit a loading state instantly
        rxjs.of({ loading: !0 }),
        // then emit the values from watching the published ID's path
        documentPreviewStore.unstable_observePathsDocumentPair(
          publishedId,
          keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)
        ).pipe(
          // this debounce time is needed to prevent flashing banners due to
          // the router state updating faster than the content-lake state. we
          // debounce to wait for more emissions because the value pulled
          // initially could be stale.
          operators.debounceTime(750),
          operators.map(
            ({ draft, published }) => {
              var _a2;
              return {
                loading: !1,
                result: {
                  availability: {
                    draft: draft.availability,
                    published: published.availability
                  },
                  refValue: (_a2 = PathUtils.get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a2._ref
                }
              };
            }
          )
        )
      );
    },
    [documentPreviewStore, parentId, parentRefPath],
    { loading: !0 }
  ), handleReloadReference = React.useCallback(() => {
    var _a2;
    referenceInfo.loading || (_a2 = referenceInfo.result) != null && _a2.refValue && replaceCurrent({
      id: referenceInfo.result.refValue,
      params
    });
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  return (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c = referenceInfo.result) != null && _c.availability.draft.available) && !((_d = referenceInfo.result) != null && _d.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId ? null : /* @__PURE__ */ jsxRuntime.jsx(
      Banner,
      {
        action: (_f = referenceInfo.result) != null && _f.refValue ? {
          onClick: handleReloadReference,
          icon: icons.SyncIcon,
          text: t("banners.reference-changed-banner.reason-changed.reload-button.text")
        } : {
          as: BackLink2,
          icon: icons.CloseIcon,
          text: t("banners.reference-changed-banner.reason-removed.close-button.text")
        },
        "data-testid": "reference-changed-banner",
        content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: (_g = referenceInfo.result) != null && _g.refValue ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }),
        icon: icons.WarningOutlineIcon,
        tone: "caution"
      }
    )
  );
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
const TitleContainer = styled__default.default(ui.Stack)`
  ${({ theme: theme2 }) => styled.css`
      @supports not (container-type: inline-size) {
        display: none !important;
      }

      container-type: inline-size;

      [data-heading] {
        font-size: ${theme2.sanity.fonts.heading.sizes[4].fontSize}px;
        line-height: ${theme2.sanity.fonts.heading.sizes[4].lineHeight}px;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      @container (max-width: 560px) {
        [data-heading] {
          font-size: ${theme2.sanity.fonts.heading.sizes[3].fontSize}px;
          line-height: ${theme2.sanity.fonts.heading.sizes[3].lineHeight}px;
        }
      }

      @container (max-width: 420px) {
        [data-heading] {
          font-size: ${theme2.sanity.fonts.heading.sizes[2].fontSize}px;
          line-height: ${theme2.sanity.fonts.heading.sizes[2].lineHeight}px;
        }
      }
    `}
`, FormHeader = ({ documentId, schemaType, title }) => {
  var _a;
  const isSingleton = documentId === schemaType.name, { t } = reactI18next.useTranslation(structureLocaleNamespace);
  return schemaType.__experimental_formPreviewTitle === !1 ? null : /* @__PURE__ */ jsxRuntime.jsxs(TitleContainer, { marginBottom: 6, space: 4, children: [
    !isSingleton && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: (_a = schemaType.title) != null ? _a : schemaType.name }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h2", "data-heading": !0, muted: !title, children: title != null ? title : t("document-view.form-view.form-title-fallback") })
  ] });
};
function usePrevious(value) {
  const ref = React.useRef();
  return React.useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
const LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = ui.useToast(), wasEnabled = usePrevious(params.enabled);
  React.useEffect(() => {
    !wasEnabled && params.enabled && toast.push({ ...params, duration: LONG_ENOUGH_BUT_NOT_TOO_LONG }), wasEnabled && !params.enabled && toast.push({
      ...params,
      // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
      duration: 0.01
    });
  }, [params, toast, wasEnabled]);
}
const preventDefault = (ev) => ev.preventDefault(), FormView = React.forwardRef(function(props, ref) {
  var _a;
  const { hidden, margins } = props, {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    connectionState,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane(), documentStore = sanity.useDocumentStore(), presence = sanity.useDocumentPresence(documentId), { title } = useDocumentTitle(), patchChannel = React.useMemo(() => sanity.createPatchChannel(), []), isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled, { t } = sanity.useTranslation(structureLocaleNamespace);
  useConditionalToast({
    id: `sync-lock-${documentId}`,
    status: "warning",
    enabled: isLocked,
    title: t("document-view.form-view.sync-lock-toast.title"),
    description: t("document-view.form-view.sync-lock-toast.description")
  }), React.useEffect(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(
      operators.tap((event) => {
        event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
      })
    ).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = !!(value != null && value._rev);
  React.useEffect(() => {
    hasRev && patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, [hasRev]);
  const [formRef, setFormRef] = React.useState(null);
  React.useEffect(() => {
    ready && !(formState != null && formState.focusPath.length) && formRef && ui.focusFirstDescendant(formRef);
  }, [ready]);
  const setRef = React.useCallback(
    (node) => {
      setFormRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
    },
    [ref]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Container,
    {
      hidden,
      paddingX: 4,
      paddingTop: 5,
      paddingBottom: 9,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */ jsxRuntime.jsx(sanity.PresenceOverlay, { margins, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "form", onSubmit: preventDefault, ref: setRef, children: connectionState === "connecting" ? /* @__PURE__ */ jsxRuntime.jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: t("document-view.form-view.loading") }) })
      ] }) }) : formState === null || hidden ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t("document-view.form-view.form-hidden") }) }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(FormHeader, { documentId, schemaType: formState.schemaType, title }),
        /* @__PURE__ */ jsxRuntime.jsx(
          sanity.FormBuilder,
          {
            __internal_fieldActions: fieldActions,
            __internal_patchChannel: patchChannel,
            collapsedFieldSets,
            collapsedPaths,
            focusPath: formState.focusPath,
            changed: formState.changed,
            focused: formState.focused,
            groups: formState.groups,
            id: "root",
            members: formState.members,
            onChange,
            onFieldGroupSelect: onSetActiveFieldGroup,
            onPathBlur: onBlur,
            onPathFocus: onFocus,
            onPathOpen,
            onSetFieldSetCollapsed: onSetCollapsedFieldSet,
            onSetPathCollapsed: onSetCollapsedPath,
            presence,
            readOnly: connectionState === "reconnecting" || formState.readOnly,
            schemaType: formState.schemaType,
            validation,
            value: (
              // note: the form state doesn't have a typed concept of a "document" value
              // but these should be compatible
              formState.value
            )
          }
        )
      ] }) }) })
    }
  );
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: sanity.fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: sanity.fromMutationPatches("remote", remotePatches).concat(
      sanity.fromMutationPatches("local", localPatches)
    )
  };
}
const DocumentBox = styled__default.default(ui.Box)({
  position: "relative"
}), Scroller$1 = styled__default.default(sanity.ScrollContainer)(({ $disabled }) => $disabled ? { height: "100%" } : styled.css`
    height: 100%;
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    outline: none;
  `), DocumentPanel = function(props) {
  const { footerHeight, headerHeight, isInspectOpen, rootElement, setDocumentPanelPortalElement } = props, {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views: views2,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading,
    isDeleting,
    isDeleted,
    timelineStore
  } = useDocumentPane(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed } = usePane(), parentPortal = ui.usePortal(), { features } = useStructureTool(), portalRef = React.useRef(null), [documentScrollElement, setDocumentScrollElement] = React.useState(null), formContainerElement = React.useRef(null), requiredPermission = value._createdAt ? "update" : "create", activeView = React.useMemo(
    () => views2.find((view) => view.id === activeViewId) || views2[0] || { type: "form" },
    [activeViewId, views2]
  ), portalElement = features.splitPanes && portalRef.current || parentPortal.element, margins = React.useMemo(() => layoutCollapsed ? [headerHeight || 0, 0, footerHeight ? footerHeight + 2 : 2, 0] : [0, 0, 2, 0], [layoutCollapsed, footerHeight, headerHeight]), formViewHidden = activeView.type !== "form", activeViewNode = React.useMemo(
    () => activeView.type === "component" && activeView.component && React.createElement(activeView.component, {
      document: {
        draft: (editState == null ? void 0 : editState.draft) || null,
        displayed: displayed || value,
        historical: displayed,
        published: (editState == null ? void 0 : editState.published) || null
      },
      documentId,
      options: activeView.options,
      schemaType
    }),
    [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]
  ), lastNonDeletedRevId = sanity.useTimelineSelector(
    timelineStore,
    (state2) => state2.lastNonDeletedRevId
  );
  React.useEffect(() => {
    documentScrollElement != null && documentScrollElement.scrollTo && documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]), React.useEffect(() => {
    portalElement && setDocumentPanelPortalElement(portalElement);
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = React.useMemo(() => isInspectOpen ? /* @__PURE__ */ jsxRuntime.jsx(InspectDialog, { value: displayed || value }) : null, [isInspectOpen, displayed, value]), showInspector = !!(!collapsed && inspector);
  return /* @__PURE__ */ jsxRuntime.jsx(PaneContent, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { height: "fill", children: [
    (features.resizablePanes || !showInspector) && /* @__PURE__ */ jsxRuntime.jsx(DocumentBox, { flex: 2, overflow: "hidden", children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.PortalProvider,
      {
        element: portalElement,
        __unstable_elements: { documentScrollElement },
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: documentScrollElement, children: /* @__PURE__ */ jsxRuntime.jsxs(
          sanity.VirtualizerScrollInstanceProvider,
          {
            scrollElement: documentScrollElement,
            containerElement: formContainerElement,
            children: [
              activeView.type === "form" && !isPermissionsLoading && ready && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
                /* @__PURE__ */ jsxRuntime.jsx(
                  PermissionCheckBanner,
                  {
                    granted: !!(permissions != null && permissions.granted),
                    requiredPermission
                  }
                ),
                !isDeleting && isDeleted && /* @__PURE__ */ jsxRuntime.jsx(DeletedDocumentBanner, { revisionId: lastNonDeletedRevId }),
                /* @__PURE__ */ jsxRuntime.jsx(ReferenceChangedBanner, {}),
                /* @__PURE__ */ jsxRuntime.jsx(DeprecatedDocumentTypeBanner, {})
              ] }),
              /* @__PURE__ */ jsxRuntime.jsxs(
                Scroller$1,
                {
                  $disabled: layoutCollapsed || !1,
                  "data-testid": "document-panel-scroller",
                  ref: setDocumentScrollElement,
                  children: [
                    /* @__PURE__ */ jsxRuntime.jsx(
                      FormView,
                      {
                        hidden: formViewHidden,
                        margins,
                        ref: formContainerElement
                      },
                      documentId + (ready ? "_ready" : "_pending")
                    ),
                    activeViewNode
                  ]
                }
              ),
              inspectDialog,
              /* @__PURE__ */ jsxRuntime.jsx("div", { "data-testid": "document-panel-portal", ref: portalRef })
            ]
          }
        ) })
      }
    ) }),
    showInspector && /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: rootElement, children: /* @__PURE__ */ jsxRuntime.jsx(
      DocumentInspectorPanel,
      {
        documentId,
        documentType: schemaType.name,
        flex: 1
      }
    ) })
  ] }) });
}, POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"], DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const { dialog, referenceElement } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Popover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ConfirmDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: !0,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      referenceElement
    }
  );
}
function ConfirmDialogContent(props) {
  const { dialog } = props, {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog, { t } = sanity.useTranslation(structureLocaleNamespace), { isTopLayer } = ui.useLayer(), [element, setElement] = React.useState(null), handleClickOutside = React.useCallback(() => {
    isTopLayer && onCancel();
  }, [isTopLayer, onCancel]), handleGlobalKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && isTopLayer && onCancel();
    },
    [isTopLayer, onCancel]
  );
  return ui.useClickOutside(handleClickOutside, [element]), ui.useGlobalKeyDown(handleGlobalKeyDown), /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", ref: setElement, style: { minWidth: 304, maxWidth: 400 }, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, overflow: "auto", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: message }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 4, paddingY: 3, style: { borderTop: "1px solid var(--card-border-color)" }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Grid, { columns: 2, gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Button,
        {
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || t("confirm-dialog.cancel-button.fallback-text")
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Button,
        {
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"),
          tone
        }
      )
    ] }) })
  ] });
}
function ModalDialog(props) {
  const { dialog } = props, dialogId = React.useId(), footer = dialog.footer && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 4, paddingY: 3, children: dialog.footer });
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "fullscreen", children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Dialog,
    {
      __unstable_hideCloseButton: dialog.showCloseButton === !1,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: dialog.content })
    }
  ) });
}
function PopoverDialog(props) {
  const { dialog, referenceElement } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Popover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(PopoverDialogContent, { dialog }),
      fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
      open: !0,
      placement: "top",
      portal: !0,
      preventOverflow: !0,
      referenceElement
    }
  );
}
function PopoverDialogContent(props) {
  const { dialog } = props, { content, onClose } = dialog, { isTopLayer } = ui.useLayer(), [element, setElement] = React.useState(null), handleClickOutside = React.useCallback(() => {
    isTopLayer && onClose();
  }, [isTopLayer, onClose]), handleGlobalKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && isTopLayer && onClose();
    },
    [isTopLayer, onClose]
  );
  return ui.useClickOutside(handleClickOutside, [element]), ui.useGlobalKeyDown(handleGlobalKeyDown), /* @__PURE__ */ jsxRuntime.jsx("div", { ref: setElement, children: content });
}
function DocumentActionPortalProvider(props) {
  const { children } = props, { element, elements } = ui.usePortal(), portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.PortalProvider, { element: portalElement, children });
}
function ActionStateDialog(props) {
  const { dialog, referenceElement = null } = props, modalId = React.useId();
  if (dialog.type === "confirm")
    return /* @__PURE__ */ jsxRuntime.jsx(ConfirmDialog, { dialog, referenceElement });
  if (dialog.type === "popover")
    return /* @__PURE__ */ jsxRuntime.jsx(PopoverDialog, { dialog, referenceElement });
  if (dialog.type === "dialog" || !dialog.type)
    return /* @__PURE__ */ jsxRuntime.jsx(DocumentActionPortalProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ModalDialog, { dialog }) });
  if (dialog.type === "custom")
    return /* @__PURE__ */ jsxRuntime.jsx(DocumentActionPortalProvider, { children: dialog == null ? void 0 : dialog.component });
  const unknownModal = dialog;
  return console.warn(`Unsupported modal type ${unknownModal.type}`), /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      id: modalId,
      onClose: unknownModal.onClose,
      onClickOutside: unknownModal.onClose,
      width: 1,
      children: unknownModal.content || // eslint-disable-next-line i18next/no-literal-string
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
        "Unexpected modal type (",
        /* @__PURE__ */ jsxRuntime.jsx("code", { children: unknownModal.type }),
        ")"
      ] })
    }
  );
}
function ActionDialogWrapper({
  actionStates,
  children,
  referenceElement
}) {
  const [actionIndex, setActionIndex] = React.useState(-1), currentAction = actionStates[actionIndex], handleAction = React.useCallback((idx) => {
    setActionIndex(idx);
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    currentAction && currentAction.dialog && /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsxRuntime.jsx(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }),
    children({ handleAction })
  ] });
}
function ActionMenuButton(props) {
  const { actionStates, disabled } = props, idPrefix = React.useId(), [referenceElement, setReferenceElement] = React.useState(null), popoverProps = React.useMemo(
    () => ({
      placement: "top-end",
      portal: !0,
      preventOverflow: !0
    }),
    []
  ), { t } = sanity.useTranslation(structureLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(ActionDialogWrapper, { actionStates, referenceElement, children: ({ handleAction }) => /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      id: `${idPrefix}-action-menu`,
      button: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.ContextMenuButton,
        {
          "aria-label": t("buttons.action-menu-button.aria-label"),
          disabled,
          "data-testid": "action-menu-button",
          size: "large",
          tooltipProps: { content: t("buttons.action-menu-button.tooltip") }
        }
      ),
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { padding: 1, children: actionStates.map((actionState, idx) => /* @__PURE__ */ jsxRuntime.jsx(
        ActionMenuListItem,
        {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        },
        idx
      )) }),
      popover: popoverProps,
      ref: setReferenceElement
    }
  ) });
}
function ActionMenuListItem(props) {
  const { actionState, disabled, index, onAction } = props, { onHandle } = actionState, handleClick = React.useCallback(() => {
    onAction(index), onHandle && onHandle();
  }, [index, onAction, onHandle]), hotkeys = React.useMemo(() => actionState.shortcut ? String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1)) : void 0, [actionState.shortcut]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      "data-testid": `action-${actionState.label.replace(" ", "")}`,
      disabled: disabled || !!actionState.disabled,
      hotkeys,
      icon: actionState.icon,
      onClick: handleClick,
      text: actionState.label,
      tone: actionState.tone,
      ...actionState.disabled && { tooltipProps: { content: actionState.title } }
    }
  );
}
const TIMELINE_ICON_COMPONENTS = {
  create: icons.AddCircleIcon,
  delete: icons.TrashIcon,
  discardDraft: icons.CloseIcon,
  initial: icons.AddCircleIcon,
  editDraft: icons.EditIcon,
  editLive: icons.EditIcon,
  publish: icons.PublishIcon,
  unpublish: icons.UnpublishIcon
};
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
const StackWrapper = styled__default.default(ui.Stack)`
  max-width: 200px;
`, ListWrapper = styled__default.default(ui.Flex)`
  max-height: calc(100vh - 198px);
  min-width: 244px;
`, Root$4 = styled__default.default(ui.Box)(({ $visible }) => styled.css`
    opacity: 0;
    pointer-events: none;

    ${$visible && styled.css`
      opacity: 1;
      pointer-events: auto;
    `}
  `), TIMELINE_ITEM_I18N_KEY_MAPPING = {
  initial: "timeline.operation.created-initial",
  create: "timeline.operation.created",
  publish: "timeline.operation.published",
  editLive: "timeline.operation.edited-live",
  editDraft: "timeline.operation.edited-draft",
  unpublish: "timeline.operation.unpublished",
  discardDraft: "timeline.operation.draft-discarded",
  delete: "timeline.operation.deleted"
}, IconWrapper = styled__default.default(ui.Flex)(({ theme: theme2 }) => {
  var _a;
  const borderColor = (_a = theme2.sanity.color.base.skeleton) == null ? void 0 : _a.from;
  return styled.css`
    --timeline-hairline-width: 1px;
    position: relative;
    z-index: 2;
    margin: 0;
    padding: 0;

    &::before {
      position: absolute;
      content: '';
      height: 100%;
      width: var(--timeline-hairline-width);
      background: ${borderColor};
      top: 0;
      left: calc((100% - var(--timeline-hairline-width)) / 2);
      z-index: 1;
    }
  `;
}), Root$3 = styled__default.default(ui.Button)(({ $selected, $disabled }) => styled.css`
    position: relative;
    width: 100%;

    /* Line styling */
    &[data-first] ${IconWrapper}::before {
      height: 50%;
      top: unset;
      bottom: 0;
    }

    &[data-last] ${IconWrapper}::before {
      height: 50%;
    }

    ${$selected && styled.css`
      ${IconWrapper}::before {
        background: transparent;
      }
    `}

    ${$disabled && styled.css`
      cursor: not-allowed;
    `}
  `), IconBox = styled__default.default(ui.Box)`
  background: var(--card-bg-color);
  border-radius: 50px;
  position: relative;
  z-index: 2;
`, TimestampBox = styled__default.default(ui.Box)`
  min-width: 1rem;
  margin-left: ${({ theme: theme2 }) => `-${ui.rem(theme2.sanity.space[1])}`};
`;
function UserAvatarStack({ maxLength, userIds }) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarStack, { maxLength, children: userIds.map((userId) => /* @__PURE__ */ jsxRuntime.jsx(sanity.UserAvatar, { user: userId, withTooltip: !0 }, userId)) });
}
const TIMELINE_ITEM_EVENT_TONE = {
  initial: "primary",
  create: "primary",
  publish: "positive",
  editLive: "caution",
  editDraft: "caution",
  unpublish: "critical",
  discardDraft: "critical",
  delete: "critical",
  withinSelection: "primary"
};
function TimelineItem({
  chunk,
  isFirst,
  isLast,
  isLatest,
  isSelected,
  onSelect,
  timestamp,
  type
}) {
  const { t } = sanity.useTranslation("studio"), iconComponent = getTimelineEventIconComponent(type), authorUserIds = Array.from(chunk.authors), isSelectable = type !== "delete", dateFormat = sanity.useDateTimeFormat({ dateStyle: "medium", timeStyle: "short" }), formattedTimestamp = React.useMemo(() => {
    const parsedDate = new Date(timestamp);
    return dateFormat.format(parsedDate);
  }, [timestamp, dateFormat]), handleClick = React.useCallback(
    (evt) => {
      evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(chunk);
    },
    [onSelect, chunk, isSelectable]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$3,
    {
      $selected: isSelected,
      $disabled: !isSelectable,
      "data-chunk-id": chunk.id,
      "data-first": isFirst ? !0 : void 0,
      "data-last": isLast ? !0 : void 0,
      "data-ui": "timelineItem",
      mode: isSelected ? "default" : "bleed",
      onClick: handleClick,
      padding: 0,
      radius: 2,
      tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "stretch", children: [
        /* @__PURE__ */ jsxRuntime.jsx(IconWrapper, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(IconBox, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, children: iconComponent && React.createElement(iconComponent) }) }) }),
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, margin: 2, children: [
          isLatest && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Card,
            {
              padding: 1,
              radius: 2,
              shadow: 1,
              tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type],
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 0, weight: "medium", children: t("timeline.latest") })
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || /* @__PURE__ */ jsxRuntime.jsx("code", { children: type }) }) }),
          /* @__PURE__ */ jsxRuntime.jsx(TimestampBox, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "time", size: 0, muted: !0, dateTime: timestamp, children: formattedTimestamp }) })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, justify: "flex-end", align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(UserAvatarStack, { maxLength: 3, userIds: authorUserIds }) })
      ] }) })
    }
  );
}
const Timeline = ({
  chunks,
  disabledBeforeFirstChunk,
  hasMoreChunks,
  lastChunk,
  onLoadMore,
  onSelect,
  firstChunk
}) => {
  const [mounted, setMounted] = React.useState(!1), { t } = sanity.useTranslation("studio"), filteredChunks = React.useMemo(() => chunks.filter((c) => disabledBeforeFirstChunk && firstChunk ? c.index < firstChunk.index : !0), [chunks, disabledBeforeFirstChunk, firstChunk]), selectedIndex = React.useMemo(
    () => lastChunk != null && lastChunk.id ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1,
    [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]
  ), renderItem2 = React.useCallback(
    (chunk, { activeIndex }) => {
      const isFirst = activeIndex === 0, isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || !1;
      return /* @__PURE__ */ jsxRuntime.jsxs(ui.Box, { paddingBottom: isLast ? 1 : 0, paddingTop: isFirst ? 1 : 0, paddingX: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TimelineItem,
          {
            chunk,
            isFirst,
            isLast,
            isLatest: activeIndex === 0 && !disabledBeforeFirstChunk,
            isSelected: activeIndex === selectedIndex,
            onSelect,
            timestamp: chunk.endTimestamp,
            type: chunk.type
          }
        ),
        activeIndex === filteredChunks.length - 1 && hasMoreChunks && /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, {})
      ] });
    },
    [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]
  );
  return React.useEffect(() => setMounted(!0), []), /* @__PURE__ */ jsxRuntime.jsxs(
    Root$4,
    {
      $visible: !selectedIndex || mounted,
      "data-ui": "timeline",
      children: [
        filteredChunks.length === 0 && /* @__PURE__ */ jsxRuntime.jsxs(StackWrapper, { padding: 3, space: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t("timeline.error.no-document-history-description") })
        ] }),
        filteredChunks.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ListWrapper, { direction: "column", children: /* @__PURE__ */ jsxRuntime.jsx(
          sanity.CommandList,
          {
            activeItemDataAttr: "data-hovered",
            ariaLabel: t("timeline.list.aria-label"),
            autoFocus: "list",
            initialIndex: selectedIndex,
            initialScrollAlign: "center",
            itemHeight: 40,
            items: filteredChunks,
            onEndReached: onLoadMore,
            onEndReachedIndexOffset: 20,
            overscan: 5,
            renderItem: renderItem2,
            wrapAround: !1
          }
        ) })
      ]
    }
  );
};
Timeline.displayName = "Timeline";
function TimelineError() {
  const { t } = sanity.useTranslation("studio");
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, padding: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(sanity.TextWithTone, { tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(icons.ErrorOutlineIcon, {}) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(sanity.TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t("timeline.error.load-document-changes-title") }),
      /* @__PURE__ */ jsxRuntime.jsx(sanity.TextWithTone, { size: 1, tone: "critical", children: t("timeline.error.load-document-changes-description") })
    ] })
  ] });
}
const Root$2 = styled__default.default(getJsonStream.Popover)`
  overflow: hidden;
  overflow: clip;
`;
function TimelineMenu({ chunk, mode, placement }) {
  const { setTimelineRange, setTimelineMode, timelineError, ready, timelineStore } = useDocumentPane(), [open, setOpen] = React.useState(!1), [button, setButton] = React.useState(null), [popover, setPopover] = React.useState(null), toast = ui.useToast(), chunks = sanity.useTimelineSelector(timelineStore, (state2) => state2.chunks), loading = sanity.useTimelineSelector(timelineStore, (state2) => state2.isLoading), hasMoreChunks = sanity.useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks), realRevChunk = sanity.useTimelineSelector(timelineStore, (state2) => state2.realRevChunk), sinceTime = sanity.useTimelineSelector(timelineStore, (state2) => state2.sinceTime), { t } = sanity.useTranslation("studio"), handleOpen = React.useCallback(() => {
    setTimelineMode(mode), setOpen(!0);
  }, [mode, setTimelineMode]), handleClose = React.useCallback(() => {
    setTimelineMode("closed"), setOpen(!1);
  }, [setTimelineMode]), handleClickOutside = React.useCallback(() => {
    open && handleClose();
  }, [handleClose, open]), handleGlobalKeyDown = React.useCallback(
    (event) => {
      open && (event.key === "Escape" || event.key === "Tab") && (handleClose(), button == null || button.focus());
    },
    [button, handleClose, open]
  );
  ui.useClickOutside(handleClickOutside, [button, popover]), ui.useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = React.useCallback(
    (revChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: !0,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), selectSince = React.useCallback(
    (sinceChunk) => {
      try {
        const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
        setTimelineMode("closed"), setTimelineRange(sinceId, revId);
      } catch (err) {
        toast.push({
          closable: !0,
          description: err.message,
          status: "error",
          title: t("timeline.error.unable-to-load-revision")
        });
      }
    },
    [setTimelineMode, setTimelineRange, t, timelineStore, toast]
  ), handleLoadMore = React.useCallback(() => {
    loading || timelineStore.loadMore();
  }, [loading, timelineStore]), content = timelineError ? /* @__PURE__ */ jsxRuntime.jsx(TimelineError, {}) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    mode === "rev" && /* @__PURE__ */ jsxRuntime.jsx(
      Timeline,
      {
        chunks,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: realRevChunk,
        onLoadMore: handleLoadMore,
        onSelect: selectRev
      }
    ),
    mode === "since" && /* @__PURE__ */ jsxRuntime.jsx(
      Timeline,
      {
        chunks,
        disabledBeforeFirstChunk: !0,
        firstChunk: realRevChunk,
        hasMoreChunks,
        lastChunk: sinceTime,
        onLoadMore: handleLoadMore,
        onSelect: selectSince
      }
    )
  ] }), formatParams = {
    timestamp: { dateStyle: "medium", timeStyle: "short" }
  }, revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], {
    context: "timestamp",
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.latest-version"), sinceLabel = chunk ? t("timeline.since", {
    timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp),
    formatParams
  }) : t("timeline.since-version-missing");
  return /* @__PURE__ */ jsxRuntime.jsx(
    Root$2,
    {
      constrainSize: !0,
      content: open && content,
      "data-ui": "versionMenu",
      open,
      placement,
      portal: !0,
      ref: setPopover,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          disabled: !ready,
          mode: "bleed",
          iconRight: icons.ChevronDownIcon,
          onClick: open ? handleClose : handleOpen,
          ref: setButton,
          selected: open,
          style: { maxWidth: "100%" },
          text: ready ? mode === "rev" ? revLabel : sinceLabel : t("timeline.loading-history")
        }
      )
    }
  );
}
function DocumentHeaderTabs() {
  const { activeViewId, paneKey, views: views2 } = useDocumentPane(), tabPanelId = `${paneKey}tabpanel`;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TabList, { space: 1, children: views2.map((view, index) => {
    var _a;
    return /* @__PURE__ */ jsxRuntime.jsx(
      DocumentHeaderTab,
      {
        icon: view.icon,
        id: `${paneKey}tab-${view.id}`,
        isActive: activeViewId === view.id,
        label: view.title,
        tabPanelId,
        viewId: index === 0 ? null : (_a = view.id) != null ? _a : null
      },
      view.id
    );
  }) });
}
function DocumentHeaderTab(props) {
  const { icon, id, isActive, label, tabPanelId, viewId, ...rest } = props, { ready } = useDocumentPane(), { setView } = usePaneRouter(), handleClick = React.useCallback(() => setView(viewId), [setView, viewId]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tab,
    {
      ...rest,
      "aria-controls": tabPanelId,
      disabled: !ready,
      icon,
      id,
      label,
      onClick: handleClick,
      selected: isActive
    }
  );
}
function DocumentHeaderTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane(), subscribed = !!documentValue && connectionState !== "connecting", { error, value } = sanity.unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  }), { t } = sanity.useTranslation(structureLocaleNamespace);
  return connectionState === "connecting" ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {}) : title ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: title }) : documentValue ? error ? /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t("panes.document-header-title.error.text", { error: error.message }) }) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: (value == null ? void 0 : value.title) || /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("panes.document-header-title.untitled.text") }) }) : /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: t("panes.document-header-title.new.text", {
    schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)
  }) });
}
const DocumentPanelHeader = React.memo(
  React.forwardRef(function(_props, ref) {
    const { menuItems } = _props, {
      actions,
      editState,
      onMenuAction,
      onPaneClose,
      onPaneSplit,
      menuItemGroups,
      schemaType,
      timelineStore,
      connectionState,
      views: views2,
      unstable_languageFilter
    } = useDocumentPane(), { features } = useStructureTool(), { index, BackLink: BackLink2, hasGroupSiblings } = usePaneRouter(), { actions: fieldActions } = sanity.useFieldActions(), [referenceElement, setReferenceElement] = React.useState(null), menuNodes = React.useMemo(
      () => resolveMenuNodes({ actionHandler: onMenuAction, fieldActions, menuItems, menuItemGroups }),
      [onMenuAction, fieldActions, menuItemGroups, menuItems]
    ), menuButtonNodes = React.useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]), contextMenuNodes = React.useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]), showTabs = views2.length > 1, rev = sanity.useTimelineSelector(timelineStore, (state2) => state2.revTime), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1, showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings, showBackButton = features.backButton && index > 0, showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink2, { t } = sanity.useTranslation(structureLocaleNamespace);
    return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
      PaneHeader,
      {
        border: !0,
        ref,
        loading: connectionState === "connecting",
        title: /* @__PURE__ */ jsxRuntime.jsx(DocumentHeaderTitle, {}),
        tabs: showTabs && /* @__PURE__ */ jsxRuntime.jsx(DocumentHeaderTabs, {}),
        tabIndex,
        backButton: showBackButton && /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            as: BackLink2,
            "data-as": "a",
            icon: icons.ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: t("pane-header.back-button.text") }
          }
        ),
        subActions: /* @__PURE__ */ jsxRuntime.jsx(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }),
        actions: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
          unstable_languageFilter.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: unstable_languageFilter.map((languageFilterComponent, idx) => React.createElement(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: `language-filter-${idx}`,
            schemaType
          })) }),
          menuButtonNodes.map((item) => /* @__PURE__ */ jsxRuntime.jsx(PaneHeaderActionButton, { node: item }, item.key)),
          editState && /* @__PURE__ */ jsxRuntime.jsx(
            RenderActionCollectionState,
            {
              actions: actions || [],
              actionProps: editState,
              group: "paneActions",
              children: ({ states }) => /* @__PURE__ */ jsxRuntime.jsx(ActionDialogWrapper, { actionStates: states, referenceElement, children: ({ handleAction }) => /* @__PURE__ */ jsxRuntime.jsx("div", { ref: setReferenceElement, children: /* @__PURE__ */ jsxRuntime.jsx(
                PaneContextMenuButton,
                {
                  nodes: contextMenuNodes,
                  actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => /* @__PURE__ */ jsxRuntime.jsx(
                    ActionMenuListItem,
                    {
                      actionState,
                      disabled: !!actionState.disabled,
                      index: actionIndex,
                      onAction: handleAction
                    },
                    actionState.label
                  )) : void 0
                },
                "context-menu"
              ) }) })
            }
          ),
          showSplitPaneButton && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              "aria-label": t("buttons.split-pane-button.aria-label"),
              icon: icons.SplitVerticalIcon,
              mode: "bleed",
              onClick: onPaneSplit,
              tooltipProps: { content: t("buttons.split-pane-button.tooltip") }
            },
            "split-pane-button"
          ),
          showSplitPaneCloseButton && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              icon: icons.CloseIcon,
              mode: "bleed",
              onClick: onPaneClose,
              tooltipProps: { content: t("buttons.split-pane-close-button.title") }
            },
            "close-view-button"
          ),
          showPaneGroupCloseButton && /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.Button,
            {
              icon: icons.CloseIcon,
              mode: "bleed",
              tooltipProps: { content: t("buttons.split-pane-close-group-button.title") },
              as: BackLink2
            },
            "close-view-button"
          )
        ] })
      }
    ) });
  })
), BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner({ states }) {
  return states.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(ui.Inline, { space: 1, children: states.map((badge, index) => /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: badge.title,
      disabled: !badge.title,
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Badge,
        {
          fontSize: 1,
          mode: "outline",
          paddingX: 2,
          paddingY: 1,
          radius: 4,
          tone: badge.color ? BADGE_TONES[badge.color] : void 0,
          style: { whiteSpace: "nowrap" },
          children: badge.label
        }
      )
    },
    String(index)
  )) });
}
function DocumentBadges() {
  const { badges, editState } = useDocumentPane();
  return !editState || !badges ? null : /* @__PURE__ */ jsxRuntime.jsx(RenderBadgeCollectionState, { badges, badgeProps: editState, children: ({ states }) => /* @__PURE__ */ jsxRuntime.jsx(DocumentBadgesInner, { states }) });
}
const DISABLED_REASON_TITLE_KEY$1 = {
  NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete",
  NOT_READY: "action.delete.disabled.not-ready"
}, DeleteAction = ({ id, type, draft, onComplete }) => {
  const { setIsDeleting: paneSetIsDeleting } = useDocumentPane(), { delete: deleteOp } = sanity.useDocumentOperation(id, type), [isDeleting, setIsDeleting] = React.useState(!1), [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(!1), { t } = sanity.useTranslation(structureLocaleNamespace), handleCancel = React.useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = React.useCallback(() => {
    setIsDeleting(!0), setConfirmDialogOpen(!1), paneSetIsDeleting(!0), deleteOp.execute(), onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]), handle = React.useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "delete"
  }), currentUser = sanity.useCurrentUser();
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: icons.TrashIcon,
    disabled: !0,
    label: t("action.delete.label"),
    title: /* @__PURE__ */ jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, { context: "delete-document", currentUser })
  } : {
    tone: "critical",
    icon: icons.TrashIcon,
    disabled: isDeleting || !!deleteOp.disabled || isPermissionsLoading,
    title: deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "",
    label: t(isDeleting ? "action.delete.running.label" : "action.delete.label"),
    shortcut: "Ctrl+Alt+D",
    onHandle: handle,
    dialog: isConfirmDialogOpen && {
      type: "custom",
      component: /* @__PURE__ */ jsxRuntime.jsx(
        ConfirmDeleteDialogContainer,
        {
          action: "delete",
          id: (draft == null ? void 0 : draft._id) || id,
          type,
          onCancel: handleCancel,
          onConfirm: handleConfirm
        }
      )
    }
  };
};
DeleteAction.action = "delete";
const DISABLED_REASON_KEY$2 = {
  NO_CHANGES: "action.discard-changes.disabled.no-changes",
  NOT_PUBLISHED: "action.discard-changes.disabled.not-published",
  NOT_READY: "action.discard-changes.disabled.not-ready"
}, DiscardChangesAction = ({
  id,
  type,
  published,
  liveEdit,
  onComplete
}) => {
  const { discardChanges } = sanity.useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(!1), [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "discardDraft"
  }), currentUser = sanity.useCurrentUser(), { t } = sanity.useTranslation(structureLocaleNamespace), handleConfirm = React.useCallback(() => {
    discardChanges.execute(), onComplete();
  }, [discardChanges, onComplete]), handle = React.useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = React.useMemo(
    () => isConfirmDialogOpen && {
      type: "confirm",
      tone: "critical",
      onCancel: onComplete,
      onConfirm: handleConfirm,
      message: t("action.discard-changes.confirm-dialog.confirm-discard-changes")
    },
    [handleConfirm, isConfirmDialogOpen, onComplete, t]
  );
  return !published || liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: icons.ResetIcon,
    disabled: !0,
    label: t("action.discard-changes.label"),
    title: /* @__PURE__ */ jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, { context: "discard-changes", currentUser })
  } : {
    tone: "critical",
    icon: icons.ResetIcon,
    disabled: !!discardChanges.disabled || isPermissionsLoading,
    title: discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "",
    label: t("action.discard-changes.label"),
    onHandle: handle,
    dialog
  };
};
DiscardChangesAction.action = "discardChanges";
const DISABLED_REASON_KEY$1 = {
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
}, DuplicateAction = ({ id, type, onComplete }) => {
  const documentStore = sanity.useDocumentStore(), { duplicate } = sanity.useDocumentOperation(id, type), { navigateIntent } = router$1.useRouter(), [isDuplicating, setDuplicating] = React.useState(!1), [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "duplicate"
  }), { t } = sanity.useTranslation(structureLocaleNamespace), currentUser = sanity.useCurrentUser(), handle = React.useCallback(async () => {
    const dupeId = uuid.uuid();
    setDuplicating(!0);
    const duplicateSuccess = rxjs.firstValueFrom(
      documentStore.pair.operationEvents(id, type).pipe(rxjs.filter((e) => e.op === "duplicate" && e.type === "success"))
    );
    duplicate.execute(dupeId), await duplicateSuccess, navigateIntent("edit", { id: dupeId, type }), onComplete();
  }, [documentStore.pair, duplicate, id, navigateIntent, onComplete, type]);
  return !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    icon: icons.CopyIcon,
    disabled: !0,
    label: t("action.duplicate.label"),
    title: /* @__PURE__ */ jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, { context: "duplicate-document", currentUser })
  } : {
    icon: icons.CopyIcon,
    disabled: isDuplicating || !!duplicate.disabled || isPermissionsLoading,
    label: t(isDuplicating ? "action.duplicate.running.label" : "action.duplicate.label"),
    title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "",
    onHandle: handle
  };
};
DuplicateAction.action = "duplicate";
const HistoryRestoreAction = ({ id, type, revision, onComplete }) => {
  const { restore } = sanity.useDocumentOperation(id, type), event = sanity.useDocumentOperationEvent(id, type), { navigateIntent } = router$1.useRouter(), prevEvent = React.useRef(event), [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(!1), { t } = sanity.useTranslation(structureLocaleNamespace), handleConfirm = React.useCallback(() => {
    restore.execute(revision), onComplete();
  }, [restore, revision, onComplete]);
  React.useEffect(() => {
    !event || event === prevEvent.current || (event.type === "success" && event.op === "restore" && navigateIntent("edit", { id, type }), prevEvent.current = event);
  }, [event, id, navigateIntent, type]);
  const handle = React.useCallback(() => {
    setConfirmDialogOpen(!0);
  }, []), dialog = React.useMemo(() => isConfirmDialogOpen ? {
    type: "confirm",
    tone: "critical",
    onCancel: onComplete,
    onConfirm: handleConfirm,
    message: t("action.restore.confirm.message")
  } : null, [handleConfirm, isConfirmDialogOpen, onComplete, t]), isRevisionInitialVersion = revision === "@initial";
  return revision === void 0 ? null : {
    label: t("action.restore.label"),
    color: "primary",
    onHandle: handle,
    title: t(
      isRevisionInitialVersion ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip"
    ),
    icon: icons.RestoreIcon,
    dialog,
    disabled: isRevisionInitialVersion
  };
};
HistoryRestoreAction.action = "restore";
const DocumentPublished = telemetry.defineEvent({
  name: "Document Published",
  version: 1,
  description: 'User clicked the "Publish" button in the document pane'
}), DISABLED_REASON_TITLE_KEY = {
  LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled",
  ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip",
  NO_CHANGES: "action.publish.no-changes.tooltip",
  NOT_READY: "action.publish.disabled.not-ready"
};
function getDisabledReason(reason, publishedAt, t) {
  return reason === "ALREADY_PUBLISHED" && publishedAt ? /* @__PURE__ */ jsxRuntime.jsx(AlreadyPublished, { publishedAt }) : t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished({ publishedAt }) {
  const { t } = sanity.useTranslation(structureLocaleNamespace), timeSincePublished = sanity.useRelativeTime(publishedAt);
  return /* @__PURE__ */ jsxRuntime.jsx("span", { children: t("action.publish.already-published.tooltip", { timeSincePublished }) });
}
const PublishAction = (props) => {
  var _a;
  const { id, type, liveEdit, draft, published } = props, [publishState, setPublishState] = React.useState(null), { publish } = sanity.useDocumentOperation(id, type), validationStatus = sanity.useValidationStatus(id, type), syncState = sanity.useSyncState(id, type), { changesOpen, onHistoryOpen, documentId, documentType } = useDocumentPane(), editState = sanity.useEditState(documentId, documentType), { t } = sanity.useTranslation(structureLocaleNamespace), revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev, hasValidationErrors = validationStatus.validation.some(types.isValidationErrorMarker), [publishScheduled, setPublishScheduled] = React.useState(!1), isSyncing = syncState.isSyncing, isValidating = validationStatus.isValidating, [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "publish"
  }), currentUser = sanity.useCurrentUser(), title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "", hasDraft = !!draft, doPublish = React.useCallback(() => {
    publish.execute(), setPublishState("publishing");
  }, [publish]);
  React.useEffect(() => {
    const validationComplete = validationStatus.isValidating === !1 && validationStatus.revision !== revision;
    !publishScheduled || isSyncing || !validationComplete || (hasValidationErrors || doPublish(), setPublishScheduled(!1));
  }, [
    isSyncing,
    doPublish,
    hasValidationErrors,
    publishScheduled,
    validationStatus.revision,
    revision,
    isValidating,
    validationStatus.isValidating
  ]), React.useEffect(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    didPublish && changesOpen && onHistoryOpen();
    const nextState = didPublish ? "published" : null, timer = setTimeout(() => {
      setPublishState(nextState);
    }, didPublish ? 200 : 4e3);
    return () => clearTimeout(timer);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const telemetry2 = react$1.useTelemetry(), handle = React.useCallback(() => {
    telemetry2.log(DocumentPublished, {
      publishedImmediately: !(draft != null && draft._createdAt),
      previouslyPublished: !!published
    }), syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision ? setPublishScheduled(!0) : doPublish();
  }, [
    telemetry2,
    draft == null ? void 0 : draft._createdAt,
    published,
    syncState.isSyncing,
    validationStatus.isValidating,
    validationStatus.revision,
    revision,
    doPublish
  ]);
  if (liveEdit)
    return {
      tone: "default",
      icon: icons.PublishIcon,
      label: t("action.publish.live-edit.label"),
      title: t("action.publish.live-edit.tooltip"),
      disabled: !0
    };
  if (!isPermissionsLoading && !(permissions != null && permissions.granted))
    return {
      tone: "default",
      icon: icons.PublishIcon,
      label: "Publish",
      title: /* @__PURE__ */ jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, { context: "publish-document", currentUser }),
      disabled: !0
    };
  const disabled = !!(publishScheduled || (_a = editState == null ? void 0 : editState.transactionSyncLock) != null && _a.enabled || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "default",
    label: (
      // eslint-disable-next-line no-nested-ternary
      t(publishState === "published" ? "action.publish.published.label" : publishScheduled || publishState === "publishing" ? "action.publish.running.label" : "action.publish.draft.label")
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: icons.PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
const DISABLED_REASON_KEY = {
  NOT_PUBLISHED: "action.unpublish.disabled.not-published",
  NOT_READY: "action.unpublish.disabled.not-ready",
  LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled"
}, UnpublishAction = ({
  id,
  type,
  draft,
  onComplete,
  liveEdit
}) => {
  const { unpublish } = sanity.useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = React.useState(!1), [permissions, isPermissionsLoading] = sanity.useDocumentPairPermissions({
    id,
    type,
    permission: "unpublish"
  }), currentUser = sanity.useCurrentUser(), { t } = sanity.useTranslation(structureLocaleNamespace), handleCancel = React.useCallback(() => {
    setConfirmDialogOpen(!1), onComplete();
  }, [onComplete]), handleConfirm = React.useCallback(() => {
    setConfirmDialogOpen(!1), unpublish.execute(), onComplete();
  }, [onComplete, unpublish]), dialog = React.useMemo(() => isConfirmDialogOpen ? {
    type: "dialog",
    onClose: onComplete,
    content: /* @__PURE__ */ jsxRuntime.jsx(
      ConfirmDeleteDialogContainer,
      {
        id: (draft == null ? void 0 : draft._id) || id,
        type,
        action: "unpublish",
        onCancel: handleCancel,
        onConfirm: handleConfirm
      }
    )
  } : null, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  return liveEdit ? null : !isPermissionsLoading && !(permissions != null && permissions.granted) ? {
    tone: "critical",
    icon: icons.UnpublishIcon,
    label: "Unpublish",
    title: /* @__PURE__ */ jsxRuntime.jsx(sanity.InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }),
    disabled: !0
  } : {
    tone: "critical",
    icon: icons.UnpublishIcon,
    disabled: !!unpublish.disabled || isPermissionsLoading,
    label: t("action.unpublish.label"),
    title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "",
    onHandle: () => setConfirmDialogOpen(!0),
    dialog
  };
};
UnpublishAction.action = "unpublish";
function DocumentStatusBarActionsInner(props) {
  const { disabled, showMenu, states } = props, { __internal_tasks } = useDocumentPane(), [firstActionState, ...menuActionStates] = states, [buttonElement, setButtonElement] = React.useState(null), tooltipContent = React.useMemo(() => !firstActionState || !firstActionState.title && !firstActionState.shortcut ? null : /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { style: { maxWidth: 300 }, align: "center", gap: 3, children: [
    firstActionState.title && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: firstActionState.title }),
    firstActionState.shortcut && /* @__PURE__ */ jsxRuntime.jsx(
      ui.Hotkeys,
      {
        fontSize: 1,
        style: { marginTop: -4, marginBottom: -4 },
        keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
      }
    )
  ] }), [firstActionState]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
    __internal_tasks && __internal_tasks.footerAction,
    firstActionState && /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 200, children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        "data-testid": `action-${firstActionState.label}`,
        disabled: disabled || !!firstActionState.disabled,
        icon: firstActionState.icon,
        onClick: firstActionState.onHandle,
        ref: setButtonElement,
        size: "large",
        text: firstActionState.label,
        tone: firstActionState.tone || "primary"
      }
    ) }) }) }),
    showMenu && menuActionStates.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ActionMenuButton, { actionStates: menuActionStates, disabled }),
    firstActionState && firstActionState.dialog && /* @__PURE__ */ jsxRuntime.jsx(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement })
  ] });
}
const DocumentStatusBarActions = React.memo(function() {
  const { actions, connectionState, documentId, editState } = useDocumentPane();
  return !actions || !editState ? null : /* @__PURE__ */ jsxRuntime.jsx(
    RenderActionCollectionState,
    {
      actions,
      actionProps: editState,
      group: "default",
      children: ({ states }) => /* @__PURE__ */ jsxRuntime.jsx(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected",
          showMenu: actions.length > 1,
          states
        },
        documentId
      )
    }
  );
}), HistoryStatusBarActions = React.memo(function() {
  const { connectionState, editState, timelineStore } = useDocumentPane(), revTime = sanity.useTimelineSelector(timelineStore, (state2) => state2.revTime), revision = (revTime == null ? void 0 : revTime.id) || "", disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision, actionProps = React.useMemo(() => ({ ...editState || {}, revision }), [editState, revision]), historyActions = React.useMemo(() => [HistoryRestoreAction], []);
  return /* @__PURE__ */ jsxRuntime.jsx(
    RenderActionCollectionState,
    {
      actions: historyActions,
      actionProps,
      group: "default",
      children: ({ states }) => /* @__PURE__ */ jsxRuntime.jsx(
        DocumentStatusBarActionsInner,
        {
          disabled: connectionState !== "connected" || !!disabled,
          showMenu: !1,
          states
        }
      )
    }
  );
}), StyledMotionPath = styled__default.default(framerMotion.motion.path)`
  transform-origin: center;
`, Circle = (props) => /* @__PURE__ */ jsxRuntime.jsx(framerMotion.motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props }), Arrows = (props) => /* @__PURE__ */ jsxRuntime.jsx(
  StyledMotionPath,
  {
    fill: "none",
    d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
    ...props
  }
), Checkmark = (props) => /* @__PURE__ */ jsxRuntime.jsx(framerMotion.motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props }), rotateAnimation = styled.keyframes`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`, RotateGroup = styled__default.default.g`
  transform-origin: center;

  &[data-rotate] {
    animation: ${rotateAnimation} 1s ease-in-out infinite;
  }
`, root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: { transition: { duration: 0 } }
}, circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
}, arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
}, checkmark = {
  syncing: {
    pathLength: 0,
    transition: { duration: 0 }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
function AnimatedStatusIcon(props) {
  const { status } = props;
  return status ? /* @__PURE__ */ jsxRuntime.jsx(
    "svg",
    {
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.2",
      "data-sanity-icon": "animated-status-icon",
      children: /* @__PURE__ */ jsxRuntime.jsxs(framerMotion.motion.g, { variants: root, initial: status, animate: status, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(RotateGroup, { "data-rotate": status === "changes" ? void 0 : "", children: [
          /* @__PURE__ */ jsxRuntime.jsx(Arrows, { variants: arrows, initial: status, animate: status }),
          /* @__PURE__ */ jsxRuntime.jsx(Circle, { variants: circle, initial: status, animate: status })
        ] }),
        /* @__PURE__ */ jsxRuntime.jsx(Checkmark, { variants: checkmark, initial: status, animate: status })
      ] })
    }
  ) : null;
}
const STATUS_DICTIONARY = {
  saved: {
    i18nKey: "status-bar.document-status-pulse.status.saved.text",
    tone: "positive"
  },
  syncing: {
    i18nKey: "status-bar.document-status-pulse.status.syncing.text",
    tone: "default"
  }
}, DocumentStatusPulse = (props) => {
  const { status } = props, { t } = sanity.useTranslation(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing")
    return null;
  const currentStatus = STATUS_DICTIONARY[status];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(sanity.TextWithTone, { size: 1, tone: currentStatus.tone, children: /* @__PURE__ */ jsxRuntime.jsx(AnimatedStatusIcon, { status }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t(currentStatus.i18nKey) })
  ] });
}, SYNCING_TIMEOUT = 1e3, SAVED_TIMEOUT = 3e3;
function DocumentStatusLine({ singleLine }) {
  const { documentId, documentType, editState, value } = useDocumentPane(), [status, setStatus] = React.useState(null), syncState = sanity.useSyncState(documentId, documentType), lastUpdated = value == null ? void 0 : value._updatedAt;
  return React.useEffect(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]), React.useLayoutEffect(() => {
    setStatus(null);
  }, [documentId]), React.useLayoutEffect(() => {
    syncState.isSyncing && setStatus("syncing");
  }, [syncState.isSyncing, lastUpdated]), status ? /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusPulse, { status: status || void 0 }) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(sanity.DocumentStatus, { absoluteDate: !0, draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
      placement: "top",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(sanity.DocumentStatusIndicator, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }),
        /* @__PURE__ */ jsxRuntime.jsx(
          sanity.DocumentStatus,
          {
            draft: editState == null ? void 0 : editState.draft,
            published: editState == null ? void 0 : editState.published,
            singleLine
          }
        )
      ] })
    }
  );
}
function useResizeObserver({
  element,
  onResize
}) {
  React.useLayoutEffect(() => (element && sanity.resizeObserver.observe(element, onResize), () => {
    element && sanity.resizeObserver.unobserve(element);
  }), [element, onResize]);
}
const CONTAINER_BREAKPOINT = 480;
function DocumentStatusBar(props) {
  const { actionsBoxRef } = props, { editState, timelineStore } = useDocumentPane(), showingRevision = sanity.useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), [collapsed, setCollapsed] = React.useState(null), [rootElement, setRootElement] = React.useState(null), handleResize = React.useCallback((event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, []);
  useResizeObserver({ element: rootElement, onResize: handleResize });
  const shouldRender = (editState == null ? void 0 : editState.ready) && typeof collapsed == "boolean";
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", ref: setRootElement, sizing: "border", children: shouldRender && /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: "stretch",
      gap: 1,
      justify: "space-between",
      paddingY: 2,
      paddingLeft: 4,
      paddingRight: 3,
      children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusLine, { singleLine: !collapsed }),
            /* @__PURE__ */ jsxRuntime.jsx(SpacerButton, { size: "large" })
          ] }),
          /* @__PURE__ */ jsxRuntime.jsx(DocumentBadges, {})
        ] }),
        /* @__PURE__ */ jsxRuntime.jsxs(
          ui.Flex,
          {
            align: "flex-start",
            justify: "flex-end",
            ref: actionsBoxRef,
            style: { flexShrink: 0, marginLeft: "auto" },
            children: [
              /* @__PURE__ */ jsxRuntime.jsx(SpacerButton, { size: "large" }),
              showingRevision ? /* @__PURE__ */ jsxRuntime.jsx(HistoryStatusBarActions, {}) : /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusBarActions, {})
            ]
          }
        )
      ]
    }
  ) });
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    as = "div",
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props, activeAction = states[activeIndex], handleKeyDown = React.useCallback(
    (event) => {
      const matchingStates = states.filter(
        (state2) => state2.shortcut && isHotkey__default.default(state2.shortcut, event)
      ), matchingState = matchingStates[0];
      if (matchingStates.length > 1 && console.warn(
        `Keyboard shortcut conflict: More than one document action matches the shortcut "${matchingState.shortcut}"`
      ), matchingState && !matchingState.disabled && matchingState.onHandle) {
        event.preventDefault(), matchingState.onHandle(), onActionStart(states.indexOf(matchingState));
        return;
      }
      onKeyDown && onKeyDown(event);
    },
    [onActionStart, onKeyDown, states]
  );
  return React.createElement(
    as,
    {
      id,
      onKeyDown: handleKeyDown,
      tabIndex: -1,
      ...rest,
      ref: rootRef
    },
    [
      children,
      activeAction && activeAction.dialog && /* @__PURE__ */ jsxRuntime.jsx(sanity.LegacyLayerProvider, { zOffset: "paneFooter", children: /* @__PURE__ */ jsxRuntime.jsx(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) })
    ]
  );
}
const DocumentActionShortcuts = React__namespace.memo(
  (props) => {
    const { actionsBoxElement, as = "div", children, ...rest } = props, { actions, editState } = useDocumentPane(), [activeIndex, setActiveIndex] = React.useState(-1), onActionStart = React.useCallback((idx) => {
      setActiveIndex(idx);
    }, []), actionProps = React.useMemo(
      () => editState && {
        ...editState,
        // @todo: what to call here?
        onComplete: () => {
        },
        // @todo: get revision string
        revision: void 0
      },
      [editState]
    );
    return !actionProps || !actions ? null : /* @__PURE__ */ jsxRuntime.jsx(RenderActionCollectionState, { actionProps, actions, children: ({ states }) => /* @__PURE__ */ jsxRuntime.jsx(
      KeyboardShortcutResponder,
      {
        ...rest,
        activeIndex,
        actionsBoxElement,
        as,
        onActionStart,
        states,
        children
      }
    ) });
  }
);
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
function getInspectorItems({
  currentInspector,
  hasValue,
  inspectors: inspectors2,
  inspectorMenuItems
}) {
  return inspectors2.map((inspector, index) => {
    var _a;
    const menuItem = inspectorMenuItems[index];
    return !menuItem || menuItem.hidden ? null : {
      action: `${INSPECT_ACTION_PREFIX}${inspector.name}`,
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      isDisabled: !hasValue,
      selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name,
      shortcut: (_a = menuItem.hotkeys) == null ? void 0 : _a.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem({ hasValue, t }) {
  return {
    action: "inspect",
    group: "inspectors",
    title: t("document-inspector.menu-item.title"),
    icon: icons.JsonIcon,
    isDisabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getProductionPreviewItem({ previewUrl, t }) {
  return previewUrl ? {
    action: "production-preview",
    group: "links",
    title: t("production-preview.menu-item.title"),
    icon: icons.EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  } : null;
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params), items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
const isSanityDocument = (value) => sanity.isRecord(value) && typeof value._id == "string" && typeof value._type == "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = React.useState(void 0), [error, setError] = React.useState(null), { resolveProductionUrl } = sanity.useSource().document, value$ = reactRx.useAsObservable(value);
  if (error)
    throw error;
  return React.useEffect(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      operators.debounceTime(500),
      operators.switchMap(
        (document2) => isSanityDocument(document2) ? rxjs.from(resolveProductionUrl({ document: document2 })) : rxjs.of(void 0)
      ),
      operators.catchError((e) => {
        const message = sanity.isRecord(e) && typeof e.message == "string" ? e.message : "Unknown error";
        throw new Error(`An error was thrown while trying to get your preview url: ${message}`);
      })
    ).subscribe({
      next: setPreviewUrl,
      error: setError
    });
  }, [resolveProductionUrl, value$]), previewUrl;
}
function DocumentLayoutError(props) {
  const { documentType, value, currentMinWidth, paneKey, minWidth } = props, { t } = sanity.useTranslation();
  return /* @__PURE__ */ jsxRuntime.jsx(
    ErrorPane,
    {
      currentMinWidth,
      flex: 2.5,
      minWidth,
      paneKey,
      title: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-unknown-type.title",
          values: { documentType }
        }
      ),
      tone: "caution",
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
        documentType && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: /* @__PURE__ */ jsxRuntime.jsx(
          sanity.Translate,
          {
            t,
            i18nKey: "panes.document-pane.document-unknown-type.text",
            values: { documentType }
          }
        ) }),
        !documentType && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }),
        sanity.isDev && value && /* eslint-disable i18next/no-literal-string */
        /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: "Here is the JSON representation of the document:" }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })
        ] })
      ] })
    }
  );
}
const EMPTY_ARRAY$7 = [], DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
], StyledChangeConnectorRoot = styled__default.default(sanity.ChangeConnectorRoot)`
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 0;
`;
function DocumentLayout() {
  const {
    changesOpen,
    documentId,
    documentType,
    fieldActions,
    inspectOpen,
    inspector,
    inspectors: inspectors2,
    onFocus,
    onHistoryOpen,
    onMenuAction,
    onPathOpen,
    paneKey,
    schemaType,
    value
  } = useDocumentPane(), { features } = useStructureTool(), { t } = reactI18next.useTranslation(structureLocaleNamespace), { collapsed: layoutCollapsed } = usePaneLayout(), zOffsets = sanity.useZIndex(), previewUrl = usePreviewUrl(value), [rootElement, setRootElement] = React.useState(null), [footerElement, setFooterElement] = React.useState(null), [headerElement, setHeaderElement] = React.useState(null), [actionsBoxElement, setActionsBoxElement] = React.useState(null), [documentPanelPortalElement, setDocumentPanelPortalElement] = React.useState(
    null
  ), [inspectorMenuItems, setInspectorMenuItems] = React.useState([]), [rootFieldActionNodes, setRootFieldActionNodes] = React.useState([]), footerRect = ui.useElementRect(footerElement), headerRect = ui.useElementRect(headerElement), footerHeight = footerRect == null ? void 0 : footerRect.height, headerHeight = headerRect == null ? void 0 : headerRect.height, currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), currentInspector = React.useMemo(
    () => inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === (inspector == null ? void 0 : inspector.name)),
    [inspectors2, inspector == null ? void 0 : inspector.name]
  ), hasValue = !!value, menuItems = React.useMemo(
    () => getMenuItems({
      currentInspector,
      features,
      hasValue,
      inspectorMenuItems,
      inspectors: inspectors2,
      previewUrl,
      t
    }),
    [currentInspector, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]
  ), handleKeyUp = React.useCallback(
    (event) => {
      for (const item of menuItems)
        if (item.shortcut && isHotkey__default.default(item.shortcut, event)) {
          event.preventDefault(), event.stopPropagation(), onMenuAction(item);
          return;
        }
    },
    [onMenuAction, menuItems]
  ), onConnectorSetFocus = React.useCallback(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onPathOpen, onFocus]
  );
  return schemaType ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    inspectors2.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(
      DocumentInspectorMenuItemsResolver,
      {
        documentId,
        documentType,
        inspectors: inspectors2,
        onMenuItems: setInspectorMenuItems
      }
    ),
    fieldActions.length > 0 && schemaType && /* @__PURE__ */ jsxRuntime.jsx(
      sanity.FieldActionsResolver,
      {
        actions: fieldActions,
        documentId,
        documentType,
        onActions: setRootFieldActionNodes,
        path: EMPTY_ARRAY$7,
        schemaType
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(sanity.FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$7, children: /* @__PURE__ */ jsxRuntime.jsxs(
      DocumentActionShortcuts,
      {
        actionsBoxElement,
        as: Pane,
        currentMinWidth,
        "data-testid": "document-pane",
        flex: 2.5,
        id: paneKey,
        minWidth,
        onKeyUp: handleKeyUp,
        rootRef: setRootElement,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(DocumentPanelHeader, { ref: setHeaderElement, menuItems }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: /* @__PURE__ */ jsxRuntime.jsx(
            StyledChangeConnectorRoot,
            {
              "data-testid": "change-connector-root",
              isReviewChangesOpen: changesOpen,
              onOpenReviewChanges: onHistoryOpen,
              onSetFocus: onConnectorSetFocus,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                DocumentPanel,
                {
                  footerHeight: footerHeight || null,
                  headerHeight: headerHeight || null,
                  isInspectOpen: inspectOpen,
                  rootElement,
                  setDocumentPanelPortalElement
                }
              )
            }
          ) }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            ui.PortalProvider,
            {
              __unstable_elements: { [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement },
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: /* @__PURE__ */ jsxRuntime.jsx(PaneFooter, { ref: setFooterElement, children: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement }) }) }) })
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(DocumentOperationResults, {})
        ]
      }
    ) })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    DocumentLayoutError,
    {
      currentMinWidth,
      documentType,
      minWidth,
      paneKey,
      value
    }
  );
}
function pick(plugin) {
  var _a, _b;
  return (_b = (_a = plugin.document) == null ? void 0 : _a.components) == null ? void 0 : _b.unstable_layout;
}
function useDocumentLayoutComponent() {
  return sanity.useMiddlewareComponents({
    pick,
    defaultComponent: DocumentLayout
  });
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {}, structureNodeTemplate = opts.templateName;
  opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate && console.warn(
    `Conflicting templates: URL says "${opts.urlTemplate}", structure node says "${structureNodeTemplate}". Using "${structureNodeTemplate}".`
  );
  const template2 = structureNodeTemplate || opts.urlTemplate, typeTemplates = templates.filter((t) => t.schemaType === opts.documentType), templateParams = {
    ...opts.templateParams,
    ...typeof payload == "object" ? payload || {} : {}
  };
  let templateName = template2;
  return !template2 && typeTemplates.length === 1 && (templateName = typeTemplates[0].id), { templateName, templateParams };
}
const DocumentPaneProvider = React.memo((props) => {
  const { children, index, pane, paneKey, onFocusPath } = props, schema2 = sanity.useSchema(), templates = sanity.useTemplates(), {
    __internal_tasks,
    document: {
      actions: documentActions2,
      badges: documentBadges2,
      unstable_fieldActions: fieldActionsResolver,
      unstable_languageFilter: languageFilterResolver,
      inspectors: inspectorsResolver
    }
  } = sanity.useSource(), presenceStore = sanity.usePresenceStore(), paneRouter = usePaneRouter(), setPaneParams = paneRouter.setParams, { features } = useStructureTool(), { push: pushToast } = ui.useToast(), {
    options,
    menuItemGroups = DEFAULT_MENU_ITEM_GROUPS,
    title = null,
    views: viewsProp = []
  } = pane, paneOptions = sanity.useUnique(options), documentIdRaw = paneOptions.id, documentId = sanity.getPublishedId(documentIdRaw), documentType = options.type, params = sanity.useUnique(paneRouter.params) || EMPTY_PARAMS$2, panePayload = sanity.useUnique(paneRouter.payload), { templateName, templateParams } = React.useMemo(
    () => getInitialValueTemplateOpts(templates, {
      documentType,
      templateName: paneOptions.template,
      templateParams: paneOptions.templateParameters,
      panePayload,
      urlTemplate: params.template
    }),
    [documentType, paneOptions, params, panePayload, templates]
  ), initialValueRaw = sanity.useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  }), initialValue = sanity.useUnique(initialValueRaw), { patch } = sanity.useDocumentOperation(documentId, documentType), editState = sanity.useEditState(documentId, documentType), { validation: validationRaw } = sanity.useValidationStatus(documentId, documentType), connectionState = sanity.useConnectionState(documentId, documentType), schemaType = schema2.get(documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value, [isDeleting, setIsDeleting] = React.useState(!1), actions = React.useMemo(
    () => documentActions2({ schemaType: documentType, documentId }),
    [documentActions2, documentId, documentType]
  ), badges = React.useMemo(
    () => documentBadges2({ schemaType: documentType, documentId }),
    [documentBadges2, documentId, documentType]
  ), languageFilter = React.useMemo(
    () => languageFilterResolver({ schemaType: documentType, documentId }),
    [documentId, documentType, languageFilterResolver]
  ), validation = sanity.useUnique(validationRaw), views2 = sanity.useUnique(viewsProp), [focusPath, setFocusPath] = React.useState(
    () => params.path ? PathUtils.fromString(params.path) : sanity.EMPTY_ARRAY
  ), focusPathRef = React.useRef(focusPath), openPathRef = React.useRef([]), activeViewId = params.view || views2[0] && views2[0].id || null, [timelineMode, setTimelineMode] = React.useState("closed"), [timelineError, setTimelineError] = React.useState(null), timelineStore = sanity.useTimelineStore({
    documentId,
    documentType,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  }), onOlderRevision = sanity.useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), revTime = sanity.useTimelineSelector(timelineStore, (state2) => state2.revTime), sinceAttributes = sanity.useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes), timelineDisplayed = sanity.useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed), timelineReady = sanity.useTimelineSelector(timelineStore, (state2) => state2.timelineReady), isPristine = sanity.useTimelineSelector(timelineStore, (state2) => state2.isPristine), isDeleted = React.useMemo(() => timelineReady ? !(editState != null && editState.draft) && !(editState != null && editState.published) && !isPristine : !1, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]), previewUrl = usePreviewUrl(value), [presence, setPresence] = React.useState([]);
  React.useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors2 = React.useMemo(
    () => inspectorsResolver({ documentId, documentType }),
    [documentId, documentType, inspectorsResolver]
  ), [inspectorName, setInspectorName] = React.useState(() => params.inspect || null), inspectParamRef = React.useRef(params.inspect);
  React.useEffect(() => {
    inspectParamRef.current !== params.inspect && (inspectParamRef.current = params.inspect, setInspectorName(params.inspect || null));
  }, [params.inspect]);
  const currentInspector = inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === inspectorName), resolvedChangesInspector = inspectors2.find((i) => i.name === HISTORY_INSPECTOR_NAME), changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME, { t } = sanity.useTranslation(structureLocaleNamespace), inspectOpen = params.inspect === "on", compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null, fieldActions = React.useMemo(
    () => schemaType ? fieldActionsResolver({ documentId, documentType, schemaType }) : [],
    [documentId, documentType, fieldActionsResolver, schemaType]
  ), ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError), displayed = React.useMemo(
    () => onOlderRevision ? timelineDisplayed || { _id: value._id, _type: value._type } : value,
    [onOlderRevision, timelineDisplayed, value]
  ), setTimelineRange = React.useCallback(
    (newSince, newRev) => {
      setPaneParams({
        ...params,
        since: newSince,
        rev: newRev || void 0
      });
    },
    [params, setPaneParams]
  ), patchRef = React.useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(sanity.toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = React.useCallback((event) => patchRef.current(event), []), closeInspector = React.useCallback(
    (closeInspectorName) => {
      var _a, _b, _c, _d;
      const inspector = closeInspectorName && inspectors2.find((i) => i.name === closeInspectorName);
      if (closeInspectorName && !inspector) {
        console.warn(`No inspector named "${closeInspectorName}"`);
        return;
      }
      if (currentInspector) {
        if (inspector) {
          const result = (_b = (_a = inspector.onClose) == null ? void 0 : _a.call(inspector, { params })) != null ? _b : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
          return;
        }
        if (currentInspector) {
          const result = (_d = (_c = currentInspector.onClose) == null ? void 0 : _c.call(currentInspector, { params })) != null ? _d : { params };
          setInspectorName(null), inspectParamRef.current = void 0, setPaneParams({ ...result.params, inspect: void 0 });
        }
      }
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), openInspector = React.useCallback(
    (nextInspectorName, paneParams) => {
      var _a, _b, _c, _d;
      const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
      if (!nextInspector) {
        console.warn(`No inspector named "${nextInspectorName}"`);
        return;
      }
      if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
        setPaneParams({ ...params, ...paneParams, inspect: nextInspector.name });
        return;
      }
      let currentParams = params;
      currentInspector && (currentParams = ((_b = (_a = nextInspector.onClose) == null ? void 0 : _a.call(nextInspector, { params: currentParams })) != null ? _b : {
        params: currentParams
      }).params);
      const result = (_d = (_c = nextInspector.onOpen) == null ? void 0 : _c.call(nextInspector, { params: currentParams })) != null ? _d : { params: currentParams };
      setInspectorName(nextInspector.name), inspectParamRef.current = nextInspector.name, setPaneParams({ ...result.params, ...paneParams, inspect: nextInspector.name });
    },
    [currentInspector, inspectors2, params, setPaneParams]
  ), handleHistoryClose = React.useCallback(() => {
    resolvedChangesInspector && closeInspector(resolvedChangesInspector.name);
  }, [closeInspector, resolvedChangesInspector]), handleHistoryOpen = React.useCallback(() => {
    features.reviewChanges && resolvedChangesInspector && openInspector(resolvedChangesInspector.name);
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]), handlePaneClose = React.useCallback(() => paneRouter.closeCurrent(), [paneRouter]), handlePaneSplit = React.useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]), toggleLegacyInspect = React.useCallback(
    (toggle = !inspectOpen) => {
      setPaneParams(toggle ? { ...params, inspect: "on" } : omit__default.default(params, "inspect"));
    },
    [inspectOpen, params, setPaneParams]
  ), handleMenuAction = React.useCallback(
    (item) => {
      if (item.action === "production-preview" && previewUrl)
        return window.open(previewUrl), !0;
      if (item.action === "inspect")
        return toggleLegacyInspect(!0), !0;
      if (item.action === "reviewChanges")
        return handleHistoryOpen(), !0;
      if (typeof item.action == "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
        const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length), nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
        if (nextInspector)
          return nextInspector.name === inspectorName ? closeInspector(nextInspector.name) : openInspector(nextInspector.name), !0;
      }
      return !1;
    },
    [
      closeInspector,
      handleHistoryOpen,
      inspectorName,
      inspectors2,
      openInspector,
      previewUrl,
      toggleLegacyInspect
    ]
  ), handleLegacyInspectClose = React.useCallback(
    () => toggleLegacyInspect(!1),
    [toggleLegacyInspect]
  ), [openPath, onSetOpenPath] = React.useState([]), [fieldGroupState, onSetFieldGroupState] = React.useState(), [collapsedPaths, onSetCollapsedPath] = React.useState(), [collapsedFieldSets, onSetCollapsedFieldSets] = React.useState(), handleOnSetCollapsedPath = React.useCallback((path, collapsed) => {
    onSetCollapsedPath((prevState) => sanity.setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = React.useCallback((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => sanity.setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = React.useCallback(
    (path, groupName) => onSetFieldGroupState((prevState) => sanity.setAtPath(prevState, path, groupName)),
    []
  ), requiredPermission = value._createdAt ? "update" : "create", liveEdit = !!(schemaType != null && schemaType.liveEdit), docId = value._id ? value._id : "dummy-id", docPermissionsInput = React.useMemo(() => ({
    ...value,
    _id: liveEdit ? sanity.getPublishedId(docId) : sanity.getDraftId(docId)
  }), [liveEdit, value, docId]), [permissions, isPermissionsLoading] = sanity.useDocumentValuePermissions({
    document: docPermissionsInput,
    permission: requiredPermission
  }), isNonExistent = !(value != null && value._id), readOnly = React.useMemo(() => {
    var _a;
    const hasNoPermission = !isPermissionsLoading && !(permissions != null && permissions.granted), updateActionDisabled = !_internal.isActionEnabled(schemaType, "update"), createActionDisabled = isNonExistent && !_internal.isActionEnabled(schemaType, "create"), reconnecting = connectionState === "reconnecting", isLocked = (_a = editState.transactionSyncLock) == null ? void 0 : _a.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [
    connectionState,
    editState.transactionSyncLock,
    isNonExistent,
    isDeleted,
    isDeleting,
    isPermissionsLoading,
    permissions == null ? void 0 : permissions.granted,
    ready,
    revTime,
    schemaType
  ]), formState = sanity.useFormState(schemaType, {
    value: displayed,
    readOnly,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets,
    fieldGroupState,
    changesOpen
  }), formStateRef = React.useRef(formState);
  formStateRef.current = formState;
  const setOpenPath = React.useCallback(
    (path) => {
      sanity.getExpandOperations(formStateRef.current, path).forEach((op) => {
        op.type === "expandPath" && onSetCollapsedPath((prevState) => sanity.setAtPath(prevState, op.path, !1)), op.type === "expandFieldSet" && onSetCollapsedFieldSets((prevState) => sanity.setAtPath(prevState, op.path, !1)), op.type === "setSelectedGroup" && onSetFieldGroupState((prevState) => sanity.setAtPath(prevState, op.path, op.groupName));
      }), onSetOpenPath(path);
    },
    [formStateRef]
  ), handleFocus = React.useCallback(
    (nextFocusPath) => {
      deepEquals__default.default(focusPathRef.current, nextFocusPath) || (setFocusPath(nextFocusPath), focusPathRef.current = nextFocusPath, openPathRef.current = nextFocusPath, onFocusPath == null || onFocusPath(nextFocusPath)), presenceStore.setLocation([
        {
          type: "document",
          documentId,
          path: nextFocusPath,
          lastActiveAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      ]);
    },
    [documentId, onFocusPath, presenceStore, setFocusPath]
  ), handleBlur = React.useCallback(
    (blurredPath) => {
      disableBlurRef.current || (setFocusPath(sanity.EMPTY_ARRAY), setOpenPath(blurredPath), focusPathRef.current !== sanity.EMPTY_ARRAY && (focusPathRef.current = sanity.EMPTY_ARRAY, onFocusPath == null || onFocusPath(sanity.EMPTY_ARRAY)));
    },
    [onFocusPath, setOpenPath, setFocusPath]
  ), documentPane = React.useMemo(
    () => ({
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      inspector: currentInspector || null,
      inspectors: inspectors2,
      __internal_tasks,
      onBlur: handleBlur,
      onChange: handleChange,
      onFocus: handleFocus,
      onPathOpen: setOpenPath,
      onHistoryClose: handleHistoryClose,
      onHistoryOpen: handleHistoryOpen,
      onInspectClose: handleLegacyInspectClose,
      onMenuAction: handleMenuAction,
      onPaneClose: handlePaneClose,
      onPaneSplit: handlePaneSplit,
      onSetActiveFieldGroup: handleSetActiveFieldGroup,
      onSetCollapsedPath: handleOnSetCollapsedPath,
      onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
      openInspector,
      index,
      inspectOpen,
      validation,
      menuItemGroups: menuItemGroups || [],
      paneKey,
      previewUrl,
      ready,
      schemaType,
      isPermissionsLoading,
      permissions,
      setTimelineMode,
      setTimelineRange,
      setIsDeleting,
      isDeleting,
      isDeleted,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      value,
      views: views2,
      formState,
      unstable_languageFilter: languageFilter
    }),
    [
      __internal_tasks,
      actions,
      activeViewId,
      badges,
      changesOpen,
      closeInspector,
      collapsedFieldSets,
      collapsedPaths,
      compareValue,
      connectionState,
      currentInspector,
      displayed,
      documentId,
      documentIdRaw,
      documentType,
      editState,
      fieldActions,
      focusPath,
      formState,
      handleBlur,
      handleChange,
      handleFocus,
      handleHistoryClose,
      handleHistoryOpen,
      handleLegacyInspectClose,
      handleMenuAction,
      handleOnSetCollapsedFieldSet,
      handleOnSetCollapsedPath,
      handlePaneClose,
      handlePaneSplit,
      handleSetActiveFieldGroup,
      index,
      inspectOpen,
      inspectors2,
      isDeleted,
      isDeleting,
      isPermissionsLoading,
      languageFilter,
      menuItemGroups,
      openInspector,
      paneKey,
      permissions,
      previewUrl,
      ready,
      schemaType,
      setOpenPath,
      setTimelineRange,
      timelineError,
      timelineMode,
      timelineStore,
      title,
      validation,
      value,
      views2
    ]
  );
  React.useEffect(() => {
    connectionState === "reconnecting" && pushToast({
      id: "sanity/structure/reconnecting",
      status: "warning",
      title: t("panes.document-pane-provider.reconnecting.title")
    });
  }, [connectionState, pushToast, t]);
  const disableBlurRef = React.useRef(!1);
  return React.useEffect(() => {
    var _a;
    if (ready && params.path) {
      const { path, ...restParams } = params, pathFromUrl = PathUtils.resolveKeyedPath((_a = formStateRef.current) == null ? void 0 : _a.value, PathUtils.fromString(path));
      disableBlurRef.current = !0, setFocusPath(pathFromUrl), deepEquals__default.default(openPathRef.current, pathFromUrl) || (openPathRef.current = pathFromUrl, setOpenPath(pathFromUrl)), deepEquals__default.default(focusPathRef.current, pathFromUrl) || (focusPathRef.current = pathFromUrl, onFocusPath == null || onFocusPath(pathFromUrl));
      const timeout = setTimeout(() => {
        disableBlurRef.current = !1;
      }, 0);
      return paneRouter.setParams(restParams), () => clearTimeout(timeout);
    }
  }, [params, documentId, onFocusPath, setOpenPath, ready, paneRouter]), /* @__PURE__ */ jsxRuntime.jsx(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
const DocumentPane = React.memo(function(props) {
  const { name: parentSourceName } = sanity.useSource();
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.SourceProvider, { name: props.pane.source || parentSourceName, children: /* @__PURE__ */ jsxRuntime.jsx(DocumentPaneInner, { ...props }) });
});
function DocumentPaneInner(props) {
  var _a;
  const { pane, paneKey } = props, { resolveNewDocumentOptions } = sanity.useSource().document, paneRouter = usePaneRouter(), options = usePaneOptions(pane.options, paneRouter.params), { documentType, isLoaded: isDocumentLoaded } = sanity.useDocumentType(options.id, options.type), DocumentLayout2 = useDocumentLayoutComponent(), templateItems = React.useMemo(() => resolveNewDocumentOptions({
    type: "document",
    documentId: options.id,
    schemaType: options.type
  }), [options.id, options.type, resolveNewDocumentOptions]), [templatePermissions, isTemplatePermissionsLoading] = sanity.useTemplatePermissions({
    templateItems
  }), isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading, providerProps = React.useMemo(() => isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props, [props, documentType, isLoaded, options]), { ReferenceChildLink: ReferenceChildLink2, handleEditReference, groupIndex, routerPanesState } = paneRouter, childParams = ((_a = routerPanesState[groupIndex + 1]) == null ? void 0 : _a[0].params) || {}, routerPanesStateLength = routerPanesState.length, { parentRefPath } = childParams, activePath = React.useMemo(() => parentRefPath ? {
    path: PathUtils.fromString(parentRefPath),
    state: (
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    )
  } : { path: [], state: "none" }, [parentRefPath, groupIndex, routerPanesStateLength]), { t } = sanity.useTranslation(structureLocaleNamespace);
  return options.type === "*" && !isLoaded ? /* @__PURE__ */ jsxRuntime.jsx(
    LoadingPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.loading")
    }
  ) : documentType ? /* @__PURE__ */ jsxRuntime.jsx(
    DocumentPaneProvider,
    {
      ...providerProps,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.ReferenceInputOptionsProvider,
        {
          EditReferenceLinkComponent: ReferenceChildLink2,
          onEditReference: handleEditReference,
          initialValueTemplateItems: templatePermissions,
          activePath,
          children: /* @__PURE__ */ jsxRuntime.jsx(DocumentLayout2, { documentId: options.id, documentType: options.type })
        }
      )
    },
    `${documentType}-${options.id}`
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    ErrorPane,
    {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: t("panes.document-pane.document-not-found.title"),
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.Translate,
        {
          t,
          i18nKey: "panes.document-pane.document-not-found.text",
          values: { id: options.id }
        }
      ) }) })
    }
  );
}
function usePaneOptions(options, params = {}) {
  const templates = sanity.useTemplates();
  return React.useMemo(() => {
    if (options.type && options.type !== "*")
      return options;
    const templateName = options.template || params.template, template2 = templateName ? templates.find((t) => t.id === templateName) : void 0, documentType = template2 == null ? void 0 : template2.schemaType;
    return documentType ? { ...options, type: documentType } : options;
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: { ...options, type: documentType }
    }
  };
}
const PARTIAL_PAGE_LIMIT = 100, FULL_LIST_LIMIT = 2e3, DEFAULT_ORDERING = { by: [{ field: "_updatedAt", direction: "desc" }] }, EMPTY_RECORD = {}, RootBox = styled__default.default(ui.Box)`
  position: relative;
`, CommandListBox = styled__default.default(ui.Box)`
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
`, SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const { layout } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: SKELETON_ITEMS.map((num) => /* @__PURE__ */ jsxRuntime.jsx(sanity.SanityDefaultPreview, { isPlaceholder: !0, layout }, num)) });
}
function DocumentListPaneContent(props) {
  const {
    childItemId,
    error,
    filterIsSimpleTypeConstraint,
    hasMaxItems,
    hasSearchQuery,
    isActive,
    isLazyLoading,
    isLoading,
    items,
    layout,
    loadingVariant,
    onListChange,
    onRetry,
    paneTitle,
    searchInputElement,
    showIcons
  } = props, schema2 = sanity.useSchema(), { collapsed: layoutCollapsed } = usePaneLayout(), { collapsed, index } = usePane(), [shouldRender, setShouldRender] = React.useState(!1), { t } = sanity.useTranslation(structureLocaleNamespace), handleEndReached = React.useCallback(() => {
    isLoading || isLazyLoading || !shouldRender || onListChange();
  }, [isLazyLoading, isLoading, onListChange, shouldRender]);
  React.useEffect(() => {
    if (collapsed)
      return;
    const timer = setTimeout(() => {
      setShouldRender(!0);
    }, 0);
    return () => {
      clearTimeout(timer);
    };
  }, [collapsed, items]);
  const renderItem2 = React.useCallback(
    (item, { activeIndex }) => {
      const publishedId = sanity.getPublishedId(item._id), isSelected = childItemId === publishedId, pressed = !isActive && isSelected, selected = isActive && isSelected, isLastItem = activeIndex === items.length - 1, showSpinner = isLastItem && isLazyLoading, showMaxItemsMessage = isLastItem && hasMaxItems;
      return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          PaneItem,
          {
            icon: showIcons === !1 ? !1 : void 0,
            id: publishedId,
            layout,
            marginBottom: 1,
            pressed,
            schemaType: schema2.get(item._type),
            selected,
            value: item
          }
        ),
        showSpinner && /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, {}),
        showMaxItemsMessage && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginY: 1, paddingX: 3, paddingY: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: t("panes.document-list-pane.max-items.text", { limit: FULL_LIST_LIMIT }) }) })
      ] });
    },
    [childItemId, isActive, items.length, layout, schema2, showIcons, hasMaxItems, isLazyLoading, t]
  ), noDocumentsContent = React.useMemo(() => hasSearchQuery ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, children: t("panes.document-list-pane.no-documents.text") }) }) }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 4, paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, children: t(filterIsSimpleTypeConstraint ? "panes.document-list-pane.no-documents-of-type.text" : "panes.document-list-pane.no-matching-documents.text") }) }) }) }), [filterIsSimpleTypeConstraint, hasSearchQuery, t]), mainContent = React.useMemo(() => {
    if (!shouldRender)
      return null;
    if (error)
      return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { paddingX: 4, paddingY: 5, space: 4, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Heading, { as: "h3", children: t("panes.document-list-pane.error.title") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: /* @__PURE__ */ jsxRuntime.jsx(
          sanity.Translate,
          {
            t,
            i18nKey: "panes.document-list-pane.error.text",
            values: { error: error.message },
            components: { Code: ({ children }) => /* @__PURE__ */ jsxRuntime.jsx("code", { children }) }
          }
        ) }),
        onRetry && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            icon: icons.SyncIcon,
            onClick: onRetry,
            text: t("panes.document-list-pane.error.retry-button.text"),
            tone: "primary"
          }
        ) })
      ] }) }) });
    if (!isLoading && items.length === 0)
      return noDocumentsContent;
    if (loadingVariant === "initial" && isLoading)
      return /* @__PURE__ */ jsxRuntime.jsx(Delay, { ms: 300, children: /* @__PURE__ */ jsxRuntime.jsx(LoadingView, { layout }) });
    if (loadingVariant === "spinner" && isLoading)
      return null;
    const key = `${index}-${collapsed}`;
    return /* @__PURE__ */ jsxRuntime.jsx(RootBox, { overflow: "hidden", height: "fill", children: /* @__PURE__ */ jsxRuntime.jsx(CommandListBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.CommandList,
      {
        activeItemDataAttr: "data-hovered",
        ariaLabel: paneTitle,
        canReceiveFocus: !0,
        inputElement: searchInputElement,
        itemHeight: 51,
        items,
        onEndReached: handleEndReached,
        onlyShowSelectionWhenActive: !0,
        overscan: 10,
        paddingBottom: 1,
        paddingX: 3,
        renderItem: renderItem2,
        wrapAround: !1
      },
      key
    ) }) });
  }, [
    collapsed,
    error,
    handleEndReached,
    index,
    isLoading,
    items,
    layout,
    loadingVariant,
    // noDocumentsContent,
    onRetry,
    renderItem2,
    searchInputElement,
    shouldRender
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(PaneContent, { overflow: layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto", children: mainContent });
}
const DocumentListPaneHeader = React.memo(
  ({
    contentAfter,
    index,
    initialValueTemplates = [],
    menuItemGroups = [],
    menuItems = [],
    setLayout,
    setSortOrder,
    title
  }) => {
    const { features } = useStructureTool(), { collapsed, isLast } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, actionHandlers = React.useMemo(() => ({
      setLayout: ({ layout: value }) => {
        setLayout(value);
      },
      setSortOrder: (sort) => {
        setSortOrder(sort);
      }
    }), [setLayout, setSortOrder]);
    return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
      PaneHeader,
      {
        actions: /* @__PURE__ */ jsxRuntime.jsx(
          PaneHeaderActions,
          {
            initialValueTemplateItems: initialValueTemplates,
            actionHandlers,
            menuItemGroups,
            menuItems
          }
        ),
        backButton: features.backButton && index > 0 && /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            as: BackLink,
            "data-as": "a",
            icon: icons.ArrowLeftIcon,
            mode: "bleed",
            tooltipProps: { content: "Back" }
          }
        ),
        contentAfter,
        tabIndex,
        title
      }
    ) });
  }
);
DocumentListPaneHeader.displayName = "DocumentListPaneHeader";
function removePublishedWithDrafts(documents) {
  return sanity.collate(documents).map((entry) => ({
    ...entry.draft || entry.published,
    hasPublished: !!entry.published,
    hasDraft: !!entry.draft
  }));
}
const RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
function getTypeNameFromSingleTypeFilter(filter, params = {}) {
  const matches = filter.match(RE_TYPE_NAME_IN_FILTER);
  if (!matches)
    return null;
  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, "");
  if (match[0] === "$") {
    const k = match.slice(1), v = params[k];
    return typeof v == "string" ? v : null;
  }
  return match;
}
function isSimpleTypeFilter(filter) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter.trim());
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy2 = order.by.map((by) => {
    if (by.mapWith)
      return by;
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    return fieldType ? fieldExtendsType(fieldType, "datetime") ? { ...by, mapWith: "dateTime" } : fieldType.jsonType === "string" ? { ...by, mapWith: "lower" } : by : by;
  });
  return orderBy2.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy2 };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils__namespace.fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current)
      return;
    if (typeof segment == "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    if (!(types.isKeySegment(segment) || types.isIndexSegment(segment)) || current.jsonType !== "array")
      return;
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType)
      return;
    if (!types.isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType)
      return;
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type))
    return;
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  for (; current; ) {
    if (current.name === ofType || !current.type && current.jsonType === ofType)
      return !0;
    current = current.type;
  }
  return !1;
}
const IMPLICIT_SCHEMA_TYPE_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path, strict = !1) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType))
    return "";
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_SCHEMA_TYPE_FIELDS.includes(head)) {
      const errorMessage = `The current ordering config targeted the nonexistent field "${head}" on schema type "${schemaType.name}". It should be one of ${schemaType.fields.map((field) => field.name).join(", ")}`;
      if (strict)
        throw new Error(errorMessage);
      console.warn(errorMessage);
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return `${head}->{${refTypes.map((refType) => joinReferences(refType, tail)).join(",")}}`;
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail), tailWrapper = tailFields ? `{${tailFields}}` : "";
  return tail.length > 0 ? `${head}${tailWrapper}` : head;
}
function getExtendedProjection(schemaType, orderBy2, strict = !1) {
  return orderBy2.map((ordering) => joinReferences(schemaType, ordering.field.split("."), strict)).join(", ");
}
function listenSearchQuery(options) {
  const {
    client,
    schema: schema2,
    sort,
    limit,
    params,
    filter,
    searchQuery,
    staticTypeNames,
    maxFieldDepth,
    unstable_enableNewSearch
  } = options, sortBy = sort.by, extendedProjection = sort == null ? void 0 : sort.extendedProjection, events$ = rxjs.defer(() => client.listen(`*[${filter}]`, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeResult: !1,
    visibility: "query"
  })).pipe(
    rxjs.mergeMap((ev, i) => i === 0 && ev.type !== "welcome" ? rxjs.throwError(
      () => new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : rxjs.of(ev)),
    rxjs.share()
  ), [welcome$, mutationAndReconnect$] = rxjs.partition(events$, (ev) => ev.type === "welcome");
  return rxjs.merge(
    welcome$.pipe(rxjs.take(1)),
    mutationAndReconnect$.pipe(rxjs.throttleTime(1e3, rxjs.asyncScheduler, { leading: !0, trailing: !0 }))
  ).pipe(
    rxjsExhaustmapWithTrailing.exhaustMapWithTrailing((event) => (staticTypeNames ? rxjs.of(staticTypeNames) : client.observable.fetch(`array::unique(*[${filter}][]._type)`, params)).pipe(
      rxjs.mergeMap((typeNames) => {
        const types2 = _internalBrowser.getSearchableTypes(schema2).filter((type) => typeNames.includes(type.name) ? (getExtendedProjection(type, sort.by, !0), !0) : !1), search = _internalBrowser.createSearch(types2, client, {
          filter,
          params,
          unstable_enableNewSearch,
          maxDepth: maxFieldDepth
        }), doFetch = () => search({
          filter,
          query: searchQuery || "",
          types: types2
        }, {
          __unstable_extendedProjection: extendedProjection,
          comments: [`findability-source: ${searchQuery ? "list-query" : "list"}`],
          limit,
          skipSortByScore: !0,
          sort: sortBy
        }).pipe(
          rxjs.map(
            (result) => (
              // eslint-disable-next-line max-nested-callbacks
              result.hits.map(({ hit }) => hit)
            )
          )
        );
        return event.type === "mutation" && event.visibility !== "query" ? rxjs.timer(1200).pipe(rxjs.mergeMap(doFetch)) : doFetch();
      })
    ))
  );
}
const EMPTY_ARRAY$6 = [], INITIAL_STATE$1 = {
  error: null,
  onRetry: void 0,
  result: null
}, INITIAL_QUERY_RESULTS = {
  result: null,
  error: null
};
function useDocumentList(opts) {
  const { filter, params: paramsProp, sortOrder, searchQuery, apiVersion } = opts, client = sanity.useClient({
    ...sanity.DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: apiVersion || sanity.DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion
  }), { unstable_enableNewSearch = !1 } = sanity.useWorkspace().search, schema2 = sanity.useSchema(), maxFieldDepth = _internalBrowser.useSearchMaxFieldDepth(), [resultState, setResult] = React.useState(INITIAL_STATE$1), { onRetry, error, result } = resultState, documents = result == null ? void 0 : result.documents, items = React.useMemo(
    () => documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY$6,
    [documents]
  ), [isLazyLoading, setIsLazyLoading] = React.useState(!1), [hasFullList, setHasFullList] = React.useState(!1), [shouldFetchFullList, setShouldFetchFullList] = React.useState(!1), typeNameFromFilter = React.useMemo(
    () => getTypeNameFromSingleTypeFilter(filter, paramsProp),
    [filter, paramsProp]
  ), isLoading = result === null && !error, hasMaxItems = (documents == null ? void 0 : documents.length) === FULL_LIST_LIMIT, onListChange = React.useCallback(() => {
    isLoading || hasFullList || shouldFetchFullList || setShouldFetchFullList(!0);
  }, [isLoading, hasFullList, shouldFetchFullList]), handleSetResult = React.useCallback(
    (res) => {
      var _a, _b;
      if (res.error) {
        setResult(res);
        return;
      }
      const documentsLength = ((_b = (_a = res.result) == null ? void 0 : _a.documents) == null ? void 0 : _b.length) || 0;
      if (!res.error && (res == null ? void 0 : res.result) === null && shouldFetchFullList) {
        setIsLazyLoading(!0);
        return;
      }
      if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList && setHasFullList(!0), (res == null ? void 0 : res.result) === null) {
        setResult((prev) => ({ ...prev.error ? res : prev }));
        return;
      }
      setIsLazyLoading(!1), setResult(res);
    },
    [shouldFetchFullList]
  ), queryResults$ = React.useMemo(() => {
    const onRetry$ = new rxjs.Subject(), _onRetry = () => onRetry$.next();
    return listenSearchQuery({
      client,
      filter,
      limit: shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT,
      params: paramsProp,
      schema: schema2,
      searchQuery: searchQuery || "",
      sort: sortOrder || DEFAULT_ORDERING,
      staticTypeNames: typeNameFromFilter ? [typeNameFromFilter] : void 0,
      maxFieldDepth,
      unstable_enableNewSearch
    }).pipe(
      operators.map((results) => ({
        result: { documents: results },
        error: null
      })),
      operators.startWith(INITIAL_QUERY_RESULTS),
      operators.catchError((err) => err instanceof ProgressEvent ? rxjs.throwError(() => new Error("Request error")) : rxjs.throwError(() => err)),
      operators.catchError((err, caught$) => rxjs.concat(
        rxjs.of({ result: null, error: err }),
        rxjs.merge(rxjs.fromEvent(window, "online"), onRetry$).pipe(
          operators.take(1),
          operators.mergeMap(() => caught$)
        )
      )),
      operators.scan((prev, next) => ({ ...prev, ...next, onRetry: _onRetry }))
    );
  }, [
    shouldFetchFullList,
    sortOrder,
    client,
    filter,
    paramsProp,
    schema2,
    searchQuery,
    typeNameFromFilter,
    maxFieldDepth,
    unstable_enableNewSearch
  ]);
  React.useEffect(() => {
    const sub = queryResults$.subscribe(handleSetResult);
    return () => {
      sub.unsubscribe();
    };
  }, [handleSetResult, queryResults$]);
  const reset = React.useCallback(() => {
    setHasFullList(!1), setIsLazyLoading(!1), setResult(INITIAL_STATE$1), setShouldFetchFullList(!1);
  }, []);
  return React.useEffect(() => {
    reset();
  }, [reset, filter, paramsProp, sortOrder, searchQuery]), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady: !error,
    items,
    onListChange,
    onRetry
  };
}
const EMPTY_ARRAY$5 = [], rotate = styled.keyframes`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styled__default.default(icons.SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`;
function useShallowUnique(value) {
  const valueRef = React.useRef(value);
  return shallowEquals__default.default(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
const addSelectedStateToMenuItems = (options) => {
  const { menuItems, sortOrderRaw, layout } = options;
  return menuItems == null ? void 0 : menuItems.map((item) => {
    var _a, _b, _c, _d;
    return (_a = item.params) != null && _a.layout ? {
      ...item,
      selected: layout === ((_b = item.params) == null ? void 0 : _b.layout)
    } : (_c = item == null ? void 0 : item.params) != null && _c.by ? {
      ...item,
      selected: isEqual__default.default(sortOrderRaw == null ? void 0 : sortOrderRaw.by, ((_d = item == null ? void 0 : item.params) == null ? void 0 : _d.by) || EMPTY_ARRAY$5)
    } : { ...item, selected: !1 };
  });
}, DocumentListPane = React.memo(function(props) {
  const { childItemId, index, isActive, isSelected, pane, paneKey } = props, schema2 = sanity.useSchema(), { name: parentSourceName } = sanity.useSource(), {
    defaultLayout = "default",
    displayOptions,
    initialValueTemplates = EMPTY_ARRAY$5,
    menuItemGroups,
    menuItems,
    options
  } = pane, { apiVersion, defaultOrdering = EMPTY_ARRAY$5, filter } = options, params = useShallowUnique(options.params || EMPTY_RECORD), sourceName = pane.source, typeName = React.useMemo(() => getTypeNameFromSingleTypeFilter(filter, params), [filter, params]), showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== !1, [layout, setLayout] = useStructureToolSetting(
    "layout",
    typeName,
    defaultLayout
  ), { t } = sanity.useTranslation(structureLocaleNamespace), { title } = sanity.useI18nText(pane), [searchQuery, setSearchQuery] = React.useState(""), [searchInputValue, setSearchInputValue] = React.useState(""), [searchInputElement, setSearchInputElement] = React.useState(null), showSearchLoadingRef = React.useRef(!1), defaultSortOrder = React.useMemo(() => (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? { by: defaultOrdering } : DEFAULT_ORDERING, [defaultOrdering]), [sortOrderRaw, setSortOrder] = useStructureToolSetting(
    "sort-order",
    typeName,
    defaultSortOrder
  ), sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema2.get(typeName)) : sortOrderRaw, sortOrder = sanity.useUnique(sortWithOrderingFn), filterIsSimpleTypeConstraint = isSimpleTypeFilter(filter), {
    error,
    hasMaxItems,
    isLazyLoading,
    isLoading,
    isSearchReady,
    items,
    onListChange,
    onRetry
  } = useDocumentList({
    apiVersion,
    filter,
    params,
    searchQuery: searchQuery == null ? void 0 : searchQuery.trim(),
    sortOrder
  }), menuItemsWithSelectedState = React.useMemo(
    () => addSelectedStateToMenuItems({
      menuItems,
      sortOrderRaw,
      layout
    }),
    [layout, menuItems, sortOrderRaw]
  ), handleQueryChange = reactRx.useObservableCallback(
    (event$) => event$.pipe(
      rxjs.map((event) => event.target.value),
      rxjs.tap(setSearchInputValue),
      rxjs.debounce((value) => value === "" ? rxjs.of("") : rxjs.timer(300)),
      rxjs.tap(setSearchQuery)
    ),
    []
  ), handleClearSearch = React.useCallback(() => {
    setSearchQuery(""), setSearchInputValue("");
  }, []), handleSearchKeyDown = React.useCallback(
    (event) => {
      event.key === "Escape" && handleClearSearch();
    },
    [handleClearSearch]
  );
  React.useEffect(() => (showSearchLoadingRef.current === !1 && !isLoading && (showSearchLoadingRef.current = !0), () => {
    showSearchLoadingRef.current = !1;
  }), [isLoading]), React.useEffect(() => {
    handleClearSearch(), showSearchLoadingRef.current = !1;
  }, [paneKey, handleClearSearch]);
  const loadingVariant = React.useMemo(() => isLoading && items.length === 0 && showSearchLoadingRef.current ? "spinner" : "initial", [isLoading, items.length]), searchInput = /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 3, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.TextInput,
    {
      "aria-label": t("panes.document-list-pane.search-input.aria-label"),
      autoComplete: "off",
      border: !1,
      clearButton: !!searchQuery,
      disabled: !isSearchReady,
      fontSize: [2, 2, 1],
      icon: loadingVariant === "spinner" ? AnimatedSpinnerIcon : icons.SearchIcon,
      onChange: handleQueryChange,
      onClear: handleClearSearch,
      onKeyDown: handleSearchKeyDown,
      padding: 2,
      placeholder: t("panes.document-list-pane.search-input.placeholder"),
      radius: 2,
      ref: setSearchInputElement,
      spellCheck: !1,
      value: searchInputValue
    }
  ) });
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.SourceProvider, { name: sourceName || parentSourceName, children: /* @__PURE__ */ jsxRuntime.jsxs(
    Pane,
    {
      currentMaxWidth: 350,
      "data-ui": "DocumentListPane",
      id: paneKey,
      maxWidth: 640,
      minWidth: 320,
      selected: isSelected,
      children: [
        _DEBUG,
        /* @__PURE__ */ jsxRuntime.jsx(
          DocumentListPaneHeader,
          {
            contentAfter: searchInput,
            index,
            initialValueTemplates,
            menuItemGroups,
            menuItems: menuItemsWithSelectedState,
            setLayout,
            setSortOrder,
            title
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          DocumentListPaneContent,
          {
            childItemId,
            error,
            filterIsSimpleTypeConstraint,
            hasMaxItems,
            hasSearchQuery: !!searchQuery,
            isActive,
            isLazyLoading,
            isLoading,
            items,
            layout,
            loadingVariant,
            onListChange,
            onRetry,
            paneTitle: title,
            searchInputElement,
            showIcons
          },
          paneKey
        )
      ]
    }
  ) });
});
class SerializeError extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    const segment = typeof pathSegment > "u" ? "<unknown>" : `${pathSegment}`;
    this.path = (parentPath || []).concat(hint ? `${segment} (${hint})` : segment);
  }
  withHelpUrl(id) {
    return this.helpId = id, this;
  }
}
var HELP_URL = /* @__PURE__ */ ((HELP_URL2) => (HELP_URL2.ID_REQUIRED = "structure-node-id-required", HELP_URL2.TITLE_REQUIRED = "structure-title-required", HELP_URL2.FILTER_REQUIRED = "structure-filter-required", HELP_URL2.INVALID_LIST_ITEM = "structure-invalid-list-item", HELP_URL2.COMPONENT_REQUIRED = "structure-view-component-required", HELP_URL2.DOCUMENT_ID_REQUIRED = "structure-document-id-required", HELP_URL2.DOCUMENT_TYPE_REQUIRED = "structure-document-type-required", HELP_URL2.SCHEMA_TYPE_REQUIRED = "structure-schema-type-required", HELP_URL2.SCHEMA_TYPE_NOT_FOUND = "structure-schema-type-not-found", HELP_URL2.LIST_ITEMS_MUST_BE_ARRAY = "structure-list-items-must-be-array", HELP_URL2.QUERY_PROVIDED_FOR_FILTER = "structure-query-provided-for-filter", HELP_URL2.ACTION_OR_INTENT_REQUIRED = "structure-action-or-intent-required", HELP_URL2.LIST_ITEM_IDS_MUST_BE_UNIQUE = "structure-list-item-ids-must-be-unique", HELP_URL2.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE = "structure-action-and-intent-mutually-exclusive", HELP_URL2.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER = "structure-api-version-required-for-custom-filter", HELP_URL2))(HELP_URL || {});
const ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  i18n: {
    title: {
      key: "menu-items.sort-by.last-edited",
      ns: structureLocaleNamespace
    }
  },
  name: "lastEditedDesc",
  by: [{ field: "_updatedAt", direction: "desc" }]
}, ORDER_BY_CREATED_AT = {
  title: "Created",
  i18n: {
    title: {
      key: "menu-items.sort-by.created",
      ns: structureLocaleNamespace
    }
  },
  name: "lastCreatedDesc",
  by: [{ field: "_createdAt", direction: "desc" }]
}, DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT, DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
class MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({ action });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({ intent });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /**
   * Get menu item title. Note that the `i18n` configuration will take
   * precedence and this title is left here for compatibility.
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({ group });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({ params });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction(showAsAction = !0) {
    return this.clone({ showAsAction: !!showAsAction });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize(options = { path: [] }) {
    const { title, action, intent } = this.spec;
    if (!title) {
      const hint = typeof action == "string" ? `action: "${action}"` : void 0;
      throw new SerializeError(
        "`title` is required for menu item",
        options.path,
        options.index,
        hint
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent)
      throw new SerializeError(
        `\`action\` or \`intent\` required for menu item with title ${this.spec.title}`,
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    if (intent && action)
      throw new SerializeError(
        "cannot set both `action` AND `intent`",
        options.path,
        options.index,
        `"${title}"`
      ).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    return { ...this.spec, title };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new MenuItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
function getOrderingMenuItem(context, { by, title, i18n }, extendedProjection) {
  let builder = new MenuItemBuilder(context).group("sorting").title(
    context.i18n.t("default-menu-item.fallback-title", {
      // note this lives in the `studio` bundle because that one is loaded by default
      ns: "studio",
      replace: { title }
      // replaces the `{{title}}` option
    })
  ).icon(icons.SortIcon).action("setSortOrder").params({ by, extendedProjection });
  return i18n && (builder = builder.i18n(i18n)), builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const { schema: schema2 } = context, type = typeof typeName == "string" ? schema2.get(typeName) : typeName;
  return !type || !("orderings" in type) ? [] : (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map(
    (ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by))
  );
}
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({ path, index }) : item;
}
class MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context, this._id = spec ? spec.id : "", this._title = spec ? spec.title : "", this._i18n = spec ? spec.i18n : void 0;
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new MenuItemGroupBuilder(this._context, { id, title: this._title, i18n: this._i18n });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new MenuItemGroupBuilder(this._context, { title, id: this._id, i18n: this._i18n });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
   */
  i18n(i18n) {
    return new MenuItemGroupBuilder(this._context, { i18n, id: this._id, title: this._title });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this._i18n;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize(options = { path: [] }) {
    const { _id, _title, _i18n } = this;
    if (!_id)
      throw new SerializeError(
        "`id` is required for a menu item group",
        options.path,
        options.index,
        _title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!_title)
      throw new SerializeError(
        "`title` is required for a menu item group",
        options.path,
        _id
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: _id,
      title: _title,
      i18n: _i18n
    };
  }
}
const disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id != "string")
    throw new SerializeError(
      `Structure node id must be of type string, got ${typeof id}`,
      parentPath,
      pathSegment
    );
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar)
    throw new SerializeError(
      `Structure node id cannot contain character "${disallowedChar}"`,
      parentPath,
      pathSegment
    );
  if (id.startsWith("__edit__"))
    throw new SerializeError(
      "Structure node id cannot start with __edit__",
      parentPath,
      pathSegment
    );
  return id;
}
function getStructureNodeId(title, id) {
  if (id)
    return id;
  const camelCased = camelCase__default.default(title);
  return disallowedPattern.test(camelCased) ? camelCase__default.default(speakingurl__default.default(title)) : camelCased;
}
class ComponentBuilder {
  constructor(spec) {
    this.spec = { options: {}, ...spec || {} };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize(options = { path: [] }) {
    const { id, title, child, options: componentOptions, component: component2 } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!component2)
      throw new SerializeError(
        "`component` is required for `component` structure item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component: component2,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, options.path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, options.path)
      )
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new ComponentBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type", documentId = sanity.getPublishedId(id), draftId = sanity.getDraftId(id);
  return (await getClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(
    query,
    { documentId, draftId },
    { tag: "structure.resolve-type" }
  ))[0];
}
class GenericViewBuilder {
  constructor() {
    this.spec = {};
  }
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({ title, id: this.spec.id || kebabCase__default.default(title) });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize(options = { path: [] }) {
    const { id, title, icon } = this.spec;
    if (!id)
      throw new SerializeError(
        "`id` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!title)
      throw new SerializeError(
        "`title` is required for view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
}
function isSerializable(view) {
  return typeof view.serialize == "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({ path, index }) : item;
}
const isComponentSpec = (spec) => sanity.isRecord(spec) && spec.type === "component";
class ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? { ...componentOrSpec } : { options: {} };
    super(), this.spec = spec;
    const userComponent = typeof componentOrSpec == "function" ? componentOrSpec : this.spec.component;
    userComponent && (this.spec = this.component(userComponent).spec);
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({ options });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize(options = { path: [] }) {
    const base = super.serialize(options), component2 = this.spec.component;
    if (typeof component2 != "function")
      throw new SerializeError(
        "`component` is required and must be a function for `component()` view item",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    return {
      ...base,
      component: component2,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new ComponentViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
class FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super(), this.spec = { id: "editor", title: "Editor", ...spec || {} };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize(options = { path: [] }) {
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new FormViewBuilder();
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
const form = (spec) => new FormViewBuilder(spec), component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ComponentViewBuilder,
  FormViewBuilder,
  GenericViewBuilder,
  component,
  form,
  maybeSerializeView
});
const createDocumentChildResolver = ({ resolveDocumentNode, getClient }) => async (itemId, { params, path }) => {
  let type = params.type;
  const parentPath = path.slice(0, path.length - 1), currentSegment = path[path.length - 1];
  if (type || (type = await resolveTypeForDocument(getClient, itemId)), !type)
    throw new SerializeError(
      "Failed to resolve document, and no type provided in parameters.",
      parentPath,
      currentSegment
    );
  return resolveDocumentNode({ documentId: itemId, schemaType: type });
};
class DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...this.spec.options || {},
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        type: typeof documentType == "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...this.spec.options || {},
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views2) {
    return this.clone({ views: views2 });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const urlId = path[index || path.length - 1], id = this.spec.id || urlId && `${urlId}` || "", options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for document nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options || !options.id)
      throw new SerializeError(
        "document id (`id`) is required for document nodes",
        path,
        id,
        hint
      ).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    if (!options || !options.type)
      throw new SerializeError(
        "document type (`schemaType`) is required for document nodes",
        path,
        id,
        hint
      );
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map(
      (item, i) => maybeSerializeView(item, i, path)
    ), viewIds = views2.map((view) => view.id), dupes = uniq__default.default(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0)
      throw new SerializeError(
        `document node has views with duplicate IDs: ${dupes.join(",  ")}`,
        path,
        id,
        hint
      );
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views: views2
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone(withSpec = {}) {
    const builder = new DocumentBuilder(this._context), options = { ...this.spec.options || {}, ...withSpec.options || {} };
    return builder.spec = { ...this.spec, ...withSpec, options }, builder;
  }
}
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  return spec.template && (opts.template = spec.template), spec.templateParameters && (opts.templateParameters = spec.templateParameters), opts;
}
function documentFromEditor(context, spec) {
  let doc = spec != null && spec.type ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({ schemaType: spec.type })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec)
    return doc;
  const { id, type, template: template2, templateParameters } = spec.options;
  return doc = doc.id(spec.id).documentId(id), type && (doc = doc.schemaType(type)), template2 && (doc = doc.initialValueTemplate(template2, templateParameters)), spec.child && (doc = doc.child(spec.child)), doc;
}
function documentFromEditorWithInitialValue({ resolveDocumentNode, templates }, templateId, parameters) {
  const template2 = templates.find((t) => t.id === templateId);
  if (!template2)
    throw new Error(`Template with ID "${templateId}" not defined`);
  return resolveDocumentNode({ schemaType: template2.schemaType }).initialValueTemplate(
    templateId,
    parameters
  );
}
class InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({ title });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({ description });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({ parameters });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize({ path = [], index, hint } = { path: [] }) {
    const { spec, _context } = this, { templates } = _context;
    if (typeof spec.id != "string" || !spec.id)
      throw new SerializeError(
        "`id` is required for initial value template item nodes",
        path,
        index,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!spec.templateId)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const template2 = templates.find((t) => t.id === spec.templateId);
    if (!template2)
      throw new SerializeError(
        "template id (`templateId`) is required for initial value template item nodes",
        path,
        spec.id,
        hint
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template2.schemaType,
      type: "initialValueTemplateItem",
      description: spec.description || template2.description,
      title: spec.title || template2.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template2.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone(withSpec = {}) {
    const builder = new InitialValueTemplateItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec }, builder;
  }
}
function defaultInitialValueTemplateItems(context) {
  const { schema: schema2, getStructureBuilder, templates } = context, typeNames = schema2.getTypeNames();
  return templates.filter((tpl) => {
    var _a;
    return !((_a = tpl.parameters) != null && _a.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType)).map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const { schema: schema2, templates } = context;
  return templateItems.map((item) => {
    const template2 = templates.find((t) => t.id === item.templateId), title = item.title || (template2 == null ? void 0 : template2.title) || "Create", params = {};
    template2 && template2.schemaType && (params.type = template2.schemaType), item.templateId && (params.template = item.templateId);
    const intentParams = item.parameters ? [params, item.parameters] : params, schemaType = template2 && schema2.get(template2.schemaType), i18n = item.i18n || (template2 == null ? void 0 : template2.i18n);
    let builder = new MenuItemBuilder(context).title(title).icon(template2 && template2.icon || (schemaType == null ? void 0 : schemaType.icon) || icons.AddIcon).intent({ type: "create", params: intentParams });
    return i18n && (builder = builder.i18n(i18n)), builder.serialize();
  });
}
const DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent"), defaultIntentChecker = (intentName, params, { pane }) => {
  var _a, _b;
  const isEdit = intentName === "edit", isCreate = intentName === "create", typedSpec = pane, paneFilter = ((_a = typedSpec.options) == null ? void 0 : _a.filter) || "", paneParams = ((_b = typedSpec.options) == null ? void 0 : _b.params) || {}, typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams), initialValueTemplates = typedSpec.initialValueTemplates || [];
  return isCreate && params.template ? initialValueTemplates.some((tpl) => tpl.templateId === params.template) : isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
const layoutOptions = ["default", "card", "media", "detail", "block"];
function noChildResolver() {
}
const shallowIntentChecker = (intentName, params, { pane, index }) => index <= 1 && defaultIntentChecker(intentName, params, { pane, index });
class GenericListBuilder {
  constructor() {
    this.initialValueTemplatesSpecified = !1, this.spec = {};
  }
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({ defaultLayout });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({ child });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons(enabled = !0) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcons: enabled }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    return this.initialValueTemplatesSpecified = !0, this.clone({ initialValueTemplates: Array.isArray(templates) ? templates : [templates] });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id || "", path = options.path, defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout))
      throw new SerializeError(
        `\`layout\` must be one of ${layoutOptions.map((item) => `"${item}"`).join(", ")}`,
        path,
        id || options.index,
        this.spec.title
      );
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map(
      (item, i) => maybeSerializeInitialValueTemplateItem(item, i, path)
    );
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      i18n: this.spec.i18n,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map(
        (item, i) => maybeSerializeMenuItem(item, i, path)
      ),
      menuItemGroups: (this.spec.menuItemGroups || []).map(
        (item, i) => maybeSerializeMenuItemGroup(item, i, path)
      )
    };
  }
}
const validateFilter = (spec, options) => {
  var _a;
  const filter = ((_a = spec.options) == null ? void 0 : _a.filter.trim()) || "";
  if (["*", "{"].includes(filter[0]))
    throw new SerializeError(
      `\`filter\` cannot start with \`${filter[0]}\` - looks like you are providing a query, not a filter`,
      options.path,
      spec.id,
      spec.title
    ).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  return filter;
}, createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a;
  const parentItem = options.parent, template2 = (_a = options.params) != null && _a.template ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0, type = template2 ? template2.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then(
    (schemaType) => schemaType ? context.resolveDocumentNode({ schemaType, documentId: itemId }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType("")
  );
};
class DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec != null && spec.initialValueTemplates);
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, apiVersion } });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.apiVersion;
  }
  /** Set Document list filter
   * @param filter - filter
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter) {
    return this.clone({ options: { ...this.spec.options || {}, filter } });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type == "string" ? type : type.name;
    return this.clone({ schemaTypeName });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, params }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering))
      throw new Error("`defaultOrdering` must be an array of order clauses");
    return this.clone({
      options: { ...this.spec.options || { filter: "" }, defaultOrdering: ordering }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    var _a;
    return (_a = this.spec.options) == null ? void 0 : _a.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize(options = { path: [] }) {
    var _a;
    if (typeof this.spec.id != "string" || !this.spec.id)
      throw new SerializeError(
        "`id` is required for document lists",
        options.path,
        options.index,
        this.spec.title
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this.spec.options || !this.spec.options.filter)
      throw new SerializeError(
        "`filter` is required for document lists",
        options.path,
        this.spec.id,
        this.spec.title
      ).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    return ((_a = this.spec.options) == null ? void 0 : _a.filter) !== "_type == $type" && this.spec.options.filter && !this.spec.options.apiVersion && console.warn(
      `No apiVersion specified for document type list with custom filter: \`${this.spec.options.filter}\`. This will be required in the future. See %s for more info.`,
      generateHelpUrl.generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER)
    ), {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
        apiVersion: this.spec.options.apiVersion || sanity.DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, this.initialValueTemplatesSpecified || (builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec)), builder.spec.schemaTypeName || (builder.spec.schemaTypeName = inferTypeName(builder.spec)), builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
}
function inferInitialValueTemplates(context, spec) {
  const { document: document2 } = context, { schemaTypeName, options } = spec, { filter, params } = options || { filter: "", params: {} }, typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter, params)));
  if (typeNames.length !== 0)
    return typeNames.flatMap(
      (schemaType) => document2.resolveNewDocumentOptions({
        type: "structure",
        schemaType
      })
    ).map((option) => ({ ...option, icon: icons.AddIcon }));
}
function inferTypeName(spec) {
  const { options } = spec, { filter, params } = options || { filter: "", params: {} }, typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter, params = {}) {
  let typeNames = getTypeNamesFromEqualityFilter(filter, params);
  return typeNames.length === 0 && (typeNames = getTypeNamesFromInTypesFilter(filter, params)), typeNames;
}
function getTypeNamesFromEqualityFilter(filter, params = {}) {
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g, matches = [];
  let match;
  for (; (match = pattern.exec(filter)) !== null; )
    matches.push(match[1] || match[2]);
  return matches.map((candidate) => ((candidate[0] === "$" ? params[candidate.slice(1)] : candidate) || "").trim().replace(/^["']|["']$/g, "")).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter, params = {}) {
  const pattern = /\b_type\s+in\s+\[(.*?)\]/, matches = filter.match(pattern);
  return matches ? matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean) : [];
}
const getArgType = (thing) => thing instanceof ListBuilder ? "ListBuilder" : isPromise(thing) ? "Promise" : Array.isArray(thing) ? "array" : typeof thing, isListItem = (item) => item.type === "listItem", defaultCanHandleIntent = (intentName, params, context) => (context.pane.items || []).filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context), resolveChildForItem = (itemId, options) => {
  const target = (options.parent.items.filter(isListItem).find((item) => item.id === itemId) || { child: void 0 }).child;
  return !target || typeof target != "function" ? target : typeof target == "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder)
    return item.serialize({ path, index });
  const listItem = item;
  if (listItem && listItem.type === "divider")
    return item;
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem), helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError(
      `List items must be of type "listItem", got "${gotWhat}"${helpText}`,
      path,
      index
    ).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return sanity.isRecord(thing) && typeof thing.then == "function";
}
class ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({ items });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize(options = { path: [] }) {
    const id = this.spec.id;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for lists",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    const items = typeof this.spec.items > "u" ? [] : this.spec.items;
    if (!Array.isArray(items))
      throw new SerializeError(
        "`items` must be an array of items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    const path = (options.path || []).concat(id), serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path)), dupes = serializedItems.filter((val, i) => find__default.default(serializedItems, { id: val.id }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5), dupeDesc = dupes.length > 5 ? `${dupeIds.join(", ")}...` : dupeIds.join(", ");
      throw new SerializeError(
        `List items with same ID found (${dupeDesc})`,
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new ListBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
class ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({ id });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon(enabled = !0) {
    return this.clone({
      displayOptions: { ...this.spec.displayOptions || {}, showIcon: enabled }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({ child });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({ schemaType });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    return typeof schemaType == "string" ? this._context.schema.get(schemaType) : this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize(options = { path: [] }) {
    const { id, title, child } = this.spec;
    if (typeof id != "string" || !id)
      throw new SerializeError(
        "`id` is required for list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options.titleIsOptional && (typeof title != "string" || !title))
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(
        HELP_URL.TITLE_REQUIRED
      );
    let schemaType = this.spec.schemaType;
    if (typeof schemaType == "string") {
      const type = this._context.schema.get(schemaType);
      if (!type)
        throw new SerializeError(
          `Could not find type "${schemaType}" in schema`,
          options.path,
          id
        ).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      schemaType = type;
    }
    const serializeOptions = { path: options.path.concat(id), hint: "child" };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild == "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => originalChild(itemId, { ...childOptions, serializeOptions });
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new ListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
const createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType == "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({ schemaType, documentId }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
class DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec), this._context = _context, this.spec = spec || {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize(options = { path: [] }) {
    const spec = super.serialize({ ...options, titleIsOptional: !0 });
    if (!spec.schemaType)
      throw new SerializeError(
        "`schemaType` is required for document list items",
        options.path,
        options.index
      ).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return { ...spec, child, schemaType: spec.schemaType, _id: spec.id };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new DocumentListItemBuilder(this._context);
    return builder.spec = { ...this.spec, ...withSpec || {} }, builder;
  }
}
function isDocumentListItem(item) {
  return sanity.isRecord(item) && typeof item.schemaType < "u" && typeof item._id == "string";
}
class DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context), this._context = _context, this.spec = spec || {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({ child });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec), builder = new DocumentTypeListBuilder(this._context);
    return builder.spec = { ...this.spec, ...parent.getSpec(), ...withSpec || {} }, builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec), builder = new DocumentTypeListBuilder(this._context), canHandleIntent = this.spec.canHandleIntent, override = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER ? { canHandleIntent: void 0 } : {};
    return builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...withSpec || {},
      ...override
    }, builder;
  }
}
const BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a;
  return ((_a = schemaType.type) == null ? void 0 : _a.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes({ schema: schema2 }) {
  return schema2.getTypeNames().filter((n) => {
    const schemaType = schema2.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  return getDocumentTypes(context).map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const { schema: schema2 } = context, type = schema2.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase__default.default(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent, parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    return parentItem && parentItem.title && (list = list.title(parentItem.title)), list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const { schema: schema2, resolveDocumentNode } = context, schemaType = typeof typeNameOrSpec == "string" ? typeNameOrSpec : typeNameOrSpec.schemaType, typeName = typeof schemaType == "string" ? schemaType : schemaType.name, spec = typeof typeNameOrSpec == "string" ? { schemaType } : typeNameOrSpec, type = schema2.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase__default.default(typeName);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({ type: typeName }).schemaType(type).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(
    spec.menuItemGroups || [
      {
        id: "sorting",
        title: "Sort",
        i18n: { title: { key: "menu-item-groups.actions-group", ns: structureLocaleNamespace } }
      },
      {
        id: "layout",
        title: "Layout",
        i18n: { title: { key: "menu-item-groups.layout-group", ns: structureLocaleNamespace } }
      },
      {
        id: "actions",
        title: "Actions",
        i18n: { title: { key: "menu-item-groups.sorting-group", ns: structureLocaleNamespace } }
      }
    ]
  ).child(
    spec.child || ((documentId) => resolveDocumentNode({ schemaType: typeName, documentId }))
  ).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(
    spec.menuItems || [
      // Create new (from action button) will be added in serialization step of GenericList
      // Sort by <Y>
      ...getOrderingMenuItemsForSchemaType(context, type),
      // Display as <Z>
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.compact-view", ns: structureLocaleNamespace } }).title("Compact view").icon(icons.StackCompactIcon).action("setLayout").params({ layout: "default" }),
      new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.detailed-view", ns: structureLocaleNamespace } }).title("Detailed view").icon(icons.StackIcon).action("setLayout").params({ layout: "detail" })
      // Create new (from menu) will be added in serialization step of GenericList
    ]
  );
}
function hasIcon(schemaType) {
  return !schemaType || typeof schemaType == "string" ? !1 : !!schemaType.icon;
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({ title: { key: "default-definition.content-title", ns: structureLocaleNamespace } }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder({
  defaultDocumentNode,
  source
}) {
  const configContext = sanity.getConfigContextFromSource(source), context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: (options) => {
      let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, { ...options, ...configContext })) || new DocumentBuilder(context);
      return builder.getId() || (builder = builder.id("documentEditor")), options.documentId && (builder = builder.documentId(sanity.getPublishedId(options.documentId))), builder.schemaType(options.schemaType);
    }
  }, structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: (...args) => getDocumentTypeList(context, ...args),
    documentTypeListItem: (...args) => getDocumentTypeListItem(context, ...args),
    documentTypeListItems: (...args) => getDocumentTypeListItems(context, ...args),
    document: (...args) => new DocumentBuilder(context, ...args),
    documentWithInitialValueTemplate: (...args) => documentFromEditorWithInitialValue(context, ...args),
    defaultDocument: context.resolveDocumentNode,
    list: (...args) => new ListBuilder(context, ...args),
    listItem: (...args) => new ListItemBuilder(context, ...args),
    menuItem: (...args) => new MenuItemBuilder(context, ...args),
    menuItemGroup: (...args) => new MenuItemGroupBuilder(context, ...args),
    menuItemsFromInitialValueTemplateItems: (...args) => menuItemsFromInitialValueTemplateItems(context, ...args),
    documentList: (...args) => new DocumentListBuilder(context, ...args),
    documentListItem: (...args) => new DocumentListItemBuilder(context, ...args),
    orderingMenuItem: (...args) => getOrderingMenuItem(context, ...args),
    orderingMenuItemsForType: (...args) => getOrderingMenuItemsForSchemaType(context, ...args),
    editor: (...args) => documentFromEditor(context, ...args),
    defaultInitialValueTemplateItems: (...args) => defaultInitialValueTemplateItems(context, ...args),
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: (spec) => reactIs.isValidElementType(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec),
    divider: () => ({ id: uniqueId__default.default("__divider__"), type: "divider" }),
    view: views,
    context
  };
  return structureBuilder;
}
const tasksLocaleNamespace = "tasks", tasksUsEnglishLocaleBundle = sanity.defineLocaleResourceBundle({
  locale: "en-US",
  namespace: tasksLocaleNamespace,
  resources: () => Promise.resolve().then(function() {
    return require("./resources3.js");
  })
});
function getTargetValue({
  documentId,
  documentType,
  dataset,
  projectId
}) {
  return {
    documentType,
    document: {
      _ref: sanity.getPublishedId(documentId),
      _type: "crossDatasetReference",
      _dataset: dataset,
      _projectId: projectId,
      _weak: !0
    }
  };
}
function getMentionedUsers(description) {
  if (!description)
    return [];
  const subscribers = [];
  return description == null || description.forEach((block) => {
    sanity.isPortableTextTextBlock(block) && block.children.forEach((child) => {
      child._type === "mention" && typeof child.userId == "string" && !subscribers.includes(child.userId) && subscribers.push(child.userId);
    });
  }), subscribers;
}
const TASK_STATUS = [
  { value: "open", title: "To Do", icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CircleIcon, {}) },
  { value: "closed", title: "Done", icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkCircleIcon, {}) }
];
function useDocumentPreviewValues(options) {
  var _a;
  const { documentId, documentType } = options || {}, schemaType = sanity.useSchema().get(documentType), documentPreviewStore = sanity.useDocumentPreviewStore(), previewState = reactRx.useMemoObservable(() => !documentId || !schemaType ? rxjs.of(null) : sanity.getPreviewStateObservable(documentPreviewStore, schemaType, documentId, ""), [documentId, documentPreviewStore, schemaType]), isLoading = (_a = previewState == null ? void 0 : previewState.isLoading) != null ? _a : !0, { published, draft } = previewState || {}, documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title), subtitle = (draft == null ? void 0 : draft.subtitle) || (published == null ? void 0 : published.subtitle), description = (draft == null ? void 0 : draft.description) || (published == null ? void 0 : published.description), media = (draft == null ? void 0 : draft.media) || (published == null ? void 0 : published.media);
  return {
    isLoading,
    value: {
      title: documentTitle,
      subtitle,
      media,
      description
    }
  };
}
const DATE_FORMAT_OPTIONS = {
  month: "long",
  day: "2-digit",
  minute: "2-digit",
  hour: "2-digit",
  second: "2-digit"
}, RELATIVE_TIME_OPTIONS = {
  minimal: !0,
  useTemporalPhrase: !0
}, Strong = styled__default.default.strong`
  font-weight: 600;
`;
function UpdatedTimeAgo(timestamp) {
  const date = new Date(timestamp), formattedDate = sanity.useDateTimeFormat(DATE_FORMAT_OPTIONS).format(date);
  return { timeAgo: sanity.useRelativeTime(date || "", RELATIVE_TIME_OPTIONS), formattedDate };
}
function UserName({ userId }) {
  const [user, isLoading] = sanity.useUser(userId);
  return isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "15ch" } }) : /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: user == null ? void 0 : user.displayName });
}
const DUE_BY_DATE_OPTIONS = {
  month: "short",
  day: "numeric"
};
function DueByChange({ date }) {
  const dueBy = new Date(date), formattedDate = sanity.useDateTimeFormat(DUE_BY_DATE_OPTIONS).format(dueBy);
  return /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: formattedDate });
}
const LinkWrapper = styled__default.default.span`
  > a {
    color: var(--card-fg-muted-color);
    text-decoration: underline;
    text-underline-offset: 1px;
    font-weight: 600;
  }
`;
function TargetContentChange({ target }) {
  const schema2 = sanity.useSchema(), documentId = target.document._ref, documentType = target.documentType, documentSchema = schema2.get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  });
  return isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { style: { width: "15ch" } }) : documentSchema ? /* @__PURE__ */ jsxRuntime.jsx(LinkWrapper, { children: /* @__PURE__ */ jsxRuntime.jsx(router$1.IntentLink, { intent: "edit", params: { id: documentId, type: documentType }, children: value == null ? void 0 : value.title }) }) : null;
}
function getChangeDetails(activity) {
  var _a, _b;
  switch (activity.field) {
    case "status": {
      const statusTitle = (_a = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _a.title;
      return {
        text: "changed status to",
        icon: ((_b = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _b.icon) || /* @__PURE__ */ jsxRuntime.jsx(icons.CircleIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(Strong, { children: statusTitle })
      };
    }
    case "target":
      return activity.to ? {
        text: "set target content to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(TargetContentChange, { target: activity.to })
      } : {
        text: "removed target content",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.LinkIcon, {}),
        changeTo: void 0
      };
    case "dueBy":
      return activity.from ? activity.to ? {
        text: "changed the due date to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(DueByChange, { date: activity.to })
      } : {
        text: "removed the due date",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
        changeTo: void 0
      } : {
        text: "set the due date to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CalendarIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(DueByChange, { date: activity.to })
      };
    case "assignedTo":
      return activity.to ? {
        text: "assigned to",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.UserIcon, {}),
        changeTo: /* @__PURE__ */ jsxRuntime.jsx(UserName, { userId: activity.to })
      } : {
        text: "unassigned this task",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.UserIcon, {}),
        changeTo: void 0
      };
    case "description":
      return {
        text: "updated the task description",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.EditIcon, {}),
        changeTo: void 0
      };
    case "title":
      return {
        text: "updated the task title",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.EditIcon, {}),
        changeTo: void 0
      };
    default:
      return {
        text: "",
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CircleIcon, {})
      };
  }
}
const EditedAt = React.memo(
  function(props) {
    const { activity } = props, { formattedDate, timeAgo } = UpdatedTimeAgo(activity.timestamp), { icon, text, changeTo } = getChangeDetails(activity);
    return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, marginLeft: 1, marginRight: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: icon }) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
        /* @__PURE__ */ jsxRuntime.jsx(UserName, { userId: activity.author }),
        " ",
        text,
        " ",
        changeTo,
        " \u2022",
        " ",
        /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: formattedDate, placement: "top-end", children: /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: formattedDate, children: timeAgo }) })
      ] })
    ] });
  },
  (prevProps, nextProps) => prevProps.activity.timestamp === nextProps.activity.timestamp
), AvatarRoot = styled__default.default.div(
  (props) => {
    var _a, _b;
    const theme$1 = theme.getTheme_v2(props.theme);
    return styled.css`
      min-height: ${(_a = theme$1.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
      min-width: ${(_b = theme$1.avatar.sizes[props.$size]) == null ? void 0 : _b.size}px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      ${props.$border ? "box-shadow: inset 0 0 0 1px var(--card-border-color);" : ""};
      ${props.$removeBg ? "--card-avatar-gray-bg-color: transparent;" : ""}
    `;
  }
), AvatarSkeleton = styled__default.default(ui.Skeleton)((props) => {
  var _a, _b;
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    height: ${(_a = theme$1.avatar.sizes[props.$size]) == null ? void 0 : _a.size}px;
    width: ${(_b = theme$1.avatar.sizes[props.$size]) == null ? void 0 : _b.size}px;
    border-radius: 50%;
  `;
});
function TasksUserAvatar(props) {
  const { user, size = 0, border = !0 } = props, [loadedUser, loading] = sanity.useUser((user == null ? void 0 : user.id) || "");
  return loading ? /* @__PURE__ */ jsxRuntime.jsx(AvatarSkeleton, { $size: size, animated: !0 }) : !user || !loadedUser ? /* @__PURE__ */ jsxRuntime.jsx(AvatarRoot, { $size: size, $border: border, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size, children: /* @__PURE__ */ jsxRuntime.jsx(icons.UserIcon, {}) }) }) : /* @__PURE__ */ jsxRuntime.jsx(AvatarRoot, { $size: size, $removeBg: !!(loadedUser != null && loadedUser.imageUrl), children: /* @__PURE__ */ jsxRuntime.jsx(
    sanity.UserAvatar,
    {
      user: loadedUser,
      size,
      ...loadedUser != null && loadedUser.imageUrl ? { color: void 0 } : {}
    }
  ) });
}
const ActivityItemChildrenContainer = styled__default.default.div`
  width: 100%;
`;
function ActivityItem({ userId, children }) {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginRight: 3, paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: { id: userId }, size: 0 }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ActivityItemChildrenContainer, { children })
  ] });
}
function TasksActivityCommentInput(props) {
  const { mentionOptions, currentUser, onSubmit } = props, [value, setValue] = React.useState(null), editorRef = React.useRef(null), hasValue = React.useMemo(() => hasCommentMessageValue(value), [value]), handleChange = React.useCallback((nextValue) => {
    setValue(nextValue);
  }, []), handleSubmit = React.useCallback(() => {
    hasValue && (onSubmit(value), setValue(null));
  }, [hasValue, onSubmit, value]), handleDiscardCancel = React.useCallback(() => {
    var _a;
    (_a = editorRef.current) == null || _a.discardDialogController.close();
  }, []), handleDiscardConfirm = React.useCallback(() => {
    var _a;
    (_a = editorRef.current) == null || _a.discardDialogController.close(), setValue(null);
  }, []), handleKeyDown = React.useCallback(
    (e) => {
      var _a, _b;
      e.key === "Escape" && (e.preventDefault(), e.stopPropagation(), hasValue ? (_a = editorRef.current) == null || _a.discardDialogController.open() : ((_b = editorRef.current) == null || _b.discardDialogController.close(), setValue(null)));
    },
    [hasValue]
  ), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(ActivityItem, { userId: currentUser.id, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: "transparent", radius: 3, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    CommentInput,
    {
      withAvatar: !1,
      currentUser,
      expandOnFocus: !0,
      mentionOptions,
      onChange: handleChange,
      onDiscardConfirm: handleDiscardConfirm,
      onDiscardCancel: handleDiscardCancel,
      onKeyDown: handleKeyDown,
      onSubmit: handleSubmit,
      placeholder: t("panel.comment.placeholder"),
      ref: editorRef,
      value
    }
  ) }) });
}
const COMMENTS_LIST_ITEM_AVATAR_CONFIG = {
  parentCommentAvatar: !1,
  threadCommentsAvatar: !0,
  replyAvatar: !0,
  avatarSize: 0
};
function TasksActivityCommentItem(props) {
  const { parentComment } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ActivityItem, { userId: parentComment.authorId, children: /* @__PURE__ */ jsxRuntime.jsx(
    CommentsListItem,
    {
      ...props,
      avatarConfig: COMMENTS_LIST_ITEM_AVATAR_CONFIG,
      canReply: !0,
      innerPadding: 1,
      isSelected: !1,
      mode: "default"
    }
  ) });
}
const UserSkeleton = styled__default.default(ui.TextSkeleton)`
  max-width: 15ch;
  width: '100%';
`, TasksActivityCreatedAt = React.memo(
  function(props) {
    var _a;
    const { createdAt, authorId } = props, [user, loading] = sanity.useUser(authorId), { timeAgo, formattedDate } = UpdatedTimeAgo(createdAt), { t } = sanity.useTranslation(tasksLocaleNamespace);
    return /* @__PURE__ */ jsxRuntime.jsx(ActivityItem, { userId: authorId, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, muted: !0, children: [
      /* @__PURE__ */ jsxRuntime.jsxs("strong", { style: { fontWeight: 600 }, children: [
        loading ? /* @__PURE__ */ jsxRuntime.jsx(UserSkeleton, {}) : (_a = user == null ? void 0 : user.displayName) != null ? _a : t("panel.activity.unknown-user"),
        " "
      ] }),
      t("panel.activity.created-fragment"),
      " \u2022",
      " ",
      /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: formattedDate, placement: "top-end", children: /* @__PURE__ */ jsxRuntime.jsx("time", { dateTime: createdAt, children: timeAgo }) })
    ] }) }) });
  },
  (prevProps, nextProps) => prevProps.createdAt === nextProps.createdAt
);
function TasksSubscribers(props) {
  var _a, _b;
  const { value, onChange, path, currentUserId } = props, buttonText = (_a = value.subscribers) != null && _a.includes(currentUserId) ? "Unsubscribe" : "Subscribe", handleToggleSubscribe = React.useCallback(() => {
    const subscribers = value.subscribers || [];
    subscribers.includes(currentUserId) || onChange(sanity.set(subscribers.concat(currentUserId), path)), subscribers.includes(currentUserId) && onChange(
      sanity.set(
        subscribers.filter((subscriberId) => subscriberId !== currentUserId),
        path
      )
    );
  }, [value.subscribers, currentUserId, onChange, path]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { mode: "bleed", text: buttonText, onClick: handleToggleSubscribe }),
    value.subscribers && ((_b = value.subscribers) == null ? void 0 : _b.length) > 0 && /* @__PURE__ */ jsxRuntime.jsx(TasksSubscriberAvatars, { subscriberIds: value.subscribers })
  ] });
}
const EMPTY_ARRAY$4 = [];
function TasksSubscriberAvatars(props) {
  const { subscriberIds: subscriberIdsProp } = props, subscriberIds = React.useMemo(() => (subscriberIdsProp == null ? void 0 : subscriberIdsProp.filter(Boolean)) || EMPTY_ARRAY$4, [subscriberIdsProp]);
  return /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { initial: !1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarStack, { maxLength: 3, size: 0, children: subscriberIds.map((subscriberId) => /* @__PURE__ */ jsxRuntime.jsx(
    framerMotion.motion.div,
    {
      exit: { opacity: 0, translateX: "2px", scale: 0.9 },
      animate: {
        opacity: 1,
        translateX: 0,
        scale: 1,
        transition: { type: "just", duration: 0.2 }
      },
      initial: { opacity: 0, translateX: "2px", scale: 0.9 },
      children: /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: { id: subscriberId }, size: 0 })
    },
    subscriberId
  )) }) });
}
const EMPTY_ARRAY$3 = [], VARIANTS$2 = {
  hidden: { opacity: 0, x: 0 },
  visible: { opacity: 1, x: 0 }
}, MotionStack = styled__default.default(framerMotion.motion(ui.Stack))``;
function TasksActivityLog(props) {
  const { value, onChange, path, activityData = [] } = props, currentUser = sanity.useCurrentUser(), { title: workspaceTitle, basePath } = sanity.useWorkspace(), { comments: comments2, mentionOptions, operation, getComment } = useComments(), [commentToDeleteId, setCommentToDeleteId] = React.useState(null), [commentDeleteError, setCommentDeleteError] = React.useState(null), [commentDeleteLoading, setCommentDeleteLoading] = React.useState(!1), loading = comments2.loading, taskComments = comments2.data.open, handleGetNotificationValue = React.useCallback(
    (message, commentId) => {
      const studioUrl = new URL(`${window.location.origin}${basePath ? `${basePath}/` : ""}`);
      studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", value == null ? void 0 : value._id), studioUrl.searchParams.set("viewMode", "edit"), studioUrl.searchParams.set("commentId", commentId);
      const mentionedUsers = getMentionedUsers(message), subscribers = Array.from(/* @__PURE__ */ new Set([...value.subscribers || [], ...mentionedUsers]));
      return {
        documentTitle: value.title || "Sanity task",
        url: studioUrl.toString(),
        workspaceTitle,
        subscribers
      };
    },
    [basePath, value == null ? void 0 : value._id, value.title, workspaceTitle, value.subscribers]
  ), handleCommentCreate = React.useCallback(
    (message) => {
      const commentId = uuid.uuid(), notification = handleGetNotificationValue(message, commentId), nextComment = {
        id: commentId,
        type: "task",
        message,
        parentCommentId: void 0,
        reactions: EMPTY_ARRAY$3,
        status: "open",
        threadId: uuid.uuid(),
        context: {
          notification
        }
      };
      onChange(sanity.set(notification.subscribers, ["subscribers"])), operation.create(nextComment);
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentReply = React.useCallback(
    (nextComment) => {
      const commentId = uuid.uuid(), notification = handleGetNotificationValue(nextComment.message, commentId);
      onChange(sanity.set(notification.subscribers, ["subscribers"])), operation.create({
        id: commentId,
        type: "task",
        message: nextComment.message,
        parentCommentId: nextComment.parentCommentId,
        reactions: EMPTY_ARRAY$3,
        status: "open",
        threadId: nextComment.threadId,
        context: {
          notification
        }
      });
    },
    [operation, handleGetNotificationValue, onChange]
  ), handleCommentCreateRetry = React.useCallback(
    (id) => {
      const comment = getComment(id);
      if (!comment)
        return;
      const notification = handleGetNotificationValue(comment.message, comment._id);
      onChange(sanity.set(notification.subscribers, ["subscribers"])), operation.create({
        type: "task",
        id: comment._id,
        message: comment.message,
        parentCommentId: comment.parentCommentId,
        reactions: comment.reactions || EMPTY_ARRAY$3,
        status: comment.status,
        threadId: comment.threadId,
        context: {
          notification
        }
      });
    },
    [getComment, operation, handleGetNotificationValue, onChange]
  ), handleCommentReact = React.useCallback(
    (id, reaction) => {
      operation.react(id, reaction);
    },
    [operation]
  ), handleDeleteCommentStart = React.useCallback((id) => setCommentToDeleteId(id), []), handleDeleteCommentCancel = React.useCallback(() => setCommentToDeleteId(null), []), handleDeleteCommentConfirm = React.useCallback(
    async (id) => {
      try {
        setCommentDeleteLoading(!0), setCommentDeleteError(null), await operation.remove(id), setCommentToDeleteId(null);
      } catch (err) {
        setCommentDeleteError(err);
      } finally {
        setCommentDeleteLoading(!1);
      }
    },
    [operation]
  ), handleCommentEdit = React.useCallback(
    (id, next) => {
      operation.update(id, next);
    },
    [operation]
  ), activity = React.useMemo(() => {
    const taskActivity = activityData.map((item) => ({
      _type: "activity",
      payload: item,
      timestamp: item.timestamp
    })), commentsActivity = taskComments.map((comment) => ({
      _type: "comment",
      payload: comment,
      timestamp: comment.parentComment._createdAt
    }));
    return taskActivity.concat(commentsActivity).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
  }, [activityData, taskComments]), { t } = sanity.useTranslation(tasksLocaleNamespace), commentToDeleteIsParent = React.useMemo(() => {
    var _a;
    const parent = taskComments.find((c) => {
      var _a2;
      return ((_a2 = c.parentComment) == null ? void 0 : _a2._id) === commentToDeleteId;
    });
    return !!(parent && ((_a = parent == null ? void 0 : parent.replies) == null ? void 0 : _a.length) > 0);
  }, [commentToDeleteId, taskComments]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    commentToDeleteId && /* @__PURE__ */ jsxRuntime.jsx(
      CommentDeleteDialog,
      {
        commentId: commentToDeleteId,
        error: commentDeleteError,
        isParent: commentToDeleteIsParent,
        loading: commentDeleteLoading,
        onClose: handleDeleteCommentCancel,
        onConfirm: handleDeleteCommentConfirm
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, weight: "semibold", children: t("panel.activity.title") }) }),
        (currentUser == null ? void 0 : currentUser.id) && /* @__PURE__ */ jsxRuntime.jsx(
          TasksSubscribers,
          {
            currentUserId: currentUser.id,
            value,
            onChange,
            path
          }
        )
      ] }),
      loading && /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0, title: "Loading activity" }),
      /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { children: !loading && /* @__PURE__ */ jsxRuntime.jsxs(MotionStack, { animate: "visible", initial: "hidden", space: 4, variants: VARIANTS$2, children: [
        value.createdByUser && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { paddingBottom: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
          TasksActivityCreatedAt,
          {
            createdAt: value.createdByUser,
            authorId: value.authorId
          }
        ) }),
        currentUser && /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, marginTop: 1, children: [
          activity.map((item) => item._type === "activity" ? /* @__PURE__ */ jsxRuntime.jsx(EditedAt, { activity: item.payload }, item.timestamp) : /* @__PURE__ */ jsxRuntime.jsx(
            TasksActivityCommentItem,
            {
              currentUser,
              mentionOptions,
              onCreateRetry: handleCommentCreateRetry,
              onDelete: handleDeleteCommentStart,
              onEdit: handleCommentEdit,
              onReactionSelect: handleCommentReact,
              onReply: handleCommentReply,
              parentComment: item.payload.parentComment,
              replies: item.payload.replies
            },
            item.payload.parentComment._id
          )),
          /* @__PURE__ */ jsxRuntime.jsx(
            TasksActivityCommentInput,
            {
              currentUser,
              mentionOptions,
              onSubmit: handleCommentCreate
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
const TasksEnabledContext = React.createContext(null);
function TasksEnabledProvider({ children }) {
  var _a;
  const { enabled, isLoading } = sanity.useFeatureEnabled("sanityTasks"), { enabled: stagingIsEnabled, isLoading: stagingIsLoading } = sanity.useFeatureEnabled("studioTasks"), isWorkspaceEnabled = (_a = sanity.useWorkspace().tasks) == null ? void 0 : _a.enabled, value = React.useMemo(() => !isWorkspaceEnabled || isLoading || stagingIsLoading ? {
    enabled: !1,
    mode: null
  } : stagingIsEnabled || enabled ? {
    enabled: !0,
    mode: "default"
  } : {
    enabled: !1,
    mode: null
  }, [enabled, isLoading, isWorkspaceEnabled, stagingIsEnabled, stagingIsLoading]);
  return /* @__PURE__ */ jsxRuntime.jsx(TasksEnabledContext.Provider, { value, children });
}
function useTasksEnabled() {
  const context = React.useContext(TasksEnabledContext);
  if (!context)
    throw new Error("useTasks must be used within a TasksEnabledProvider");
  return context;
}
const MentionUserContext = React.createContext(null);
function MentionUserProvider(props) {
  const [selectedDocument, setSelectedDocument] = React.useState(null), mentionOptions = sanity.useUserListWithPermissions({
    documentValue: selectedDocument,
    permission: "read"
  }), value = React.useMemo(
    () => ({
      mentionOptions,
      selectedDocument,
      setSelectedDocument
    }),
    [mentionOptions, selectedDocument, setSelectedDocument]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(MentionUserContext.Provider, { value, children: props.children });
}
function useMentionUser() {
  const context = React.useContext(MentionUserContext);
  if (!context)
    throw new Error("useMentionUser must be used within a MentionUserProvider");
  return context;
}
const TasksNavigationContext = React.createContext(null), initialState = {
  viewMode: "list",
  selectedTask: null,
  activeTabId: "assigned",
  duplicateTaskValues: null,
  isOpen: !1
};
function reducer(state2, action) {
  switch (action.type) {
    case "TOGGLE_TASKS_VIEW":
      return action.payload === !1 ? {
        ...initialState,
        isOpen: action.payload
      } : {
        ...state2,
        isOpen: action.payload
      };
    case "CREATE_TASK":
      return {
        ...state2,
        viewMode: "create",
        selectedTask: uuid.uuid()
      };
    case "EDIT_TASK":
      return {
        ...state2,
        viewMode: "edit",
        selectedTask: action.payload.id
      };
    case "EDIT_DRAFT":
      return {
        ...state2,
        viewMode: "draft",
        selectedTask: action.payload.id
      };
    case "DUPLICATE_TASK":
      return {
        ...state2,
        viewMode: "duplicate",
        selectedTask: uuid.uuid(),
        duplicateTaskValues: action.payload.duplicateTaskValues
      };
    case "SET_ACTIVE_TAB":
      return {
        ...state2,
        viewMode: "list",
        activeTabId: action.payload
      };
    case "NAVIGATE_TO_LIST":
      return {
        ...state2,
        viewMode: "list"
      };
    default:
      return state2;
  }
}
const TasksNavigationProvider = ({ children }) => {
  const [state2, dispatch] = React.useReducer(reducer, initialState), router2 = router$1.useRouter(), toast = ui.useToast(), setViewMode = React.useCallback((viewMode) => {
    switch (viewMode.type) {
      case "list":
        dispatch({ type: "NAVIGATE_TO_LIST" });
        break;
      case "create":
        dispatch({ type: "CREATE_TASK" });
        break;
      case "edit":
        dispatch({ type: "EDIT_TASK", payload: { id: viewMode.id } });
        break;
      case "duplicate":
        dispatch({
          type: "DUPLICATE_TASK",
          payload: { duplicateTaskValues: viewMode.duplicateTaskValues }
        });
        break;
      case "draft":
        dispatch({ type: "EDIT_DRAFT", payload: { id: viewMode.id } });
        break;
    }
  }, []), setActiveTab = React.useCallback((tabId) => {
    dispatch({ type: "SET_ACTIVE_TAB", payload: tabId });
  }, []), handleCloseTasks = React.useCallback(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !1 });
  }, []), handleOpenTasks = React.useCallback(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !0 });
  }, []), handleCopyLinkToTask = React.useCallback(() => {
    const url = new URL(window.location.href);
    url.searchParams.set("sidebar", "tasks"), url.searchParams.set("viewMode", state2.viewMode), state2.selectedTask && url.searchParams.set("selectedTask", state2.selectedTask), navigator.clipboard.writeText(url.toString()).then(() => {
      toast.push({
        closable: !0,
        status: "info",
        title: "Copied link to clipboard"
      });
    }).catch(() => {
      toast.push({
        closable: !0,
        status: "error",
        title: "Failed to copy link to clipboard"
      });
    });
  }, [state2.selectedTask, state2.viewMode, toast]), searchParamsAsString = new URLSearchParams(router2.state._searchParams).toString();
  return React.useEffect(() => {
    if (searchParamsAsString) {
      const searchParams = new URLSearchParams(searchParamsAsString);
      if (searchParams.get("sidebar") !== "tasks")
        return;
      dispatch({ type: "TOGGLE_TASKS_VIEW", payload: !0 });
      const viewMode = searchParams.get("viewMode"), selectedTask = searchParams.get("selectedTask");
      viewMode === "edit" && selectedTask && dispatch({ type: "EDIT_TASK", payload: { id: selectedTask } });
    }
  }, [searchParamsAsString]), /* @__PURE__ */ jsxRuntime.jsx(
    TasksNavigationContext.Provider,
    {
      value: {
        state: state2,
        setViewMode,
        setActiveTab,
        handleCloseTasks,
        handleOpenTasks,
        handleCopyLinkToTask
      },
      children
    }
  );
};
function useTasksNavigation() {
  return React.useContext(TasksNavigationContext) || {
    state: {
      activeTabId: "assigned",
      viewMode: "list",
      selectedTask: null,
      isOpen: !1,
      duplicateTaskValues: null
    },
    setActiveTab: () => null,
    setViewMode: () => null,
    handleCloseTasks: () => null,
    handleCopyLinkToTask: () => null,
    handleOpenTasks: () => null
  };
}
const TasksContext = React.createContext(null);
function createTasksSet(tasks2) {
  return tasks2.reduce((acc, task) => ({ ...acc, [task._id]: task }), {});
}
function tasksReducer(state2, action) {
  switch (action.type) {
    case "TASKS_SET": {
      const tasksById = createTasksSet(action.tasks);
      return {
        ...state2,
        tasks: tasksById
      };
    }
    case "TASK_ADDED": {
      const nextTaskResult = action.payload, nextTaskValue = nextTaskResult, nextTask = {
        [nextTaskResult._id]: {
          ...state2.tasks[nextTaskResult._id],
          ...nextTaskValue,
          _state: nextTaskResult._state || void 0,
          // If the task is created optimistically, it won't have a createdAt date as this is set on the server.
          // However, we need to set a createdAt date to be able to sort the tasks correctly.
          // Therefore, we set the createdAt date to the current date here if it's missing while creating the task.
          // Once the task is created and received from the server, the createdAt date will be updated to the correct value.
          _createdAt: nextTaskResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          ...nextTask
        }
      };
    }
    case "TASK_RECEIVED": {
      const nextTaskResult = action.payload;
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          [nextTaskResult._id]: nextTaskResult
        }
      };
    }
    case "TASK_DELETED": {
      const { [action.id]: _, ...restTasks } = state2.tasks;
      return {
        ...state2,
        tasks: restTasks
      };
    }
    case "TASK_UPDATED": {
      const updatedTask = action.payload, id = updatedTask._id, nextTask = {
        // Add existing task data
        ...state2.tasks[id],
        // Add incoming task data
        ...updatedTask
      };
      return {
        ...state2,
        tasks: {
          ...state2.tasks,
          [id]: nextTask
        }
      };
    }
    default:
      return state2;
  }
}
const INITIAL_STATE = {
  tasks: {}
}, LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: !0,
  visibility: "query"
}, SORT_FIELD = "_createdAt", SORT_ORDER = "desc", QUERY_FILTERS = ['_type == "tasks.task"'], QUERY_PROJECTION = `{
  ...,
}`, QUERY_SORT_ORDER = `order(${SORT_FIELD} ${SORT_ORDER})`, QUERY = `*[${QUERY_FILTERS.join(" && ")}] ${QUERY_PROJECTION} | ${QUERY_SORT_ORDER}`;
function useTasksStore(opts) {
  const { client } = sanity.useAddonDataset(), { documentId } = opts, [state2, dispatch] = React.useReducer(tasksReducer, INITIAL_STATE), [isLoading, setIsLoading] = React.useState(client !== null), [error, setError] = React.useState(null), params = React.useMemo(
    () => ({ documentId: documentId ? sanity.getPublishedId(documentId) : null }),
    [documentId]
  ), initialFetch = React.useCallback(async () => {
    if (!client) {
      setIsLoading(!1);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({ type: "TASKS_SET", tasks: res }), setIsLoading(!1);
    } catch (err) {
      setError(err);
    }
  }, [client, params]), handleListenerEvent = React.useCallback(
    async (event) => {
      if (event.type === "welcome" && (setIsLoading(!0), await initialFetch(), setIsLoading(!1)), event.type === "reconnect" && setIsLoading(!0), event.type === "mutation") {
        if (event.transition === "appear") {
          const nextTask = event.result;
          nextTask && dispatch({
            type: "TASK_RECEIVED",
            payload: nextTask
          });
        }
        if (event.transition === "disappear" && dispatch({ type: "TASK_DELETED", id: event.documentId }), event.transition === "update") {
          const updatedTask = event.result;
          updatedTask && dispatch({
            type: "TASK_UPDATED",
            payload: updatedTask
          });
        }
      }
    },
    [initialFetch]
  ), listener$ = React.useMemo(() => client ? client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(
    rxjs.catchError((err) => (setError(err), rxjs.of(err)))
  ) : rxjs.of(), [client, params]);
  return React.useEffect(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null || sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]), {
    data: React.useMemo(() => Object.values(state2.tasks), [state2.tasks]),
    dispatch,
    error,
    isLoading
  };
}
const EMPTY_ARRAY$2 = [];
function TasksProvider(props) {
  const { children } = props, [activeDocument, setActiveDocument] = React.useState(null), { data = EMPTY_ARRAY$2, isLoading } = useTasksStore({}), value = React.useMemo(
    () => ({
      activeDocument,
      setActiveDocument,
      isLoading,
      data: data != null ? data : []
    }),
    [activeDocument, data, isLoading]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(TasksContext.Provider, { value, children });
}
function useTasks() {
  return React.useContext(TasksContext) || {
    activeDocument: null,
    setActiveDocument: () => null,
    data: [],
    isLoading: !1
  };
}
const API_VERSION = "2024-03-05";
function MentionUserMenuItem(props) {
  const { user, onSelect, pressed } = props, { t } = sanity.useTranslation(tasksLocaleNamespace), handleSelect = React.useCallback(() => onSelect(user.id), [user, onSelect]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { onClick: handleSelect, padding: 1, disabled: !user.granted, pressed, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, flex: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: user.id ? user : void 0, size: 1 }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", title: user.displayName, children: user.displayName })
    ] }),
    !user.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
  ] }) });
}
const StyledMenu$1 = styled__default.default(ui.Menu)`
  width: 308px;
  border-radius: 3px;
`, IGNORED_KEYS = [
  "Control",
  "Shift",
  "Alt",
  "Enter",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "Meta",
  "Tab",
  "CapsLock"
], NO_ASSIGNEE_OPTION = {
  id: "",
  displayName: "No assignee",
  granted: !0
};
function MentionsMenu({ onSelect, value = "" }) {
  const [searchTerm, setSearchTerm] = React.useState(""), { mentionOptions } = useMentionUser(), inputRef = React.useRef(null), options = [NO_ASSIGNEE_OPTION].concat(mentionOptions.data || []), handleSearchChange = React.useCallback((event) => {
    setSearchTerm(event.currentTarget.value);
  }, []), filteredOptions = React.useMemo(() => {
    var _a;
    if (!searchTerm)
      return options || [];
    const deburredSearchTerm = deburr__default.default(searchTerm).toLocaleLowerCase(), deburredOptions = options == null ? void 0 : options.map((option) => ({
      ...option,
      searchName: deburr__default.default(option.displayName || "").toLocaleLowerCase()
    }));
    return ((_a = deburredOptions == null ? void 0 : deburredOptions.filter((option) => option == null ? void 0 : option.searchName.includes(deburredSearchTerm))) == null ? void 0 : _a.sort((a, b) => {
      const matchA = a.searchName.startsWith(deburredSearchTerm), matchB = b.searchName.startsWith(deburredSearchTerm);
      return matchA && !matchB ? -1 : !matchA && matchB ? 1 : 0;
    })) || [];
  }, [options, searchTerm]), renderItem2 = React.useCallback(
    (user) => /* @__PURE__ */ jsxRuntime.jsx(
      MentionUserMenuItem,
      {
        user,
        onSelect,
        pressed: user.id === value
      },
      user.id
    ),
    [onSelect, value]
  ), handleKeyDown = React.useCallback((event) => {
    var _a;
    event.target !== inputRef.current && (IGNORED_KEYS.includes(event.key) || (_a = inputRef.current) == null || _a.focus());
  }, []), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return mentionOptions.loading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0 }) }) : /* @__PURE__ */ jsxRuntime.jsxs("div", { onKeyDown: handleKeyDown, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextInput,
      {
        placeholder: t("form.input.assignee.search.placeholder"),
        autoFocus: !0,
        border: !1,
        onChange: handleSearchChange,
        value: searchTerm,
        fontSize: 1,
        icon: icons.UserIcon,
        ref: inputRef
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: { maxHeight: "320px", overflowY: "scroll", paddingTop: "8px" }, children: filteredOptions.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, muted: !0, children: t("form.input.assignee.search.no-users.text") }) }) : filteredOptions.map(renderItem2) })
  ] });
}
function AssigneeSelectionMenu(props) {
  const { onSelect, menuButton, value } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: menuButton,
      id: "assign-user-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsx(StyledMenu$1, { children: /* @__PURE__ */ jsxRuntime.jsx(MentionsMenu, { onSelect, value }) }),
      popover: {
        placement: "bottom",
        portal: !0
      }
    }
  );
}
const FocusableCard = styled__default.default(ui.Card)((props) => {
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    &[data-as='button'] {
      border: 1px solid var(--card-border-color);
      &:focus-within {
        border: 1px solid var(--card-focus-ring-color);
      }
      --card-muted-fg-color: ${theme$1.color.input.default.enabled.placeholder};
    }
  `;
});
function AssigneeCreateFormField(props) {
  const { value, onChange } = props, { mentionOptions } = useMentionUser(), mentionedUser = React.useMemo(
    () => {
      var _a;
      return (_a = mentionOptions.data) == null ? void 0 : _a.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), onSelect = React.useCallback((userId) => onChange(sanity.set(userId)), [onChange]), { t } = sanity.useTranslation(tasksLocaleNamespace), displayText = React.useMemo(() => {
    if (value) {
      if (mentionOptions.loading)
        return /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return t("form.input.assignee.user-not-found.text");
    }
    return t("form.input.assignee.search.placeholder");
  }, [mentionOptions.loading, mentionedUser, value, t]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: /* @__PURE__ */ jsxRuntime.jsx(FocusableCard, { "data-as": "button", padding: 1, radius: 2, tabIndex: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: mentionedUser, size: 1, border: !1 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", muted: !mentionedUser, children: displayText })
        ] }),
        value && mentionedUser && !mentionedUser.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
const StyledButton = styled__default.default(ui.Button)`
  padding: 3px 6px;
`;
function AssigneeEditFormField(props) {
  const { value, onChange, path } = props, subscribers = sanity.useFormValue(["subscribers"]), { mentionOptions } = useMentionUser(), mentionedUser = React.useMemo(
    () => {
      var _a;
      return (_a = mentionOptions.data) == null ? void 0 : _a.find((u) => u.id === value);
    },
    [mentionOptions.data, value]
  ), { t } = sanity.useTranslation(tasksLocaleNamespace), onSelect = React.useCallback(
    (userId) => {
      onChange(sanity.set(userId, path)), subscribers && !subscribers.includes(userId) && userId && onChange(sanity.set([...subscribers, userId], ["subscribers"]));
    },
    [onChange, path, subscribers]
  ), displayText = React.useMemo(() => {
    if (value) {
      if (mentionOptions.loading)
        return /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { animated: !0, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return t("form.input.assignee.user-not-found.text");
    }
    return t("form.input.assignee.no-user-assigned.text");
  }, [mentionOptions.loading, mentionedUser, value, t]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    AssigneeSelectionMenu,
    {
      onSelect,
      value,
      menuButton: /* @__PURE__ */ jsxRuntime.jsx(StyledButton, { mode: "ghost", padding: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, flex: 1, children: [
          /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: mentionedUser, size: 0 }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: displayText }) })
        ] }),
        value && mentionedUser && !mentionedUser.granted && /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 1, mode: "outline", children: t("form.input.assignee.unauthorized.text") })
      ] }) })
    }
  );
}
const serialize = (date) => legacyDateFormat.format(date, legacyDateFormat.DEFAULT_DATE_FORMAT), deserialize = (value) => legacyDateFormat.parse(value, legacyDateFormat.DEFAULT_DATE_FORMAT);
function DateEditFormField(props) {
  var _a;
  const { value, onChange, path } = props, { t: coreT } = sanity.useTranslation(), { t } = sanity.useTranslation(tasksLocaleNamespace), [pickerOpen, setPickerOpen] = React.useState(!1), [popoverRef, setPopoverRef] = React.useState(null), buttonRef = React.useRef(null), dateFormatter = sanity.useDateTimeFormat({ dateStyle: "long" }), dueByeDisplayValue = React.useMemo(() => {
    if (!value)
      return { short: "----", full: "----" };
    const dueFormated = dateFormatter.format(new Date(value)), [monthAndDay] = dueFormated.split(",");
    return { short: monthAndDay, full: dueFormated };
  }, [dateFormatter, value]);
  ui.useClickOutside(() => setPickerOpen(!1), [popoverRef]);
  const handleKeyUp = React.useCallback((e) => {
    e.key === "Escape" && setPickerOpen(!1);
  }, []), handleClick = React.useCallback(() => setPickerOpen((p) => !p), []), calendarLabels = React.useMemo(() => getJsonStream.getCalendarLabels(coreT), [coreT]), handleChange = React.useCallback(
    (nextDate) => {
      onChange(nextDate ? sanity.set(serialize(nextDate), path) : sanity.unset(path)), setPickerOpen(!1);
    },
    [onChange, path]
  ), deserializedValue = deserialize(value), handleDeactivation = React.useCallback(() => {
    var _a2;
    (_a2 = buttonRef.current) == null || _a2.focus();
  }, [buttonRef]), dueDateIsThisYear = ((_a = deserializedValue == null ? void 0 : deserializedValue.date) == null ? void 0 : _a.getFullYear()) === (/* @__PURE__ */ new Date()).getFullYear();
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Popover,
    {
      constrainSize: !0,
      "data-testid": "date-input-dialog",
      portal: !0,
      ref: setPopoverRef,
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(FocusLock__default.default, { onDeactivation: handleDeactivation, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.DatePicker,
          {
            calendarLabels,
            selectTime: !1,
            timeStep: 1,
            onKeyUp: handleKeyUp,
            value: deserializedValue.date,
            onChange: handleChange
          }
        ),
        value && /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "flex-start", padding: 3, paddingTop: 0, children: /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.Button,
          {
            mode: "bleed",
            text: t("form.input.date.buttons.remove.text"),
            onClick: () => handleChange(null),
            tone: "critical"
          }
        ) })
      ] }) }),
      open: pickerOpen,
      placement: "bottom",
      fallbackPlacements: ["bottom-start", "bottom-end"],
      children: /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: icons.CalendarIcon,
          mode: "ghost",
          text: dueDateIsThisYear ? dueByeDisplayValue.short : dueByeDisplayValue.full,
          onClick: handleClick,
          ref: buttonRef
        }
      )
    }
  );
}
const NormalText = styled__default.default(ui.Text)`
  word-break: break-word;
`;
function DescriptionInputBlock(props) {
  const { children } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxRuntime.jsx(NormalText, { size: 1, children }) });
}
const renderBlock = (blockProps) => {
  const { children } = blockProps;
  return /* @__PURE__ */ jsxRuntime.jsx(DescriptionInputBlock, { children });
}, DescriptionInputRoot = styled__default.default.div((props) => {
  const theme$1 = theme.getTheme_v2(props.theme), verticalPadding = props.$mode === "edit" ? theme$1.space[1] : theme$1.space[3];
  return styled.css`
    /* select editable-wrap and change the padding */
    [data-ui='editable-wrap'] {
      overflow: hidden;
      padding: ${props.$mode === "edit" ? `${verticalPadding}px 0px` : `${verticalPadding}px ${theme$1.space[2]}px`};
      min-height: ${Math.max(props.$minHeight + verticalPadding, 200)}px !important;
    }
    #comment-input-root {
      box-shadow: ${props.$mode === "edit" ? "none" : ""};
    }
    [data-ui='CommentInputActions'] {
      display: none !important;
    }
  `;
});
function DescriptionInput(props) {
  const {
    value: _propValue,
    mode,
    inputProps: { onChange }
  } = props, value = _propValue, currentUser = sanity.useCurrentUser(), { mentionOptions } = useMentionUser(), handleChange = React.useCallback((next) => onChange(sanity.set(next)), [onChange]), [rootRef, setRootRef] = React.useState(null), [textBoxScrollHeight, setTextBoxScrollHeight] = React.useState(200), setTextboxHeight = React.useCallback((ref) => {
    const textBox = ref.querySelector('[role="textbox"]');
    if (!textBox)
      return;
    const height = textBox.scrollHeight;
    setTextBoxScrollHeight(height);
  }, []), handleSetRootRef = React.useCallback((ref) => {
    ref && React.startTransition(() => {
      setRootRef(ref);
    });
  }, []), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return React.useEffect(() => {
    rootRef && setTextboxHeight(rootRef);
  }, [value, setTextboxHeight, rootRef]), currentUser ? /* @__PURE__ */ jsxRuntime.jsx(
    DescriptionInputRoot,
    {
      $mode: mode,
      ref: handleSetRootRef,
      $minHeight: textBoxScrollHeight || 200,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        CommentInput,
        {
          expandOnFocus: !1,
          currentUser,
          mentionOptions,
          onChange: handleChange,
          value: value != null ? value : [],
          withAvatar: !1,
          placeholder: t("form.input.description.placeholder"),
          onDiscardConfirm: () => null,
          renderBlock
        }
      )
    }
  ) : null;
}
const FieldWrapperRoot = styled__default.default.div((props) => {
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    // Reset the padding of the field header content box
    [data-ui='fieldHeaderContentBox'] {
      padding: 0;
      label {
        font-weight: ${theme$1.font.text.weights.regular};
      }
    }
  `;
});
function FieldWrapper(props) {
  return /* @__PURE__ */ jsxRuntime.jsx(FieldWrapperRoot, { children: props.renderDefault(props) });
}
const StatusMenuButton = React.forwardRef(function(props, ref) {
  var _a;
  const { value, options, ...rest } = props, selectedOption = options.find((option) => option.value === value), icon = (_a = TASK_STATUS.find((status) => status.value === value)) == null ? void 0 : _a.icon;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      ...rest,
      ref,
      tooltipProps: null,
      icon,
      text: (selectedOption == null ? void 0 : selectedOption.title) || value,
      tone: "default",
      mode: "ghost"
    }
  );
});
function StatusSelector(props) {
  const { value, onChange, options, path } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(StatusMenuButton, { value, options }),
      id: "reference-menuButton",
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { children: options.map((option) => {
        var _a;
        const isSelected = value === option.value, icon = (_a = TASK_STATUS.find((status) => status.value === option.value)) == null ? void 0 : _a.icon;
        return /* @__PURE__ */ jsxRuntime.jsx(
          getJsonStream.MenuItem,
          {
            icon: sanity.isString(option.value) && icon || icons.CircleIcon,
            text: option.title || option.value,
            pressed: isSelected,
            iconRight: isSelected && /* @__PURE__ */ jsxRuntime.jsx(icons.CheckmarkIcon, {}),
            onClick: () => onChange(sanity.set(option.value, path))
          },
          option.title
        );
      }) })
    }
  );
}
function ConfigErrorsScreen() {
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: "Config errors" });
}
function CurrentWorkspaceProvider({ children }) {
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.WorkspaceLoader, { LoadingComponent: sanity.LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen, children });
}
const EmptyReferenceRoot = styled__default.default(ui.Card)((props) => {
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    &:focus {
      border: 1px solid var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      border: 1px solid var(--card-focus-ring-color);
    }
    &:hover {
      border-color: ${theme$1.color.input.default.hovered.border};
    }
  `;
}), Placeholder = styled__default.default(ui.Text)((props) => `
      color: ${theme.getTheme_v2(props.theme).color.input.default.enabled.placeholder};
      margin-left: 3px;
  `), TargetRoot = styled__default.default(ui.Card)`
  position: relative;
  [data-ui='show-on-hover'] {
    opacity: 0;
    position: absolute;
    right: 6px;
    top: 4px;
    display: flex;
  }
  &:focus-within,
  &:hover {
    padding-right: 36px;
    /* Hides the preview status dot, the button will take it's position. */
    [data-testid='compact-preview__status'] {
      opacity: 0;
    }
    [data-ui='show-on-hover'] {
      transition: opacity 200ms;
      opacity: 1;
    }
  }
`, StyledIntentLink$1 = styled__default.default(router$1.IntentLink)(() => styled.css`
    text-decoration: none;
    width: 100%;
    overflow: hidden;
    cursor: pointer;
    &:focus {
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
    &:focus-visible {
      outline: none;
      box-shadow: 0 0 0 1px var(--card-focus-ring-color);
    }
  `);
function Preview(props) {
  const { value, handleRemove } = props, documentId = value.document._ref, documentType = value.documentType, schemaType = sanity.useSchema().get(value.documentType), documentPresence = sanity.useDocumentPresence(documentId), { t } = sanity.useTranslation(tasksLocaleNamespace), CardLink = React.useMemo(
    () => React.forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsxRuntime.jsx(
        StyledIntentLink$1,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return schemaType ? /* @__PURE__ */ jsxRuntime.jsx(TargetRoot, { border: !0, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", justify: "space-between", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: CardLink, radius: 2, "data-as": "button", children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.SearchResultItemPreview,
      {
        documentId: value.document._ref,
        layout: "compact",
        presence: documentPresence,
        schemaType,
        showBadge: !1
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx("div", { "data-ui": "show-on-hover", children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        icon: icons.CloseIcon,
        mode: "bleed",
        onClick: handleRemove,
        tooltipProps: { content: t("form.input.target.buttons.remove.text") }
      }
    ) })
  ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: t("form.input.target.error.schema-not-found") });
}
function TargetField(props) {
  const [open, setOpen] = React.useState(!1), { dataset, projectId } = sanity.useWorkspace(), {
    mode,
    inputProps: { onChange },
    value: _propValue
  } = props, value = _propValue, handleItemSelect = React.useCallback(
    (item) => {
      onChange(
        sanity.set(
          getTargetValue({
            documentId: item._id,
            documentType: item._type,
            dataset,
            projectId
          })
        )
      );
    },
    [dataset, projectId, onChange]
  ), handleRemove = React.useCallback(() => {
    onChange(sanity.unset());
  }, [onChange]), handleOpenSearch = React.useCallback(() => {
    setOpen(!0);
  }, [setOpen]), handleCloseSearch = React.useCallback(() => {
    setOpen(!1);
  }, [setOpen]), handleKeyDown = React.useCallback((event) => {
    (event.key === "Enter" || event.key === " ") && setOpen(!0);
  }, []), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderBottom: mode === "edit", paddingBottom: mode === "edit" ? 4 : 0, children: /* @__PURE__ */ jsxRuntime.jsx(FieldWrapperRoot, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.LayerProvider, { zOffset: 100, children: /* @__PURE__ */ jsxRuntime.jsxs(CurrentWorkspaceProvider, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
      mode === "create" && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { "data-ui": "fieldHeaderContentBox", children: /* @__PURE__ */ jsxRuntime.jsx(
        sanity.FormFieldHeaderText,
        {
          description: props.description,
          inputId: props.inputId,
          title: props.title,
          validation: props.validation,
          deprecated: void 0
        }
      ) }),
      value ? /* @__PURE__ */ jsxRuntime.jsx(Preview, { value, handleRemove }) : /* @__PURE__ */ jsxRuntime.jsx(
        EmptyReferenceRoot,
        {
          border: !0,
          radius: 2,
          paddingX: 2,
          paddingY: 3,
          onClick: handleOpenSearch,
          onKeyDown: handleKeyDown,
          tabIndex: 0,
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, justify: "flex-start", align: "center", children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(Placeholder, { size: 1, children: t("form.input.target.search.placeholder") })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(sanity.SearchProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(
      sanity.SearchPopover,
      {
        open,
        onClose: handleCloseSearch,
        onItemSelect: handleItemSelect,
        disableIntentLink: !0
      }
    ) })
  ] }) }) }) });
}
const Root$1 = styled__default.default.div((props) => `
      display: grid;
      grid-template-columns: 1fr;
      padding-top: ${theme.getTheme_v2(props.theme).space[3]}px;
    `), TitleInput = styled__default.default.textarea((props) => {
  const { color: color2, font } = theme.getTheme_v2(props.theme);
  return styled.css`
    resize: none;
    overflow: hidden;
    appearance: none;
    background: none;
    border: 0;
    padding: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${font.text.weights.semibold};
    font-size: ${font.text.sizes[3].fontSize}px;
    line-height: ${font.text.sizes[3].lineHeight}px;
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;
    transition: height 500ms;
    /* NOTE: This is a hack to disable Chromes autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    color: ${color2.input.default.enabled.fg};

    &::placeholder {
      color: ${color2.input.default.enabled.placeholder};
    }
  `;
});
function Title(props) {
  const { value, onChange, placeholder, path } = props, ref = React.useRef(null);
  React.useEffect(() => {
    ref.current && (ref.current.style.height = "auto", ref.current.style.height = `${ref.current.scrollHeight}px`);
  }, [value]);
  const handleChange = React.useCallback(
    (event) => {
      const inputValue = event.currentTarget.value;
      return inputValue || onChange(sanity.unset(path)), onChange(sanity.set(inputValue.replace(/\n/g, ""), path));
    },
    [onChange, path]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Root$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
    TitleInput,
    {
      ref,
      autoFocus: !value,
      value,
      placeholder,
      onChange: handleChange,
      rows: 1
    }
  ) });
}
function TitleField(props) {
  const { value, inputProps } = props, { onChange, schemaType } = inputProps;
  return /* @__PURE__ */ jsxRuntime.jsx(Title, { value, onChange, placeholder: schemaType.placeholder });
}
function useTaskOperations() {
  const { client, createAddonDataset } = sanity.useAddonDataset(), currentUser = sanity.useCurrentUser(), handleCreate = React.useCallback(
    async (payload) => {
      if (!currentUser)
        throw new Error("No current user found. Unable to create task.");
      const task = {
        ...payload,
        authorId: currentUser.id,
        _type: "tasks.task"
      };
      if (!client)
        try {
          const newCreatedClient = await createAddonDataset();
          if (!newCreatedClient)
            throw new Error("No addon client found. Unable to create task.");
          return await newCreatedClient.create(task);
        } catch (err) {
          throw err;
        }
      try {
        return await client.create(task);
      } catch (err) {
        throw err;
      }
    },
    [client, createAddonDataset, currentUser]
  ), handleEdit = React.useCallback(
    async (id, set) => {
      try {
        if (!client)
          throw new Error("No client. Unable to create task.");
        return await client.patch(id).set(set).commit();
      } catch (e) {
        throw e;
      }
    },
    [client]
  ), handleRemove = React.useCallback(
    async (id) => {
      try {
        if (!client)
          throw new Error("No client. Unable to create task.");
        await client.delete(id);
      } catch (e) {
        throw e;
      }
    },
    [client]
  );
  return React.useMemo(
    () => ({
      create: handleCreate,
      edit: handleEdit,
      remove: handleRemove
    }),
    [handleCreate, handleEdit, handleRemove]
  );
}
function useRemoveTask({ id, onError, onRemoved }) {
  const [removeStatus, setRemoveStatus] = React.useState("idle"), [showDialog, setShowDialog] = React.useState(!1), [error, setError] = React.useState(null), operations = useTaskOperations(), handleRemove = React.useCallback(async () => {
    try {
      setRemoveStatus("loading"), await operations.remove(id), onRemoved == null || onRemoved(), setRemoveStatus("idle"), await new Promise((resolve) => setTimeout(resolve, 300)), setShowDialog(!1);
    } catch (e) {
      onError == null || onError(e.message), setError(e.message), setRemoveStatus("error");
    } finally {
      setRemoveStatus("idle");
    }
  }, [id, operations, onError, onRemoved]), handleOpenDialog = React.useCallback(() => {
    setShowDialog(!0);
  }, [setShowDialog]), handleCloseDialog = React.useCallback(() => {
    setShowDialog(!1);
  }, [setShowDialog]);
  return {
    removeStatus,
    showDialog,
    error,
    handleRemove,
    handleOpenDialog,
    handleCloseDialog
  };
}
const getTaskSubscribers = (task) => {
  const subscribers = task.subscribers || [];
  return getMentionedUsers(task.description).forEach((user) => {
    subscribers.includes(user) || subscribers.push(user);
  }), task.assignedTo && (subscribers.includes(task.assignedTo) || subscribers.push(task.assignedTo)), subscribers;
};
function FormCreate(props) {
  const [createMore, setCreateMore] = React.useState(!1), {
    setViewMode,
    setActiveTab,
    state: { viewMode }
  } = useTasksNavigation(), toast = ui.useToast(), handleCreateMore = React.useCallback(() => setCreateMore((p) => !p), []), { onChange } = props, value = props.value, onRemove = React.useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { handleRemove, removeStatus } = useRemoveTask({ id: value._id, onRemoved: onRemove }), { t } = sanity.useTranslation(tasksLocaleNamespace), handleCreate = React.useCallback(() => {
    if (!(value != null && value.title)) {
      toast.push({
        closable: !0,
        status: "error",
        title: t("form.status.error.title-required")
      });
      return;
    }
    onChange([
      sanity.set(getTaskSubscribers(value), ["subscribers"]),
      sanity.set((/* @__PURE__ */ new Date()).toISOString(), ["createdByUser"])
    ]), createMore ? setViewMode({ type: "create" }) : setActiveTab("subscribed"), toast.push({
      closable: !0,
      status: "success",
      title: t("form.status.success")
    });
  }, [setViewMode, setActiveTab, onChange, createMore, toast, value, t]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    props.renderDefault(props),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 5, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "flex-end", paddingTop: 1, gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, style: { flexGrow: viewMode === "draft" ? 1 : 0 }, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Switch, { onChange: handleCreateMore, checked: createMore }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, muted: !0, children: t("form.input.create-more.text") })
      ] }),
      viewMode === "draft" && /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          text: t("buttons.discard.text"),
          onClick: handleRemove,
          mode: "bleed",
          disabled: removeStatus === "loading",
          loading: removeStatus === "loading"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { text: t("buttons.create.text"), onClick: handleCreate })
    ] }) })
  ] });
}
const FIELDS_TO_GROUP = [
  "title",
  "status",
  "assignedTo",
  "dueBy",
  "target",
  "description"
], GROUP_TIME = 2 * 60 * 1e3;
function groupChanges(changes) {
  const groupedChanges = [];
  for (const change of changes) {
    const lastChangeProcessed = groupedChanges[groupedChanges.length - 1];
    if (!lastChangeProcessed) {
      groupedChanges.push(change);
      continue;
    }
    if (!FIELDS_TO_GROUP.includes(change.field)) {
      groupedChanges.push(change);
      continue;
    }
    if (lastChangeProcessed.author === change.author && lastChangeProcessed.field === change.field) {
      const lastChangeDate = new Date(lastChangeProcessed.timestamp), changeDate = new Date(change.timestamp);
      if (Math.abs(lastChangeDate.getTime() - changeDate.getTime()) <= GROUP_TIME) {
        lastChangeProcessed.to = change.to, lastChangeProcessed.timestamp = change.timestamp;
        continue;
      }
    }
    groupedChanges.push(change);
  }
  return groupedChanges;
}
function omitRev(document2) {
  const { _rev, ...doc } = document2;
  return doc;
}
function trackFieldChanges(newestDocument, transactions, fieldsToTrack) {
  let currentDocument = omitRev(newestDocument);
  const changes = [];
  let previousDocument = currentDocument;
  for (const transaction of transactions) {
    const { timestamp, effects } = transaction, documentId = transaction.documentIDs[0], effect = effects[documentId];
    !effect || !effect.revert || (previousDocument = mendoza.applyPatch(currentDocument, effect.revert), fieldsToTrack.forEach((field) => {
      (previousDocument == null ? void 0 : previousDocument[field]) !== (currentDocument == null ? void 0 : currentDocument[field]) && changes.push({
        field,
        from: previousDocument == null ? void 0 : previousDocument[field],
        to: currentDocument == null ? void 0 : currentDocument[field],
        timestamp,
        author: transaction.author
      });
    }), currentDocument = previousDocument);
  }
  const changesSortedByTimestamp = changes.sort((a, b) => a.timestamp.localeCompare(b.timestamp)), createdByUserIndex = changesSortedByTimestamp.findIndex(
    (change) => change.field === "createdByUser"
  );
  return groupChanges(changesSortedByTimestamp.slice(createdByUserIndex + 1));
}
function useActivityLog(task) {
  var _a;
  const [changes, setChanges] = React.useState([]), client = sanity.useClient({ apiVersion: API_VERSION }), { dataset, token } = client.config(), queryParams = "tag=sanity.studio.tasks.history&effectFormat=mendoza&excludeContent=true&includeIdentifiedDocumentsOnly=true&reverse=true", publishedId = sanity.getPublishedId((_a = task == null ? void 0 : task._id) != null ? _a : ""), transactionsUrl = client.getUrl(
    `/data/history/${dataset}/transactions/${publishedId}?${queryParams}`
  ), fetchAndParse = React.useCallback(
    async (newestTaskDocument) => {
      try {
        if (!publishedId)
          return;
        const transactions = [], reader = (await getJsonStream.getJsonStream(transactionsUrl, token)).getReader();
        let result;
        for (; result = await reader.read(), !result.done; ) {
          if ("error" in result.value)
            throw new Error(result.value.error.description || result.value.error.type);
          transactions.push(result.value);
        }
        const fieldsToTrack = [
          "createdByUser",
          "title",
          "description",
          "dueBy",
          "assignedTo",
          "status",
          "target"
        ], parsedChanges = await trackFieldChanges(
          newestTaskDocument,
          [...transactions],
          fieldsToTrack
        );
        setChanges(parsedChanges);
      } catch (error) {
        console.error("Failed to fetch and parse activity log", error);
      }
    },
    [transactionsUrl, token, publishedId]
  );
  return React.useEffect(() => {
    fetchAndParse(task);
  }, [fetchAndParse, task._rev]), { changes };
}
function RemoveTaskDialog(props) {
  const { handleCloseDialog, handleRemove, removeStatus, showDialog } = props, { t } = sanity.useTranslation(tasksLocaleNamespace);
  return showDialog ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Dialog,
    {
      id: "remove-task",
      header: t("dialog.remove-task.title"),
      onClose: handleCloseDialog,
      footer: {
        cancelButton: {
          text: t("dialog.remove-task.buttons.cancel.text"),
          onClick: handleCloseDialog
        },
        confirmButton: {
          text: t("dialog.remove-task.buttons.confirm.text"),
          tone: "critical",
          onClick: handleRemove,
          loading: removeStatus === "loading"
        }
      },
      children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: t("dialog.remove-task.body") }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "p", children: t("dialog.remove-task.body2") })
      ] })
    }
  ) : null;
}
const FirstRow = styled__default.default(ui.Flex)((props) => {
  const theme$1 = theme.getTheme_v2(props.theme);
  return styled.css`
    column-gap: ${theme$1.space[2]}px;
    row-gap: ${theme$1.space[3]}px;
  `;
});
function FormActionsMenu({ id, value }) {
  const { setViewMode, handleCopyLinkToTask } = useTasksNavigation(), onTaskRemoved = React.useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), removeTask = useRemoveTask({ id, onRemoved: onTaskRemoved }), duplicateTask = React.useCallback(() => {
    setViewMode({ type: "duplicate", duplicateTaskValues: value });
  }, [setViewMode, value]), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.MenuButton,
      {
        id: "edit-task-menu",
        button: /* @__PURE__ */ jsxRuntime.jsx(sanity.ContextMenuButton, {}),
        popover: {
          placement: "bottom",
          fallbackPlacements: ["bottom-end", "bottom-start"]
        },
        menu: /* @__PURE__ */ jsxRuntime.jsxs(ui.Menu, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t("menuitem.duplicate.text"),
              icon: icons.CopyIcon,
              onClick: duplicateTask
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t("menuitem.copylink.text"),
              icon: icons.LinkIcon,
              onClick: handleCopyLinkToTask
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
          /* @__PURE__ */ jsxRuntime.jsx(
            getJsonStream.MenuItem,
            {
              text: t("menuitem.delete.text"),
              icon: icons.TrashIcon,
              onClick: removeTask.handleOpenDialog,
              tone: "critical"
            }
          )
        ] })
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(RemoveTaskDialog, { ...removeTask })
  ] });
}
function FormEditInner(props) {
  var _a, _b, _c, _d, _e, _f;
  const statusField = props.schemaType.fields.find((f) => f.name === "status"), value = props.value, currentUser = sanity.useCurrentUser(), { t } = sanity.useTranslation(tasksLocaleNamespace), activityData = useActivityLog(value).changes, handleChangeAndSubscribe = React.useCallback(
    (patch) => {
      const subscribers = value.subscribers || [];
      props.onChange(patch), currentUser && (subscribers.includes(currentUser.id) || props.onChange(sanity.set([...subscribers, currentUser.id], ["subscribers"])));
    },
    [currentUser, props, value.subscribers]
  );
  if (!statusField)
    throw new Error("Status field not found");
  return (_a = props.value) != null && _a._id ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        Title,
        {
          onChange: handleChangeAndSubscribe,
          value: (_b = props.value) == null ? void 0 : _b.title,
          path: ["title"],
          placeholder: t("form.input.title.placeholder")
        }
      ) }),
      /* @__PURE__ */ jsxRuntime.jsx(FormActionsMenu, { id: (_c = props.value) == null ? void 0 : _c._id, value })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(
      FirstRow,
      {
        paddingBottom: 3,
        paddingTop: 4,
        align: "flex-start",
        justify: "flex-start",
        wrap: "wrap",
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            StatusSelector,
            {
              value: (_d = props.value) == null ? void 0 : _d.status,
              path: ["status"],
              onChange: handleChangeAndSubscribe,
              options: statusField.type.options.list
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            AssigneeEditFormField,
            {
              value: (_e = props.value) == null ? void 0 : _e.assignedTo,
              onChange: handleChangeAndSubscribe,
              path: ["assignedTo"]
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            DateEditFormField,
            {
              value: (_f = props.value) == null ? void 0 : _f.dueBy,
              onChange: handleChangeAndSubscribe,
              path: ["dueBy"]
            }
          )
        ]
      }
    ) }),
    props.renderDefault(props),
    /* @__PURE__ */ jsxRuntime.jsx(
      CommentsProvider,
      {
        documentId: value._id,
        documentType: "tasks.task",
        sortOrder: "asc",
        type: "task",
        children: /* @__PURE__ */ jsxRuntime.jsx(CurrentWorkspaceProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { borderTop: !0, paddingTop: 4, marginTop: 4, paddingBottom: 6, children: /* @__PURE__ */ jsxRuntime.jsx(
          TasksActivityLog,
          {
            value,
            onChange: props.onChange,
            path: ["subscribers"],
            activityData
          }
        ) }) })
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, {});
}
function FormEdit(props) {
  const value = props.value, currentUser = sanity.useCurrentUser(), transformPatches = React.useCallback(
    (patches) => {
      if (!currentUser || patches.some((patch) => patch.path[0] === "subscribers"))
        return patches;
      const subscribers = value.subscribers || [], newSubscribers = [...subscribers], changeAssigneePatch = patches.find((patch) => patch.path[0] === "assignedTo");
      changeAssigneePatch && changeAssigneePatch.type === "set" && typeof changeAssigneePatch.value == "string" && !newSubscribers.includes(changeAssigneePatch.value) && newSubscribers.push(changeAssigneePatch.value), newSubscribers.includes(currentUser.id) || newSubscribers.push(currentUser.id);
      const changedDescriptionPatch = patches.find(
        (patch) => patch.path[0] === "description" && patch.type === "set"
      );
      if (changedDescriptionPatch) {
        const prevMentionedUser = getMentionedUsers(value.description), newDescription = changedDescriptionPatch.type === "set" ? changedDescriptionPatch.value : void 0;
        getMentionedUsers(newDescription).filter((user) => !prevMentionedUser.includes(user)).forEach((user) => {
          newSubscribers.includes(user) || newSubscribers.push(user);
        });
      }
      return newSubscribers.length !== subscribers.length && patches.push(sanity.set(newSubscribers, ["subscribers"])), patches;
    },
    [currentUser, value.subscribers, value.description]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(sanity.TransformPatches, { transform: transformPatches, children: /* @__PURE__ */ jsxRuntime.jsx(FormEditInner, { ...props }) });
}
function TasksNotificationTargetInner(props) {
  var _a, _b, _c;
  const { inputProps } = props, { onChange } = inputProps, { target, _id, context } = sanity.useFormValue([]), { title: workspaceTitle, basePath } = sanity.useWorkspace(), client = sanity.useClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS), imageBuilder = React.useMemo(() => imageUrlBuilder__default.default(client), [client]), documentId = (_b = (_a = target == null ? void 0 : target.document) == null ? void 0 : _a._ref) != null ? _b : "", documentType = (_c = target == null ? void 0 : target.documentType) != null ? _c : "", { isLoading: previewValuesLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), targetContentTitle = (value == null ? void 0 : value.title) || null, imageUrl = assetUtils.isImageSource(value == null ? void 0 : value.media) ? imageBuilder.image(value.media).width(96).height(96).url() : null;
  return React.useEffect(() => {
    if (documentId && documentType && previewValuesLoading)
      return;
    const studioUrl = new URL(`${window.location.origin}${basePath}/`);
    studioUrl.searchParams.set("sidebar", "tasks"), studioUrl.searchParams.set("selectedTask", _id), studioUrl.searchParams.set("viewMode", "edit");
    const notificationTarget = {
      url: studioUrl.toString(),
      workspaceTitle,
      targetContentImageUrl: imageUrl,
      targetContentTitle
    };
    deepEquals__default.default(notificationTarget, context == null ? void 0 : context.notification) || onChange(sanity.set(notificationTarget, ["notification"]));
  }, [
    _id,
    basePath,
    workspaceTitle,
    documentId,
    documentType,
    previewValuesLoading,
    targetContentTitle,
    imageUrl,
    onChange,
    context
  ]), null;
}
function TasksNotificationTarget(props) {
  return /* @__PURE__ */ jsxRuntime.jsx(CurrentWorkspaceProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksNotificationTargetInner, { ...props }) });
}
const targetContentField = (mode) => sanity.defineField({
  type: "object",
  name: "target",
  title: "Target",
  components: {
    field: (props) => /* @__PURE__ */ jsxRuntime.jsx(TargetField, { ...props, mode })
  },
  fields: [
    {
      name: "document",
      type: "crossDatasetReference",
      dataset: "playground",
      weak: !0,
      studioUrl: ({ id, type }) => `intent/edit/id=${id};type=${type}/`,
      to: [
        {
          type: "any_document",
          preview: {
            select: { title: "title" }
          }
        }
      ]
    },
    {
      name: "documentType",
      type: "string",
      title: "Document type"
    }
  ]
}), descriptionInputField = (mode) => sanity.defineField({
  type: "array",
  name: "description",
  title: "Description",
  components: {
    field: (props) => /* @__PURE__ */ jsxRuntime.jsx(DescriptionInput, { ...props, mode })
  },
  of: [
    {
      type: "block",
      name: "block",
      of: [
        {
          name: "mention",
          type: "object",
          fields: [
            {
              name: "userId",
              type: "string"
            }
          ]
        }
      ],
      marks: {
        annotations: []
      },
      styles: [{ title: "Normal", value: "normal" }],
      lists: []
    }
  ]
}), taskSchema = (mode) => sanity.defineType({
  type: "document",
  name: "tasks.task",
  liveEdit: !0,
  components: {
    input: mode === "edit" ? FormEdit : FormCreate
  },
  fields: [
    {
      type: "string",
      title: "Title",
      name: "title",
      placeholder: "Task title",
      components: {
        field: TitleField
      },
      hidden: mode === "edit"
    },
    ...mode === "edit" ? [targetContentField(mode), descriptionInputField(mode)] : [descriptionInputField(mode), targetContentField(mode)],
    {
      type: "string",
      name: "assignedTo",
      title: "Assign to",
      placeholder: "Select username",
      components: {
        field: FieldWrapper,
        input: AssigneeCreateFormField
      },
      hidden: mode === "edit"
    },
    {
      type: "date",
      name: "dueBy",
      title: "Deadline",
      placeholder: "Select date",
      components: {
        field: FieldWrapper
      },
      hidden: mode === "edit"
    },
    {
      type: "string",
      name: "authorId",
      hidden: !0
    },
    {
      type: "string",
      name: "createdByUser",
      hidden: !0
    },
    {
      type: "array",
      of: [{ type: "string" }],
      name: "subscribers",
      hidden: !0
    },
    {
      type: "string",
      name: "status",
      title: "Status",
      options: {
        list: TASK_STATUS.map((s) => ({ value: s.value, title: s.title }))
      },
      hidden: !0
    },
    {
      type: "object",
      name: "context",
      components: {
        field: TasksNotificationTarget
      },
      fields: [
        {
          type: "object",
          name: "notification",
          fields: [
            {
              type: "string",
              name: "url"
            },
            {
              type: "string",
              name: "workspaceTitle"
            },
            {
              type: "string",
              name: "targetContentImageUrl"
            },
            {
              type: "string",
              name: "targetContentTitle"
            }
          ]
        }
      ]
    }
  ]
});
function TasksAddonWorkspaceProviderInner({
  children,
  mode,
  addonDataset
}) {
  const apiHost = sanity.useClient({ apiVersion: API_VERSION }).config().apiHost, basePath = "", source = sanity.useSource(), addonDatasetConfig = React.useMemo(
    () => ({
      basePath,
      dataset: addonDataset,
      name: `addon-dataset-${addonDataset}`,
      projectId: source.projectId,
      apiHost,
      schema: {
        types: [taskSchema(mode)]
      }
    }),
    [source.projectId, mode, apiHost, addonDataset, basePath]
  ), { workspaces } = React.useMemo(
    () => sanity.prepareConfig(addonDatasetConfig, { basePath }),
    [addonDatasetConfig, basePath]
  ), addonWorkspace = sanity.useWorkspaceLoader(workspaces[0]);
  return addonWorkspace ? /* @__PURE__ */ jsxRuntime.jsx(sanity.WorkspaceProvider, { workspace: addonWorkspace, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.SourceProvider, { source: addonWorkspace.unstable_sources[0], children: /* @__PURE__ */ jsxRuntime.jsx(sanity.ResourceCacheProvider, { children }) }) }) : null;
}
function TasksAddonWorkspaceProvider(props) {
  const { client: addonDatasetClient, ready, createAddonDataset } = sanity.useAddonDataset(), addonDataset = addonDatasetClient == null ? void 0 : addonDatasetClient.config().dataset;
  return React.useEffect(() => {
    !addonDataset && ready && createAddonDataset();
  }, [addonDataset, ready, createAddonDataset]), addonDataset ? /* @__PURE__ */ jsxRuntime.jsx(TasksAddonWorkspaceProviderInner, { ...props, addonDataset }) : /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, {});
}
function useTasksFormBuilder(options) {
  const { documentType = "tasks.task", documentId, initialValue = {} } = options, tasksSchemaType = sanity.useSchema().get(documentType);
  if (!tasksSchemaType)
    throw new Error(`Schema type for '${documentType}' not found`);
  const { validation: validationRaw } = sanity.useValidationStatus(documentId, documentType), validation = sanity.useUnique(validationRaw), [focusPath, setFocusPath] = React.useState([]), [openPath, setOpenPath] = React.useState([]), [collapsedPaths, onSetCollapsedPath] = React.useState(), [collapsedFieldSets, onSetCollapsedFieldSets] = React.useState(), [fieldGroupState, onSetFieldGroupState] = React.useState(), [presence] = React.useState([]), handleFocus = React.useCallback(
    (nextFocusPath) => {
      setFocusPath(nextFocusPath);
    },
    [setFocusPath]
  ), handleBlur = React.useCallback(() => {
    setFocusPath([]);
  }, []), handleOnSetCollapsedPath = React.useCallback((path, collapsed) => {
    onSetCollapsedPath((prevState) => sanity.setAtPath(prevState, path, collapsed));
  }, []), handleOnSetCollapsedFieldSet = React.useCallback((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => sanity.setAtPath(prevState, path, collapsed));
  }, []), handleSetActiveFieldGroup = React.useCallback(
    (path, groupName) => onSetFieldGroupState((prevState) => sanity.setAtPath(prevState, path, groupName)),
    []
  ), { patch } = sanity.useDocumentOperation(documentId, documentType), patchRef = React.useRef(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(sanity.toMutationPatches(event.patches), initialValue);
  };
  const handleChange = React.useCallback((event) => patchRef.current(event), []), connectionState = sanity.useConnectionState(documentId, documentType), editState = sanity.useEditState(documentId, documentType), value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue, formState = sanity.useFormState(tasksSchemaType, {
    value,
    comparisonValue: value,
    readOnly: !1,
    changesOpen: !1,
    presence,
    focusPath,
    openPath,
    collapsedPaths,
    collapsedFieldSets,
    fieldGroupState,
    validation
  }), ready = editState.ready && connectionState === "connected", patchChannel = React.useMemo(() => sanity.createPatchChannel(), []);
  return formState === null || !ready ? { loading: !0 } : {
    id: "root",
    onChange: handleChange,
    // eslint-disable-next-line camelcase
    __internal_patchChannel: patchChannel,
    // eslint-disable-next-line camelcase
    __internal_fieldActions: void 0,
    onPathFocus: handleFocus,
    onPathOpen: setOpenPath,
    onPathBlur: handleBlur,
    onFieldGroupSelect: handleSetActiveFieldGroup,
    onSetFieldSetCollapsed: handleOnSetCollapsedFieldSet,
    onSetPathCollapsed: handleOnSetCollapsedPath,
    collapsedPaths,
    collapsedFieldSets,
    focusPath: formState.focusPath,
    changed: formState.changed,
    focused: formState.focused,
    groups: formState.groups,
    validation: formState.validation,
    members: formState.members,
    presence: formState.presence,
    schemaType: tasksSchemaType,
    value: formState.value
  };
}
const VARIANTS$1 = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.2, delay: 0.2 }
  }
}, FormBuilderRoot = styled__default.default(framerMotion.motion.div)((props) => {
  const theme$1 = theme.getTheme_v2(props.theme);
  return `
    // Update spacing for the form builder
    & > [data-ui='Stack'] {
      grid-gap: ${ui.rem(theme$1.space[4])};
    }
`;
}), TasksFormBuilderInner = ({
  documentId,
  initialValue
}) => {
  var _a, _b;
  const formBuilderProps = useTasksFormBuilder({
    documentType: "tasks.task",
    documentId,
    initialValue
  }), { setSelectedDocument } = useMentionUser(), target = formBuilderProps.loading || (_a = formBuilderProps.value) == null ? void 0 : _a.target, targetId = (_b = target == null ? void 0 : target.document) == null ? void 0 : _b._ref, targetType = target == null ? void 0 : target.documentType;
  return React.useEffect(() => {
    setSelectedDocument(targetId && targetType ? { _id: targetId, _type: targetType } : null);
  }, [targetId, targetType, setSelectedDocument]), /* @__PURE__ */ jsxRuntime.jsx(CommentsEnabledProvider, { documentId: "", documentType: "", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: formBuilderProps.loading ? /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(FormBuilderRoot, { id: "wrapper", initial: "hidden", animate: "visible", variants: VARIANTS$1, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.FormBuilder, { ...formBuilderProps }) }) }) });
};
function TasksFormBuilder() {
  const currentUser = sanity.useCurrentUser(), { activeDocument } = useTasks(), { dataset, projectId } = sanity.useWorkspace(), {
    state: { selectedTask, viewMode, duplicateTaskValues }
  } = useTasksNavigation(), initialValue = React.useMemo(() => {
    if (currentUser && selectedTask) {
      if (viewMode === "duplicate")
        return {
          ...duplicateTaskValues,
          title: `${duplicateTaskValues == null ? void 0 : duplicateTaskValues.title} (copy)`,
          // Set the new task title
          createdByUser: void 0,
          // Remove the createdByUser field
          _id: selectedTask,
          // Set the new task ID
          _type: "tasks.task",
          authorId: currentUser.id,
          // Set the author ID
          status: "open"
        };
      if (viewMode === "create")
        return {
          _id: selectedTask,
          _type: "tasks.task",
          authorId: currentUser.id,
          status: "open",
          subscribers: [currentUser.id],
          target: activeDocument ? getTargetValue({
            documentId: activeDocument.documentId,
            documentType: activeDocument.documentType,
            dataset,
            projectId
          }) : void 0
        };
    }
  }, [activeDocument, currentUser, dataset, duplicateTaskValues, projectId, selectedTask, viewMode]);
  return currentUser ? selectedTask ? (
    // This provider needs to be mounted before the TasksAddonWorkspaceProvider.
    /* @__PURE__ */ jsxRuntime.jsx(MentionUserProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksAddonWorkspaceProvider, { mode: viewMode === "edit" ? "edit" : "create", children: /* @__PURE__ */ jsxRuntime.jsx(
      TasksFormBuilderInner,
      {
        documentId: selectedTask,
        currentUser,
        initialValue
      }
    ) }) })
  ) : null : /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0, title: "Loading current user" });
}
const HEADING_BY_STATUS = {
  open: {
    assigned: {
      heading: "empty-state.status.list.open.assigned.heading",
      text: "empty-state.status.list.open.assigned.text"
    },
    document: { heading: "empty-state.status.list.open.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.open.subscribed.heading",
      text: "empty-state.status.list.open.subscribed.text"
    }
  },
  closed: {
    assigned: {
      heading: "empty-state.status.list.closed.assigned.heading",
      text: "empty-state.status.list.closed.assigned.text"
    },
    document: { heading: "empty-state.status.list.closed.document.heading", text: "" },
    subscribed: {
      heading: "empty-state.status.list.closed.subscribed.heading",
      text: "empty-state.status.list.closed.subscribed.text"
    }
  }
};
function EmptyStatusListState({ status }) {
  const {
    state: { activeTabId }
  } = useTasksNavigation(), { t } = reactI18next.useTranslation(tasksLocaleNamespace), { heading, text } = HEADING_BY_STATUS[status][activeTabId];
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: t(heading) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t(text) })
  ] });
}
const EMPTY_TASK_LIST = {
  assigned: {
    heading: "empty-state.list.assigned.heading",
    text: "empty-state.list.assigned.text"
  },
  subscribed: {
    heading: "empty-state.list.subscribed.heading",
    text: "empty-state.list.subscribed.text"
  },
  document: {
    heading: "empty-state.list.document.heading",
    text: "empty-state.list.document.text"
  }
}, Root = styled__default.default.div`
  max-width: 268px;
  margin: 0 auto;
  height: 100%;
  margin-top: 40%;
`;
function EmptyTasksListState() {
  const {
    state: { activeTabId },
    setViewMode
  } = useTasksNavigation(), { heading, text } = EMPTY_TASK_LIST[activeTabId], { t } = reactI18next.useTranslation(tasksLocaleNamespace), handleTaskCreate = React.useCallback(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]);
  return /* @__PURE__ */ jsxRuntime.jsx(Root, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 3, align: "center", flex: 1, justify: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: t(heading) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingBottom: 6, paddingTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, align: "center", children: t(text) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { icon: icons.AddIcon, text: t("empty-state.list.create-new"), onClick: handleTaskCreate })
  ] }) });
}
const StyledIntentLink = styled__default.default(router$1.IntentLink)((props) => `
  text-decoration: underline;
  text-decoration-color: ${theme.getTheme_v2(props.theme).color.input.default.enabled.border};
  text-underline-offset: 2px;
`);
function DocumentPreview({
  documentId,
  documentType
}) {
  const documentSchema = sanity.useSchema().get(documentType), { isLoading, value } = useDocumentPreviewValues({
    documentId,
    documentType
  }), Link2 = React.useMemo(
    () => React.forwardRef(function(linkProps, ref) {
      return /* @__PURE__ */ jsxRuntime.jsx(
        StyledIntentLink,
        {
          ...linkProps,
          intent: "edit",
          params: { id: documentId, type: documentType },
          ref
        }
      );
    }),
    [documentId, documentType]
  );
  return documentSchema ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DocumentIcon, {}) }),
    isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.TextSkeleton, { size: 1, muted: !0 }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, as: Link2, weight: "medium", style: { maxWidth: "20ch" }, textOverflow: "ellipsis", children: (value == null ? void 0 : value.title) || "Untitled" })
  ] }) : null;
}
function TasksStatus(props) {
  const operations = useTaskOperations(), { documentId, status } = props, [checkboxValue, setCheckboxValue] = React.useState(status === "closed"), [isLoading, setIsLoading] = React.useState(!1), handleCheckboxChange = React.useCallback(
    async (event) => {
      const isChecked = event.target.checked;
      setCheckboxValue(isChecked), setIsLoading(!0);
      try {
        isChecked ? await operations.edit(documentId, { status: "closed" }) : isChecked || await operations.edit(documentId, { status: "open" });
      } catch (error) {
        console.error("An error occurred while updating the task status", error);
      } finally {
        setIsLoading(!1);
      }
    },
    [documentId, operations]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: isLoading ? /* @__PURE__ */ jsxRuntime.jsx("div", { style: { height: "17px", width: "17px" }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { marginLeft: "3.5px", marginRight: "3.5px", marginTop: "3.5px" } }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Checkbox, { onChange: handleCheckboxChange, checked: checkboxValue, disabled: isLoading }) });
}
const TitleButton = styled__default.default(ui.Button)`
  width: 100%;
  max-width: 100%;
`, TaskDetailsRoot = styled__default.default(ui.Flex)`
  /* Checkbox width is 17px and first row gap is 12px. */
  margin-left: 29px;
`;
function getTargetDocumentMeta(target) {
  var _a;
  if ((_a = target == null ? void 0 : target.document) != null && _a._ref)
    return {
      _ref: target == null ? void 0 : target.document._ref,
      _type: target == null ? void 0 : target.documentType
    };
}
function TaskDueDate({ dueBy }) {
  const fullDateFormatter = sanity.useDateTimeFormat({ dateStyle: "medium" }), monthAndDayFormatter = sanity.useDateTimeFormat({ month: "short", day: "numeric" }), dayFormatter = sanity.useDateTimeFormat({ weekday: "long" }), dateOptions = React.useMemo(() => {
    const date = new Date(dueBy);
    return {
      fullDate: fullDateFormatter.format(date),
      monthAndDay: monthAndDayFormatter.format(date),
      day: dayFormatter.format(date),
      isDueByToday: dateFns.isToday(date),
      isDueThisWeek: dateFns.isThisISOWeek(date)
    };
  }, [dayFormatter, dueBy, fullDateFormatter, monthAndDayFormatter]), { fullDate, monthAndDay, day, isDueByToday, isDueThisWeek } = dateOptions;
  return /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: fullDate, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { tone: isDueByToday ? "critical" : "transparent", padding: 1, radius: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, {
    as: "time",
    size: 1,
    dateTime: dueBy,
    muted: !0,
    // eslint-disable-next-line no-nested-ternary
    children: isDueByToday ? "Today" : isDueThisWeek ? day : monthAndDay
  }) }) }) });
}
function TasksListItem(props) {
  const { assignedTo, title, dueBy, target, onSelect, documentId, status } = props, targetDocument = React.useMemo(() => getTargetDocumentMeta(target), [target]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksStatus, { documentId, status }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TitleButton, { onClick: onSelect, mode: "bleed", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title || "Untitled" }) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(TasksUserAvatar, { user: assignedTo ? { id: assignedTo } : void 0 })
    ] }),
    (dueBy || targetDocument) && /* @__PURE__ */ jsxRuntime.jsxs(TaskDetailsRoot, { align: "center", gap: 2, paddingX: 0, children: [
      dueBy && /* @__PURE__ */ jsxRuntime.jsx(TaskDueDate, { dueBy }),
      targetDocument && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginLeft: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        DocumentPreview,
        {
          documentId: targetDocument._ref,
          documentType: targetDocument._type
        }
      ) })
    ] })
  ] });
}
const EMPTY_ARRAY$1 = [], getLabelForStatus = (status) => {
  const statusConfig = TASK_STATUS.find((item) => item.value === status);
  return statusConfig == null ? void 0 : statusConfig.title;
}, DetailsFlex = styled__default.default(ui.Flex)`
  [data-ui='summary-icon'] {
    transition: transform 0.2s;
    transform: rotate(-90deg);
  }
  &[open] [data-ui='summary-icon'] {
    transform: rotate(0);
  }
  > summary::-webkit-details-marker {
    display: none;
  }
`, SummaryBox = styled__default.default(ui.Box)`
  list-style: none;
`;
function TaskList(props) {
  const { status, tasks: tasks2, onTaskSelect } = props;
  return /* @__PURE__ */ jsxRuntime.jsxs(DetailsFlex, { forwardedAs: "details", direction: "column", open: status === "open", children: [
    /* @__PURE__ */ jsxRuntime.jsx(SummaryBox, { forwardedAs: "summary", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, paddingY: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", muted: !0, children: getLabelForStatus(status) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronDownIcon, { "data-ui": "summary-icon" }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, marginTop: 4, paddingBottom: 5, children: (tasks2 == null ? void 0 : tasks2.length) > 0 ? tasks2.map((task, index) => {
      const showDivider = index < tasks2.length - 1;
      return /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          TasksListItem,
          {
            documentId: task._id,
            title: task.title,
            dueBy: task.dueBy,
            assignedTo: task.assignedTo,
            target: task.target,
            onSelect: () => onTaskSelect(task._id),
            status: task.status
          }
        ),
        showDivider && /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {})
      ] }, task._id);
    }) : /* @__PURE__ */ jsxRuntime.jsx(EmptyStatusListState, { status }) })
  ] });
}
function TasksList(props) {
  var _a, _b;
  const { items = EMPTY_ARRAY$1, onTaskSelect } = props, tasksByStatus = React.useMemo(
    () => items.reduce((acc, task) => (acc[task.status] || (acc[task.status] = []), acc[task.status].push(task), acc), {}),
    [items]
  ), hasOpenTasks = ((_a = tasksByStatus.open) == null ? void 0 : _a.length) > 0, hasClosedTasks = ((_b = tasksByStatus.closed) == null ? void 0 : _b.length) > 0;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 4, flex: 1, children: !hasOpenTasks && !hasClosedTasks ? /* @__PURE__ */ jsxRuntime.jsx(EmptyTasksListState, {}) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(TaskList, { status: "open", tasks: tasksByStatus.open, onTaskSelect }),
    /* @__PURE__ */ jsxRuntime.jsx(TaskList, { status: "closed", tasks: tasksByStatus.closed, onTaskSelect })
  ] }) });
}
const LIST_STYLES = {
  marginLeft: "-0.5em",
  justifyContent: "space-between",
  display: "flex"
};
function TasksListTabs({ activeTabId, onChange }) {
  const { activeDocument } = useTasks(), activeDocumentId = activeDocument == null ? void 0 : activeDocument.documentId, [documentTabIsDisabled, setDocumentTabIsDisabled] = React.useState(!activeDocumentId);
  React.useEffect(() => {
    let timeoutId = null;
    return !activeDocumentId && !documentTabIsDisabled && (timeoutId = setTimeout(() => {
      setDocumentTabIsDisabled(!0), onChange("assigned");
    }, 1e3)), documentTabIsDisabled && activeDocumentId && setDocumentTabIsDisabled(!1), () => {
      timeoutId && clearTimeout(timeoutId);
    };
  }, [activeDocumentId, documentTabIsDisabled, onChange]);
  const { t } = sanity.useTranslation(tasksLocaleNamespace), tabs = React.useMemo(
    () => [
      {
        id: "assigned",
        label: t("tab.assigned.label")
      },
      {
        id: "subscribed",
        label: t("tab.subscribed.label")
      },
      {
        id: "document",
        label: t("tab.document.label"),
        isDisabled: documentTabIsDisabled
      }
    ],
    [documentTabIsDisabled, t]
  ), handleTabChange = React.useCallback(
    (tab) => {
      tab.isDisabled || onChange(tab.id);
    },
    [onChange]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.TabList, { space: 2, style: LIST_STYLES, children: tabs.map((tab) => /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Tab,
    {
      "aria-controls": `${tab.id}-panel`,
      id: `${tab.id}-tab`,
      onClick: () => handleTabChange(tab),
      disabled: tab == null ? void 0 : tab.isDisabled,
      selected: tab.id === activeTabId,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: tab.label })
    },
    `${tab.id}-tab`
  )) });
}
const Divider = styled__default.default.div((props) => `
    height: 25px;
    width: 1px;
    background-color: ${theme.getTheme_v2(props.theme).color.input.default.enabled.border};
  `);
function TasksActiveTabNavigation(props) {
  const { items: allItems } = props, { state: state2, setViewMode } = useTasksNavigation(), { selectedTask } = state2, items = allItems.filter((t2) => t2.status === "open"), currentItemIndex = items.findIndex((item) => item._id === selectedTask), goToPreviousTask = React.useCallback(() => {
    const prevTaskId = currentItemIndex > 0 ? items[currentItemIndex - 1]._id : items[items.length - 1]._id;
    setViewMode({ type: "edit", id: prevTaskId });
  }, [currentItemIndex, items, setViewMode]), goToNextTask = React.useCallback(() => {
    const nextTaskId = currentItemIndex < items.length - 1 ? items[currentItemIndex + 1]._id : items[0]._id;
    setViewMode({ type: "edit", id: nextTaskId });
  }, [currentItemIndex, items, setViewMode]), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return items.length ? /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.TooltipDelayGroupProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        tooltipProps: { content: t("buttons.previous.tooltip") },
        mode: "bleed",
        icon: icons.ChevronLeftIcon,
        onClick: goToPreviousTask
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Tooltip, { content: t("panel.navigation.tooltip"), children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingY: 2, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
      currentItemIndex + 1,
      " / ",
      items.length
    ] }) }) }),
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        tooltipProps: { content: t("buttons.next.tooltip") },
        mode: "bleed",
        icon: icons.ChevronRightIcon,
        onClick: goToNextTask
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(Divider, {})
  ] }) }) : null;
}
const MENU_BUTTON_POPOVER_PROPS = {
  constrainSize: !0,
  fallbackPlacements: ["bottom-end"],
  placement: "bottom-end",
  portal: !0
}, StyledMenu = styled__default.default(ui.Menu)`
  width: 220px;
`;
function TasksDraftsMenuItem(props) {
  const { isSelected, item, onSelect } = props, handleClick = React.useCallback(() => {
    onSelect(item._id);
  }, [item._id, onSelect]), iconRight = isSelected ? icons.CheckmarkIcon : void 0, text = item.title || "Untitled";
  return /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuItem,
    {
      iconRight,
      onClick: handleClick,
      pressed: isSelected,
      selected: isSelected,
      text
    }
  );
}
function TasksHeaderDraftsMenu() {
  const { data } = useTasks(), { state: state2, setViewMode } = useTasksNavigation(), { viewMode, selectedTask } = state2, currentUser = sanity.useCurrentUser(), draftTasks = React.useMemo(() => currentUser != null && currentUser.id ? data.filter((task) => {
    const isAuthoredByUser = task.authorId === currentUser.id, isDraft = !task.createdByUser, hasEdits = task._updatedAt !== task._createdAt, isNotTheTaskBeingCreated = viewMode === "create" ? task._id !== selectedTask : !0;
    return isAuthoredByUser && isDraft && isNotTheTaskBeingCreated && hasEdits;
  }) : [], [data, selectedTask, currentUser == null ? void 0 : currentUser.id, viewMode]), handleSelectTask = React.useCallback(
    (id) => {
      setViewMode({ type: "draft", id });
    },
    [setViewMode]
  ), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return draftTasks.length ? /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(getJsonStream.Button, { text: t("buttons.draft.text"), mode: "ghost", iconRight: icons.ChevronDownIcon }),
      id: "edit-task-menu",
      menu: /* @__PURE__ */ jsxRuntime.jsxs(StyledMenu, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: t("panel.drafts.title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.MenuDivider, {}),
        draftTasks == null ? void 0 : draftTasks.map((task) => /* @__PURE__ */ jsxRuntime.jsx(
          TasksDraftsMenuItem,
          {
            isSelected: selectedTask === task._id,
            item: task,
            onSelect: handleSelectTask
          },
          task._id
        ))
      ] }),
      popover: MENU_BUTTON_POPOVER_PROPS
    }
  ) : null;
}
function TasksSidebarHeader(props) {
  const { items: allItems } = props, { state: state2, setViewMode, handleCloseTasks } = useTasksNavigation(), { viewMode, activeTabId } = state2, handleTaskCreate = React.useCallback(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]), handleGoBack = React.useCallback(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { justify: "space-between", align: "center", gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", flex: 1, children: [
      viewMode === "list" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 2, weight: "semibold", children: t("panel.title") }) }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { mode: "bleed", space: 2, padding: 2, onClick: handleGoBack, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: t("panel.title") }) }),
        /* @__PURE__ */ jsxRuntime.jsx(icons.ChevronRightIcon, {}),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingX: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", style: { textTransform: "capitalize" }, children: viewMode === "create" || viewMode === "draft" ? t("panel.create.title") : activeTabId }) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(sanity.BetaBadge, { marginLeft: 2 })
    ] }),
    (viewMode === "create" || viewMode === "draft") && /* @__PURE__ */ jsxRuntime.jsx(TasksHeaderDraftsMenu, {}),
    viewMode === "edit" && /* @__PURE__ */ jsxRuntime.jsx(TasksActiveTabNavigation, { items: allItems }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, children: [
      viewMode === "list" && /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          icon: icons.AddIcon,
          onClick: handleTaskCreate,
          mode: "bleed",
          text: t("buttons.new.text")
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        getJsonStream.Button,
        {
          tooltipProps: {
            content: t("panel.close.tooltip")
          },
          iconRight: icons.CloseIcon,
          mode: "bleed",
          onClick: handleCloseTasks
        }
      )
    ] })
  ] });
}
const RootCard = styled__default.default(ui.Card)`
  flex: 1;
  flex-direction: column;
`, HeaderStack = styled__default.default(ui.Stack)`
  border-bottom: 1px solid var(--card-border-color);
`, ContentFlex = styled__default.default(ui.Flex)`
  overflow-y: scroll;
  overflow-x: hidden;
`;
function TasksStudioSidebarInner() {
  const { activeDocument, data, isLoading } = useTasks(), { state: state2, setActiveTab, setViewMode } = useTasksNavigation(), { activeTabId, viewMode, selectedTask } = state2, currentUser = sanity.useCurrentUser(), onTaskSelect = React.useCallback((id) => setViewMode({ type: "edit", id }), [setViewMode]), filteredList = React.useMemo(() => data.filter((item) => {
    var _a, _b;
    return item.createdByUser ? activeTabId === "assigned" ? item.assignedTo === (currentUser == null ? void 0 : currentUser.id) : activeTabId === "subscribed" ? (currentUser == null ? void 0 : currentUser.id) && ((_a = item.subscribers) == null ? void 0 : _a.includes(currentUser.id)) : activeTabId === "document" ? (activeDocument == null ? void 0 : activeDocument.documentId) && ((_b = item.target) == null ? void 0 : _b.document._ref) === activeDocument.documentId : !1 : !1;
  }), [activeDocument == null ? void 0 : activeDocument.documentId, activeTabId, data, currentUser]), content = React.useMemo(() => viewMode !== "list" ? /* @__PURE__ */ jsxRuntime.jsx(TasksFormBuilder, {}, selectedTask) : isLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", justify: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {}) }) : /* @__PURE__ */ jsxRuntime.jsx(TasksList, { items: filteredList, onTaskSelect }), [filteredList, isLoading, onTaskSelect, selectedTask, viewMode]);
  return /* @__PURE__ */ jsxRuntime.jsxs(RootCard, { display: "flex", height: "fill", flex: 1, overflow: "hidden", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(HeaderStack, { space: 3, padding: 3, sizing: "border", children: [
      /* @__PURE__ */ jsxRuntime.jsx(TasksSidebarHeader, { items: filteredList }),
      viewMode === "list" && !isLoading && /* @__PURE__ */ jsxRuntime.jsx(TasksListTabs, { activeTabId, onChange: setActiveTab })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ContentFlex,
      {
        direction: "column",
        flex: 1,
        overflow: "auto",
        padding: 3,
        paddingTop: 4,
        paddingX: 4,
        sizing: "border",
        children: content
      }
    )
  ] });
}
function TasksStudioSidebar() {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(TasksStudioSidebarInner, {}) : null;
}
function TaskCreateAction() {
  const { handleOpenTasks, setViewMode } = useTasksNavigation(), { enabled } = useTasksEnabled(), handleCreateTaskFromDocument = React.useCallback(() => {
    handleOpenTasks(), setViewMode({ type: "create" });
  }, [handleOpenTasks, setViewMode]), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return enabled ? {
    icon: icons.TaskIcon,
    label: t("actions.create.text"),
    title: t("actions.create.text"),
    group: ["paneActions"],
    onHandle: handleCreateTaskFromDocument
  } : null;
}
function SetActiveDocumentInner(document2) {
  const { documentId, documentType } = document2, { isLast } = usePane(), { setActiveDocument } = useTasks();
  return React.useEffect(() => (documentId && isLast && documentType && (setActiveDocument == null || setActiveDocument({
    documentId: sanity.getPublishedId(documentId),
    documentType
  })), () => {
    isLast && (setActiveDocument == null || setActiveDocument(null));
  }), [documentId, documentType, isLast, setActiveDocument]), null;
}
function SetActiveDocument(document2) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(SetActiveDocumentInner, { ...document2 }) : null;
}
function TasksDocumentInputLayout(props) {
  var _a, _b;
  const documentId = (_a = props.value) == null ? void 0 : _a._id, documentType = (_b = props.value) == null ? void 0 : _b._type;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(SetActiveDocument, { documentId, documentType }),
    props.renderDefault(props)
  ] });
}
const ButtonContainer = styled__default.default.div`
  position: relative;
  [data-ui='Badge'] {
    position: absolute;
    top: -2px;
    right: -2px;
  }
`;
function TasksFooterOpenTasks() {
  const { data, activeDocument } = useTasks(), { handleOpenTasks, setActiveTab } = useTasksNavigation(), { enabled } = useTasksEnabled(), mediaIndex = ui.useMediaIndex(), pendingTasks = React.useMemo(
    () => data.filter((item) => {
      var _a;
      return ((_a = item.target) == null ? void 0 : _a.document._ref) === (activeDocument == null ? void 0 : activeDocument.documentId) && item.status === "open" && item.createdByUser;
    }),
    [activeDocument, data]
  ), handleOnClick = React.useCallback(() => {
    handleOpenTasks(), setActiveTab("document");
  }, [handleOpenTasks, setActiveTab]), { t } = sanity.useTranslation(tasksLocaleNamespace);
  return pendingTasks.length === 0 || !enabled ? null : mediaIndex < 3 ? /* @__PURE__ */ jsxRuntime.jsxs(ButtonContainer, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      getJsonStream.Button,
      {
        mode: "bleed",
        icon: icons.TaskIcon,
        size: "large",
        onClick: handleOnClick,
        tooltipProps: {
          content: t("document.footer.open-tasks.placeholder", {
            count: pendingTasks.length
          })
        }
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { tone: "primary", fontSize: 0, children: pendingTasks.length })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(
    getJsonStream.Button,
    {
      mode: "bleed",
      tooltipProps: {
        content: t("document.footer.open-tasks.placeholder", {
          count: pendingTasks.length
        })
      },
      text: t("document.footer.open-tasks.text", { count: pendingTasks.length }),
      onClick: handleOnClick
    }
  );
}
const VARIANTS = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 }
}, TRANSITION = { duration: 0.2 }, FULLSCREEN_MEDIA_INDEX = 1, POSITION_ABSOLUTE_MEDIA_INDEX = 2, RootFlex = styled__default.default(ui.Flex)(({ theme: theme2 }) => {
  const media = theme2.sanity.media;
  return styled.css`
    min-height: 100%;

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      position: relative;
    }
  `;
}), SidebarMotionLayer = styled__default.default(framerMotion.motion(ui.Layer))(({ theme: theme2 }) => {
  const media = theme2.sanity.media;
  return styled.css`
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 360px;
    border-left: 1px solid var(--card-border-color);
    box-sizing: border-box;
    overflow: hidden;

    box-shadow:
      0px 6px 8px -4px var(--card-shadow-umbra-color),
      0px 12px 17px -1px var(--card-shadow-penumbra-color);

    @media (max-width: ${media[POSITION_ABSOLUTE_MEDIA_INDEX]}px) {
      bottom: 0;
      position: absolute;
      right: 0;
      top: 0;
    }

    @media (max-width: ${media[FULLSCREEN_MEDIA_INDEX]}px) {
      border-left: 0;
      min-width: 100%;
      left: 0;
    }
  `;
});
function TasksStudioActiveToolLayoutInner(props) {
  const mediaIndex = ui.useMediaIndex(), {
    state: { isOpen }
  } = useTasksNavigation(), scrollLock = mediaIndex <= FULLSCREEN_MEDIA_INDEX && isOpen;
  return /* @__PURE__ */ jsxRuntime.jsxs(RootFlex, { sizing: "border", height: "fill", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, height: "fill", overflow: scrollLock ? "hidden" : "auto", children: props.renderDefault(props) }),
    /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { initial: !1, children: isOpen && /* @__PURE__ */ jsxRuntime.jsx(
      SidebarMotionLayer,
      {
        animate: "visible",
        height: "fill",
        initial: "hidden",
        transition: TRANSITION,
        variants: VARIANTS,
        children: /* @__PURE__ */ jsxRuntime.jsx(TasksStudioSidebar, {})
      }
    ) })
  ] });
}
function TasksStudioActiveToolLayout(props) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(TasksStudioActiveToolLayoutInner, { ...props }) : props.renderDefault(props);
}
const TasksStudioLayoutInner = (props) => {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(sanity.AddonDatasetProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksNavigationProvider, { children: props.renderDefault(props) }) }) }) : props.renderDefault(props);
};
function TasksStudioLayout(props) {
  return /* @__PURE__ */ jsxRuntime.jsx(TasksEnabledProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(TasksStudioLayoutInner, { ...props }) });
}
const EMPTY_ARRAY = [];
function TasksStudioNavbarInner(props) {
  const {
    handleOpenTasks,
    state: { isOpen }
  } = useTasksNavigation(), { t } = sanity.useTranslation(tasksLocaleNamespace), actions = React.useMemo(() => [
    ...(props == null ? void 0 : props.__internal_actions) || EMPTY_ARRAY,
    {
      icon: icons.PanelRightIcon,
      location: "topbar",
      name: "tasks-topbar",
      onAction: handleOpenTasks,
      selected: isOpen,
      title: t("actions.open.text")
    },
    {
      icon: icons.TaskIcon,
      location: "sidebar",
      name: "tasks-sidebar",
      onAction: handleOpenTasks,
      selected: isOpen,
      title: t("actions.open.text")
    }
  ], [handleOpenTasks, isOpen, props == null ? void 0 : props.__internal_actions, t]);
  return props.renderDefault({
    ...props,
    // eslint-disable-next-line camelcase
    __internal_actions: actions
  });
}
function TasksStudioNavbar(props) {
  const { enabled } = useTasksEnabled();
  return enabled ? /* @__PURE__ */ jsxRuntime.jsx(TasksStudioNavbarInner, { ...props }) : props.renderDefault(props);
}
const tasks = sanity.definePlugin({
  name: "sanity/tasks",
  // eslint-disable-next-line camelcase
  __internal_tasks: {
    footerAction: /* @__PURE__ */ jsxRuntime.jsx(TasksFooterOpenTasks, {})
  },
  document: {
    actions: (prev) => [...prev, TaskCreateAction].filter(Boolean)
  },
  studio: {
    components: {
      layout: TasksStudioLayout,
      navbar: TasksStudioNavbar,
      activeToolLayout: TasksStudioActiveToolLayout
    }
  },
  form: {
    components: {
      input: (props) => {
        var _a;
        return props.id === "root" && ((_a = props.schemaType.type) == null ? void 0 : _a.name) === "document" ? /* @__PURE__ */ jsxRuntime.jsx(TasksDocumentInputLayout, { ...props }) : props.renderDefault(props);
      }
    }
  },
  i18n: {
    bundles: [tasksUsEnglishLocaleBundle]
  }
}), LiveEditBadge = (props) => {
  const { liveEdit } = props;
  return liveEdit ? {
    label: "Live",
    color: "danger"
  } : null;
}, state = { activePanes: [] };
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a;
  const panes = (routerState == null ? void 0 : routerState.panes) || [], activePanes = state.activePanes || [], editDocumentId = params.id || uuid.uuid(), isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane == "object" && ((_a = pane.canHandleIntent) != null && _a.call(pane, intent, params, {
      pane,
      index: i
    }) || // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type")) {
      const paneParams = isTemplate ? { template: params.template } : EMPTY_PARAMS$1;
      return {
        panes: panes.slice(0, i).concat([[{ id: editDocumentId, params: paneParams, payload }]])
      };
    }
  }
  return { intent, params, payload };
}
function collectLatestAuthorAnnotations(diff) {
  const authorMap = /* @__PURE__ */ new Map();
  return sanity.visitDiff(diff, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation)
      return !0;
    const { author, timestamp } = child.annotation, previous = authorMap.get(author);
    return (!previous || previous.timestamp < timestamp) && authorMap.set(author, child.annotation), !0;
  }), Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
const Scroller = styled__default.default(sanity.ScrollContainer)`
  height: 100%;
  overflow: auto;
  position: relative;
  scroll-behavior: smooth;
`;
function ChangesInspector(props) {
  const { onClose } = props, { documentId, schemaType, timelineError, timelineStore, value } = useDocumentPane(), scrollRef = React.useRef(null), diff = sanity.useTimelineSelector(timelineStore, (state2) => state2.diff), onOlderRevision = sanity.useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision), selectionState = sanity.useTimelineSelector(timelineStore, (state2) => state2.selectionState), sinceTime = sanity.useTimelineSelector(timelineStore, (state2) => state2.sinceTime), loading = selectionState === "loading", isComparingCurrent = !onOlderRevision, { t } = sanity.useTranslation("studio"), documentContext = React.useMemo(
    () => ({
      documentId,
      schemaType,
      FieldWrapper: sanity.ChangeFieldWrapper,
      rootDiff: diff,
      isComparingCurrent,
      value
    }),
    [documentId, diff, isComparingCurrent, schemaType, value]
  ), changeAnnotations = React.useMemo(
    () => diff ? collectLatestAuthorAnnotations(diff) : [],
    [diff]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("changes.action.close-label"),
        flex: "none",
        onClose,
        title: t("changes.title"),
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, padding: 3, paddingTop: 0, paddingBottom: 2, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
            sanity.DiffTooltip,
            {
              annotations: changeAnnotations,
              description: t("changes.changes-by-author"),
              portal: !0,
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.AvatarStack, { maxLength: 4, "aria-label": t("changes.changes-by-author"), children: changeAnnotations.map(({ author }) => /* @__PURE__ */ jsxRuntime.jsx(sanity.UserAvatar, { user: author }, author)) })
            }
          ) })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.BoundaryElementProvider, { element: scrollRef.current, children: /* @__PURE__ */ jsxRuntime.jsx(Scroller, { "data-ui": "Scroller", ref: scrollRef, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
      Content,
      {
        diff,
        documentContext,
        error: timelineError,
        loading,
        schemaType
      }
    ) }) }) }) })
  ] });
}
function Content({
  error,
  diff,
  documentContext,
  loading,
  schemaType
}) {
  return error ? /* @__PURE__ */ jsxRuntime.jsx(sanity.NoChanges, {}) : loading ? /* @__PURE__ */ jsxRuntime.jsx(sanity.LoadingBlock, { showText: !0 }) : diff ? /* @__PURE__ */ jsxRuntime.jsx(sanity.DocumentChangeContext.Provider, { value: documentContext, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.ChangeList, { diff, schemaType }) }) : /* @__PURE__ */ jsxRuntime.jsx(sanity.NoChanges, {});
}
const changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const { features } = useStructureTool(), { t } = sanity.useTranslation();
    return {
      hidden: !features.reviewChanges,
      icon: icons.RestoreIcon,
      title: t("changes.title")
    };
  },
  component: ChangesInspector,
  onClose: ({ params }) => ({ params: { ...params, since: void 0 } }),
  onOpen: ({ params }) => ({ params: { ...params, since: "@lastPublished" } })
};
function getPathTitles(options) {
  const { path, schemaType, value } = options, result = [];
  let s = schemaType, v = value;
  for (const segment of path) {
    if (typeof segment == "string") {
      if (!sanity.isRecord(v) && v !== void 0)
        throw new Error(`Parent value is not an object, cannot get path segment: .${segment}`);
      if (s.jsonType !== "object")
        throw new Error(
          `Parent type is not an object schema type, cannot get path segment: .${segment}`
        );
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field)
        return result.push({ name: segment }), result;
      s = field.type, result.push(s);
      continue;
    }
    if (typeof segment == "number") {
      if (!sanity.isArray(v) && v !== void 0)
        throw new Error(`Parent value is not an array, cannot get path segment: [${segment}]`);
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: [${segment}]`
        );
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => typeof v == "string" ? ofType.jsonType === "string" : typeof v == "number" ? ofType.jsonType === "number" : typeof v == "boolean" ? ofType.jsonType === "boolean" : sanity.isRecord(v) ? ofType.name === (v == null ? void 0 : v._type) : !1);
      if (!itemType)
        throw new Error(`Item type not found: [${segment}]`);
      s = itemType, result.push(s);
      continue;
    }
    if (sanity.isRecord(segment) && segment._key) {
      if (!sanity.isArray(v))
        throw new Error(
          `Parent value is not an array, cannot get path segment: [_key == ${segment}]`
        );
      if (s.jsonType !== "array")
        throw new Error(
          `Parent type is not an array schema type, cannot get path segment: .${segment}`
        );
      if (v = (v != null ? v : []).find((i) => sanity.isRecord(i) && i._key === segment._key), !sanity.isRecord(v))
        throw new Error(`Array item not found: [_key == ${segment._key}]`);
      const ofType = s.of.find((i) => sanity.isRecord(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType)
        throw new Error(`Array item type not found: .${v == null ? void 0 : v._type}`);
      s = ofType, result.push(s);
      continue;
    }
    throw new Error(`Invalid path segment: ${JSON.stringify(segment)}`);
  }
  return result;
}
const MARKER_ICON = {
  error: icons.ErrorOutlineIcon,
  warning: icons.WarningOutlineIcon,
  info: icons.InfoOutlineIcon
}, MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const { onClose } = props, { onFocus, onPathOpen, schemaType, validation, value } = useDocumentPane(), { t } = sanity.useTranslation("validation"), handleOpen = React.useCallback(
    (path) => {
      onPathOpen(path), onFocus(path);
    },
    [onFocus, onPathOpen]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      DocumentInspectorHeader,
      {
        as: "header",
        closeButtonLabel: t("panel.close-button-aria-label"),
        flex: "none",
        onClose,
        title: t("panel.title")
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Card, { flex: 1, overflow: "auto", padding: 3, children: [
      validation.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: t("panel.no-errors-message") }) }),
      validation.length > 0 && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: validation.map((marker, i) => /* @__PURE__ */ jsxRuntime.jsx(
        ValidationCard,
        {
          marker,
          onOpen: handleOpen,
          schemaType,
          value
        },
        i
      )) })
    ] })
  ] });
}
function ValidationCard(props) {
  const { marker, onOpen, schemaType, value } = props, handleOpen = React.useCallback(() => onOpen(marker.path), [marker, onOpen]), [errorInfo, setErrorInfo] = React.useState(null);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.ErrorBoundary, { onCatch: setErrorInfo, children: [
    errorInfo && /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: errorInfo.error.message }) }),
    !errorInfo && /* @__PURE__ */ jsxRuntime.jsx(
      ui.Card,
      {
        __unstable_focusRing: !0,
        as: "button",
        onClick: handleOpen,
        padding: 3,
        radius: 2,
        tone: MARKER_TONE[marker.level],
        children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: React.createElement(MARKER_ICON[marker.level]) }) }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(
              DocumentNodePathBreadcrumbs,
              {
                path: marker.path,
                schemaType,
                value
              }
            ),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: marker.message })
          ] })
        ] })
      }
    )
  ] });
}
function DocumentNodePathBreadcrumbs(props) {
  const { path, schemaType, value } = props, pathTitles = React.useMemo(
    () => getPathTitles({ path, schemaType, value }),
    [path, schemaType, value]
  );
  return pathTitles.length ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: pathTitles.map((t, i) => /* @__PURE__ */ jsxRuntime.jsxs(React.Fragment, { children: [
    i > 0 && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { color: "var(--card-muted-fg-color)", opacity: 0.5 }, children: " / " }),
    /* @__PURE__ */ jsxRuntime.jsx("span", { style: { fontWeight: 500 }, children: t.title || t.name })
  ] }, i)) }) : null;
}
function useMenuItem(props) {
  const { documentId, documentType } = props, { t } = sanity.useTranslation("validation"), { validation: validationMarkers } = sanity.useValidationStatus(documentId, documentType), validation = React.useMemo(
    () => validationMarkers.map((item) => ({
      level: item.level,
      message: item.message,
      path: item.path
    })),
    [validationMarkers]
  ), hasErrors = validation.some(sanity.isValidationError), hasWarnings = validation.some(sanity.isValidationWarning), icon = React.useMemo(() => hasErrors ? icons.ErrorOutlineIcon : hasWarnings ? icons.WarningOutlineIcon : icons.CheckmarkCircleIcon, [hasErrors, hasWarnings]), tone = React.useMemo(() => hasErrors ? "critical" : hasWarnings ? "caution" : "positive", [hasErrors, hasWarnings]);
  return {
    hidden: validation.length === 0,
    icon,
    title: t("panel.title"),
    tone,
    showAsAction: !0
  };
}
const validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
}, EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch {
    return console.warn("Failed to parse JSON parameters"), {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
const router = router$1.route.create("/", [
  // "Asynchronous intent resolving" route
  router$1.route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  router$1.route.create("/edit/:type/:editDocumentId", [
    router$1.route.create({
      path: "/:params",
      transform: { params: { toState: legacyEditParamsToState, toPath: legacyEditParamsToPath } }
    })
  ]),
  // The regular path - when the intent can be resolved to a specific pane
  router$1.route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [router$1.route.create("/:action", router$1.route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: { toState, toPath }
    }
  })
]), panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i, isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str), isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str), exclusiveParams = ["view", "since", "rev", "inspect", "comment"], isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = { ...initial, params: EMPTY_PARAMS, payload: void 0 };
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("=")), value = chunk.slice(key.length + 1);
      pane.params = { ...pane.params, [decodeURIComponent(key)]: decodeURIComponent(value) };
    } else
      isPayloadLike(chunk) ? pane.payload = tryParseBase64Payload(chunk) : console.warn("Unknown pane segment: %s - skipping", chunk);
    return pane;
  }, sibling);
}
function encodeChunks(pane, index, group) {
  const { payload, params = {}, id } = pane, [firstSibling] = group, paneIsFirstSibling = pane === firstSibling, sameAsFirst = index !== 0 && id === firstSibling.id, encodedPayload = typeof payload > "u" ? void 0 : router$1.encodeJsonParams(payload), encodedParams = Object.entries(params).filter((entry) => {
    var _a;
    const [key, value] = entry;
    if (!value)
      return !1;
    if (paneIsFirstSibling)
      return !0;
    const valueFromFirstSibling = (_a = firstSibling.params) == null ? void 0 : _a[key];
    return !(value === valueFromFirstSibling && !exclusiveParams.includes(key));
  }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  return str.indexOf(",{") !== -1 ? parseOldPanesSegment(str) : str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, { id });
    });
    return [
      firstSibling,
      ...restOfSiblings.map((sibling) => ({
        ...firstSibling,
        ...sibling,
        id: sibling.id || firstSibling.id,
        params: { ...omit__default.default(firstSibling.params, exclusiveParams), ...sibling.params },
        payload: sibling.payload || firstSibling.payload
      }))
    ];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  for (; buffer.length; ) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({ id, payload }), buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? router$1.decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
const documentActions = [
  PublishAction,
  UnpublishAction,
  DiscardChangesAction,
  DuplicateAction,
  DeleteAction,
  HistoryRestoreAction
], documentBadges = [LiveEditBadge], inspectors = [validationInspector, changesInspector], structureTool = sanity.definePlugin((options) => {
  const icon = (options == null ? void 0 : options.icon) || icons.MasterDetailIcon;
  return {
    name: "sanity/structure",
    document: {
      actions: (prevActions) => Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions])),
      badges: (prevBadges) => Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges])),
      inspectors: (prevInspectors) => Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]))
    },
    plugins: [comments(), tasks()],
    tools: [
      {
        name: (options == null ? void 0 : options.name) || "structure",
        title: (options == null ? void 0 : options.title) || "Structure",
        icon,
        component: React.lazy(() => Promise.resolve().then(function() {
          return require("./index3.js");
        })),
        canHandleIntent: (intent, params) => intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : !1,
        getIntentState,
        // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
        controlsDocumentTitle: !0,
        options,
        router
      }
    ],
    i18n: {
      bundles: [structureUsEnglishLocaleBundle]
    }
  };
});
function canHandleCreateIntent(params) {
  return "type" in params ? "template" in params ? { template: !0 } : !0 : !1;
}
function canHandleEditIntent(params) {
  return "id" in params ? "mode" in params ? { mode: params.mode === "structure" } : !0 : !1;
}
function StructureToolProvider({
  defaultDocumentNode,
  structure: resolveStructure,
  children
}) {
  const [layoutCollapsed, setLayoutCollapsed] = React.useState(!1), source = sanity.useSource(), configContext = sanity.useConfigContextFromSource(source), documentStore = sanity.useDocumentStore(), S = React.useMemo(() => createStructureBuilder({
    defaultDocumentNode,
    source
  }), [defaultDocumentNode, source]), rootPaneNode = React.useMemo(() => resolveStructure ? resolveStructure(S, {
    ...configContext,
    documentStore
  }) : S.defaults(), [S, resolveStructure, configContext, documentStore]), features = React.useMemo(
    () => ({
      backButton: layoutCollapsed,
      resizablePanes: !layoutCollapsed,
      reviewChanges: !layoutCollapsed,
      splitPanes: !layoutCollapsed,
      splitViews: !layoutCollapsed
    }),
    [layoutCollapsed]
  ), structureTool2 = React.useMemo(() => ({
    features,
    layoutCollapsed,
    setLayoutCollapsed,
    rootPaneNode,
    structureContext: S.context
  }), [features, layoutCollapsed, rootPaneNode, S.context]);
  return /* @__PURE__ */ jsxRuntime.jsx(StructureToolContext.Provider, { value: structureTool2, children });
}
exports.BackLink = BackLink;
exports.ChildLink = ChildLink;
exports.CommentsIntentProvider = CommentsIntentProvider;
exports.ComponentBuilder = ComponentBuilder;
exports.ComponentViewBuilder = ComponentViewBuilder;
exports.ConfirmDeleteDialogContainer = ConfirmDeleteDialogContainer;
exports.DEFAULT_INTENT_HANDLER = DEFAULT_INTENT_HANDLER;
exports.DocumentBuilder = DocumentBuilder;
exports.DocumentInspectorHeader = DocumentInspectorHeader;
exports.DocumentListBuilder = DocumentListBuilder;
exports.DocumentListItemBuilder = DocumentListItemBuilder;
exports.DocumentListPane = DocumentListPane;
exports.DocumentPane = DocumentPane;
exports.DocumentPaneProvider = DocumentPaneProvider;
exports.DocumentTypeListBuilder = DocumentTypeListBuilder;
exports.FormViewBuilder = FormViewBuilder;
exports.GenericListBuilder = GenericListBuilder;
exports.GenericViewBuilder = GenericViewBuilder;
exports.HELP_URL = HELP_URL;
exports.InitialValueTemplateItemBuilder = InitialValueTemplateItemBuilder;
exports.LOADING_PANE = LOADING_PANE;
exports.ListBuilder = ListBuilder;
exports.ListItemBuilder = ListItemBuilder;
exports.LoadingPane = LoadingPane;
exports.MenuItemBuilder = MenuItemBuilder;
exports.MenuItemGroupBuilder = MenuItemGroupBuilder;
exports.Pane = Pane;
exports.PaneContent = PaneContent;
exports.PaneHeader = PaneHeader;
exports.PaneHeaderActions = PaneHeaderActions;
exports.PaneItem = PaneItem;
exports.PaneLayout = PaneLayout;
exports.PaneRouterContext = PaneRouterContext;
exports.ParameterizedLink = ParameterizedLink;
exports.ReferenceChildLink = ReferenceChildLink;
exports.SerializeError = SerializeError;
exports.StructureToolProvider = StructureToolProvider;
exports._DEBUG = _DEBUG;
exports.component = component;
exports.createStructureBuilder = createStructureBuilder;
exports.defaultInitialValueTemplateItems = defaultInitialValueTemplateItems;
exports.defaultIntentChecker = defaultIntentChecker;
exports.documentFromEditor = documentFromEditor;
exports.documentFromEditorWithInitialValue = documentFromEditorWithInitialValue;
exports.form = form;
exports.getOrderingMenuItem = getOrderingMenuItem;
exports.getOrderingMenuItemsForSchemaType = getOrderingMenuItemsForSchemaType;
exports.getTypeNamesFromFilter = getTypeNamesFromFilter;
exports.isDocumentListItem = isDocumentListItem;
exports.maybeSerializeInitialValueTemplateItem = maybeSerializeInitialValueTemplateItem;
exports.maybeSerializeMenuItem = maybeSerializeMenuItem;
exports.maybeSerializeMenuItemGroup = maybeSerializeMenuItemGroup;
exports.maybeSerializeView = maybeSerializeView;
exports.menuItemsFromInitialValueTemplateItems = menuItemsFromInitialValueTemplateItems;
exports.setActivePanes = setActivePanes;
exports.shallowIntentChecker = shallowIntentChecker;
exports.structureLocaleNamespace = structureLocaleNamespace;
exports.structureTool = structureTool;
exports.useDocumentPane = useDocumentPane;
exports.useDocumentTitle = useDocumentTitle;
exports.usePane = usePane;
exports.usePaneLayout = usePaneLayout;
exports.usePaneRouter = usePaneRouter;
exports.useStructureTool = useStructureTool;
//# sourceMappingURL=StructureToolProvider.js.map
